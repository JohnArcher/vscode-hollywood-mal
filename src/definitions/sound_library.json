[
  {
    "name": "CloseAudio",
    "helpId": "CloseAudio",
    "shortDescription": "close audio hardware",
    "version": "8.0",
    "synopsis": "CloseAudio()",
    "functionDocs": "This function can be used to close the audio hardware. It is normally not necessary to call this command because Hollywood will automatically close the audio hardware when it no longer needs it. On AmigaOS and compatibles, however, there are situations where you might need fine-tuned control over the audio hardware, for example because another program tries to get exclusive access to the audio hardware, which means that your script has to release it first. In those situations you might want to call `CloseAudio()` manually. Apart from that particular situation, there is no need to call this function at all.\n\nNote that calling `CloseAudio()` will not only stop all audio output but it will also free all samples because samples are usually uploaded to sound card memory when they are loaded so it is impossible to keep them in memory while the audio hardware is closed. Music and video objects, however, aren't freed by `CloseAudio()`, though. `CloseAudio()` will only stop their playback.",
    "inputsDocs": "none",
    "example": "See [OpenAudio](https://www.hollywood-mal.com/docs/html/hollywood/OpenAudio_.html)",
    "platforms": ["All"],
    "insertText": "CloseAudio()"
  },
  {
    "name": "CloseMusic",
    "helpId": "CloseMusic",
    "shortDescription": "close a music object",
    "version": "2.0",
    "synopsis": "CloseMusic(id)",
    "functionDocs": "This function frees any memory occupied by the music object specified by `id` and closes the file. This is normally not necessary because Hollywood frees all memory when it quits. However, if you are running out of memory and want to free the music object by yourself, use this function.",
    "inputsDocs": "* `id` — identifier of the music object to close",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "CloseMusic(${1:id})"
  },
  {
    "name": "CopySample",
    "helpId": "CopySample",
    "shortDescription": "clone a sample",
    "version": "5.0",
    "synopsis": "[id] = CopySample(source, dest)",
    "functionDocs": "This function clones the samples specified by `source` and creates a copy of it as sample `dest`. The new sample is independent from the old one so you could free the source sample after it has been cloned.\n\nIf you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as `dest`, `CopySample()` will return a handle to the new sample to you. Otherwise the new sample will use the identifier specified in `dest`.",
    "inputsDocs": "* `source` — source sample id\n* `dest` — identifier of the sample to be created or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)",
    "resultsDocs": "* `id` — optional: handle to the new sample; will only be returned if you specified [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `dest`",
    "example": "```\nCopySample(1, 10)\nFreeSample(1)\n```\n\nThe above code creates a new sample 10 which contains the same audio data as sample 1. Then it frees sample 1 because it is no longer needed.",
    "platforms": ["All"],
    "insertText": "CopySample(${1:source}, ${2:dest})"
  },
  {
    "name": "CreateMusic",
    "helpId": "CreateMusic",
    "shortDescription": "create dynamic music stream",
    "version": "5.0",
    "synopsis": "[id] = CreateMusic(id, pitch, fmt)",
    "functionDocs": "This function can be used to create a dynamic music stream that has to be fed constantly with new PCM data through a user defined callback function. This allows you to play gapless audio using PCM data generated on the fly by a callback function. The music object will be added to Hollywood's music list and can be accessed through the specified id. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `CreateMusic()` will automatically select an identifier and return it to you. You also have to specify the desired playback frequency for the music in the `pitch` argument as well as the encoding of the PCM data in the `fmt` argument. Currently, the following formats are supported: `#MONO8`, `#STEREO8`, `#MONO16`, and `#STEREO16`.\n\nBefore you call this function, you have to install a callback function of type `FillMusicBuffer` using the [InstallEventHandler()](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html) function. This callback will then be called whenever the audio server needs new PCM data. To deliver the new PCM data to the audio server, your callback has to call the [FillMusicBuffer()](https://www.hollywood-mal.com/docs/html/hollywood/FillMusicBuffer_.html) function. See [FillMusicBuffer](https://www.hollywood-mal.com/docs/html/hollywood/FillMusicBuffer_.html).\n\nOnce you have created the music object using `CreateMusic()`, you can then use all the regular commands from the music library to work with the new music. For instance, you can use [PlayMusic()](https://www.hollywood-mal.com/docs/html/hollywood/PlayMusic_.html) to start playback and [PauseMusic()](https://www.hollywood-mal.com/docs/html/hollywood/PauseMusic_.html) to pause the music object.\n\nMake sure that you always use a main loop that calls [WaitEvent()](https://www.hollywood-mal.com/docs/html/hollywood/WaitEvent_.html) when you use this function because the callback function of `CreateMusic()` will always be called by [WaitEvent()](https://www.hollywood-mal.com/docs/html/hollywood/WaitEvent_.html)! If you do not use a [WaitEvent()](https://www.hollywood-mal.com/docs/html/hollywood/WaitEvent_.html) loop, your callback will never get called and thus no sound will ever play!\n\nPlease note that this is a lowlevel function that runs pretty close on the hardware level. Thus, your callback function should never block your script for a longer time. It should return as soon as possible. Never call any functions that could block the script in `CreateMusic()` callback functions. For instance, calling [Wait()](https://www.hollywood-mal.com/docs/html/hollywood/Wait_.html) or [SystemRequest()](https://www.hollywood-mal.com/docs/html/hollywood/SystemRequest_.html) in a music callback is a very bad idea.",
    "inputsDocs": "* `id` — identifier for the new music or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `pitch` — desired playback frequency for the music object\n* `fmt` — desired format for the music object",
    "resultsDocs": "* `id` — optional: identifier of new music object; this is only used if [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) is passed in the first argument",
    "platforms": ["All"],
    "insertText": "CreateMusic(${1:id}, ${2:pitch}, ${3:fmt})"
  },
  {
    "name": "CreateSample",
    "helpId": "CreateSample",
    "shortDescription": "create a sample",
    "version": "2.0",
    "synopsis": "[id] = CreateSample(id, table, pitch[, fmt, length])",
    "functionDocs": "This function can be used to create a new sample from custom PCM data. The sample will be added to Hollywood's sample list and can be accessed by the specified id. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `CreateSample()` will automatically select an identifier and return it to you. You also have to specify the desired playback frequency for this sample in the pitch argument. The optional argument `fmt` allows you to specify the format of the PCM data you are about to pass to this function. Currently, the following formats are supported: `#MONO8` (which is the default), `#STEREO8`, `#MONO16`, and `#STEREO16`. The optional argument `length` specifies the desired length in PCM frames for the new samples.\n\nThe sample data must be passed as signed integers. For 8-bit samples the valid sample range runs from -128 to 127, and for 16-bit samples the valid sample range runs from -32768 to 32767.\n\nIf you want to create a stereo sample, you must pass interleaved PCM data, i.e. left channel sample is followed by right channel sample is followed by left channel sample, and so on.\n\nStarting with Hollywood 5.0, the PCM data can be passed to this function in a number of different ways. `CreateSample()` can use an array of PCM samples, an identifier of an open file, or a memory block as the source for the new sample. Which source is used depends on the setting in the table argument which accepts the following tags:\n\n- `Source`: This tag specifies from which source `CreateSample()` should fetch the audio data for the sample. It must be set to a string that identifies the audio data source. The following sources are possible:\n\n  - `\"PCM\"` Fetch audio data directly from an array of PCM samples. If you specify this field, you must pass the PCM data in the same table starting at index 0. `CreateSample()` will then read `length` PCM frames from this table. If `length` is not specified, then `CreateSample()` will read all PCM frames from the table.\n\n  - `\"File\"` Fetch audio data from an open file. If you use this source type, you also need to specify a valid file identifier in the `ID` tag. It is also necessary to specify the optional `length` argument so that `CreateSample()` knows how many frames it should fetch from the specified file.\n\n  - `\"Memory\"` Fetch audio data from a memory block. If you use this source type, you also need to specify a valid memory block identifier in the `ID` tag. It is also necessary to specify the optional `length` argument so that `CreateSample()` knows how many frames it should fetch from the specified memory block.\n\n  The default value for the `Source` tag is `PCM` which means fetch the audio data from an array of PCM samples stored in the same table as these options.\n\n- `ID`: This tag is only required for source types `File` and `Memory`. In that case, you need to pass a valid file / memory block identifier here.\n\n- `Offset`: This tag can only be used in conjunction with source type `Memory`. In that case, it specifies an offset into the memory block at which `CreateSample()` should start fetching audio data. The offset is specified in bytes.\n\n- `Swap`: This tag can only be used in conjunction with source types `File` and `Memory` and a sample depth of 16 bits. In that case, the `Swap` tag can be used to specify whether or not `CreateSample()` should swap the two bytes making up a 16 bit sample. This is required if the sample data in the file or memory block is encoded in little endian format (LSB first). `CreateSample()`, however, requires 16-bit sample data to be in big endian format (MSB first). So if your source can only provide sample data in LSB format, simply set the `Swap` tag to `True` and everything should be fine. This tag defaults to `False` which means do not swap anything.\n\nPlease note that the new sample should use at least 1000 PCM frames. If you use less frames, the playback in loop mode will become very CPU intensive. Even if your sample has only 32 different wave forms, you should concatenate them until your sample has at least 1000 frames for performance reasons.\n\nIf you pass large sample tables to this function, please do not forget to set these tables to [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) when you no longer need them. Otherwise you will waste great amounts of memory.\n\nStarting with Hollywood 5.0, `CreateSample()` can also create empty samples if you pass an empty table or specify a length of zero. In that case, you can use functions like [InsertSample()](https://www.hollywood-mal.com/docs/html/hollywood/InsertSample_.html) to fill the sample with audio data later.",
    "inputsDocs": "* `id` — identifier for the new sample or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `table` — table containing parameters for the new sample\n* `pitch` — desired playback frequency for the sample\n* `fmt` — optional: format of the samples passed in argument 2 (defaults to `#MONO8`) (V5.0)\n* `length` — optional: desired length of the new sample in PCM frames (V5.0)",
    "resultsDocs": "* `id` — optional: identifier of new sample; this is only used if `Nil` is passed in the first argument",
    "example": "```\nsmpdata = {}\nslen = 32\nFor k = 0 To 30\n  For i = 0 To (slen\\2)-1\n    smpdata[k*slen+i] = -128\n    smpdata[k*slen+i+(slen\\2)] = 127\n  Next\nNext\nCreateSample(1, smpdata, 6982)\nPlaySample(1)\n```\n\nThe code above creates a simple beep sound.",
    "platforms": ["All"],
    "insertText": "CreateSample(${1:id}, ${2:table}, ${3:pitch})"
  },
  {
    "name": "FillMusicBuffer",
    "helpId": "FillMusicBuffer",
    "shortDescription": "feed sound server with new audio data",
    "version": "5.0",
    "synopsis": "FillMusicBuffer(id, type$, samples[, table])",
    "functionDocs": "This function is used in connection with dynamic music streams that have been initialized using [CreateMusic()](https://www.hollywood-mal.com/docs/html/hollywood/CreateMusic_.html). These dynamic music streams need to be constantly fed with new audio data. This is handled by `FillMusicBuffer()`. `FillMusicBuffer()` will send the specified audio data to Hollywood's sound server which will in turn send it to the audio device. This chain of processors makes it possible to play gapless, dynamically generated audio data from your script.\n\nHollywood's sound server decides when it needs more audio data and thus the sound server is also the one that decides when you have to call `FillMusicBuffer()`. Hollywood will notify you when it needs more audio data by raising a `FillMusicBuffer` event so that the callback function you provided using the [InstallEventHandler()](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html) function will get called. Inside this callback function you will now have to call `FillMusicBuffer()` to feed new data to the sound server. It is not allowed to call `FillMusicBuffer()` at other times! You must only call it inside of a callback function of type `FillMusicBuffer`.\n\nThis function takes four arguments: The first one specifies the music object to use. Your callback will receive this information in the `ID` tag of the event message. The third argument specifies how many samples (in PCM frames) you are providing to the audio server. This must be set to exactly the same number of frames that are requested from you by the callback handler. You get the number of frames requested from you in the `Samples` tag of the event message. The table argument is optional and must only be used for certain types (see below). The `type$` argument specifies how you will provide the new PCM data to the audio server. This can be one of the following strings:\n\n- `\"PCM\"` You will provide the new PCM data directly. In this case, you have to put an array that contains the new PCM frames into the `Data` tag of the optional table argument (see below).\n\n- `\"Sample\"` You will provide the new PCM data in the form of a sample. In this case, you have to put the identifier of the sample in the `ID` tag of the optional table argument (see below). Furthermore, you can use the `Start`, `End`, `Offset`, and `Loop` tags to fine-tune the method that the audio server should use to fetch new PCM data. See below for more information.\n\n- `\"Mute\"` If you specify this type, the audio server will mute audio output for the duration of the number of PCM frames requested. If you pass `Mute` in the `Type` tag, you do not have to specify anything else.\n\n- `\"End\"` Specify this type if you want playback of your music to stop. Once the audio server receives an `End` packet, it will wait until all queued packets have been played and will stop the playback of your music thereafter.\n\nThe tags in the optional table argument depend on the type specified in `type$`. The following tags are recognized:\n\n- `Data`: If `type$` is set to `PCM`, you need to return an array of PCM data in this tag. The array should contain as many frames as requested by the audio server in the `Samples` tag. The PCM data must be passed as signed integers. For 8-bit data the valid sample range runs from -128 to 127, and for 16-bit data the valid sample range runs from -32768 to 32767. If you are using stereo mode, you must pass interleaved PCM data, i.e. left channel sample is followed by right channel sample is followed by left channel sample, and so on.\n\n- `ID`: If `type$` is set to `Sample`, you need to return the identifier of a sample from which the audio server should fetch the PCM data in this tag. You can fine-tune the way the audio server fetches the PCM data from this sample using the `Start`, `End`, `Offset`, and `Loop` tags. See below for more information.\n\n- `Start, End`: If `type$` is set to `Sample`, these two tags allow you to specify the range in the source sample that the audio server should use for fetching samples. This is useful if you want the audio server to fetch data from only a part of the sample. Both values have to be specified in PCM frames. These tags default to 0 for `Start` and length of the specified sample for `End`. This means that by default the whole sample will be used for fetching PCM data.\n\n- `Offset`: Specifies an offset into the sample at which the audio server should start fetching PCM data. This offset must be specified in PCM frames and is relative to the position specified in `Start`. For instance, if you pass 10000 in `Start` and 100 in `Offset`, then the audio server will start fetching PCM data from offset 10100. This tag defaults to 0 which means start fetching PCM data from the beginning of the sample.\n\n- `Loop`: Specifies whether or not the audio server should continue fetching PCM data at the beginning of the source sample once its end has been reached. This defaults to `True` which means that the audio server will automatically revert to the beginning of the sample if its end has been reached and more PCM data is required. The beginning of the sample is defined by the value specified in the `Start` tag.\n\nPlease note that you have to use [FlushMusicBuffer()](https://www.hollywood-mal.com/docs/html/hollywood/FlushMusicBuffer_.html) if you need to update the audio data with a very low latency. `FillMusicBuffer()` will always buffer about 1 second of music data. This means that it will take about 1 second from the call to `FillMusicBuffer()` until you can actually hear the audio data that you've just sent. If you need to update the audio data in real-time, e.g. when seeking to a new position in the stream, you will have to flush the music buffer first. See [FlushMusicBuffer](https://www.hollywood-mal.com/docs/html/hollywood/FlushMusicBuffer_.html).",
    "inputsDocs": "* `id` — identifier of the music object to use\n* `type$` — desired way for providing new audio data to the device (see above)\n* `samples` — number of samples that you are providing in PCM frames; must be identical to the number of samples requested by the `FillMusicBuffer` event\n* `table` — optional: table containing further options (see above)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "FillMusicBuffer(${1:id}, ${2:type$}, ${3:samples})"
  },
  {
    "name": "FlushMusicBuffer",
    "helpId": "FlushMusicBuffer",
    "shortDescription": "flush buffer of dynamic music stream",
    "version": "6.0",
    "synopsis": "FlushMusicBuffer(id)",
    "functionDocs": "This function is used in connection with dynamic music streams that have been initialized using [CreateMusic()](https://www.hollywood-mal.com/docs/html/hollywood/CreateMusic_.html). These dynamic music streams need to be constantly fed with new audio data which is done by repeatedly calling [FillMusicBuffer()](https://www.hollywood-mal.com/docs/html/hollywood/FillMusicBuffer_.html). `FlushMusicBuffer()` can be used to empty all music buffers and refill them with new data. This can be useful if you need to immediately update the audio data that is being played, for example because the user has seeked the music stream to a new position. After the call to `FlushMusicBuffer()`, Hollywood will immediately trigger a `FillMusicBuffer` event so that your script gets a chance to refill the audio buffers after they have been flushed.\n\nBy default, there will always be a lag of about 1 second between the call to [FillMusicBuffer()](https://www.hollywood-mal.com/docs/html/hollywood/FillMusicBuffer_.html) and the time you can hear the audio data on your sound device. If you call `FlushMusicBuffer()` first, the data can be sent to the sound device with a lower latency.\n\nSee [FillMusicBuffer](https://www.hollywood-mal.com/docs/html/hollywood/FillMusicBuffer_.html).",
    "inputsDocs": "* `id` — identifier of the music object to flush",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "FlushMusicBuffer(${1:id})"
  },
  {
    "name": "ForceSound",
    "helpId": "ForceSound",
    "shortDescription": "fail if audio hardware cannot be allocated",
    "version": "8.0",
    "synopsis": "ForceSound(fail)",
    "functionDocs": "Normally, when a script tries to play a sound and the audio hardware cannot be allocated, Hollywood will continue running normally, just without sound. If you don't want that, i.e. if you want Hollywood to fail in case the audio hardware cannot be allocated, call this function and pass `True` in the `fail` parameter. In that case Hollywood will throw an error in case the audio hardware cannot be allocated.\n\nNote that alternatively, you can also check the result of [IsSound()](https://www.hollywood-mal.com/docs/html/hollywood/IsSound_.html) to see if the audio hardware can be allocated. See [IsSound](https://www.hollywood-mal.com/docs/html/hollywood/IsSound_.html).",
    "inputsDocs": "* `fail` — specifies whether or not Hollywood should fail if the audio hardware cannot be allocated (the default setting is `False`, which means that Hollywood won't fail)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "ForceSound(${1:fail})"
  },
  {
    "name": "FreeModule",
    "helpId": "FreeModule",
    "shortDescription": "free a module / OBSOLETE",
    "version": "1.0",
    "synopsis": "FreeModule(id)",
    "functionDocs": "Important note: This command is obsolete. Please use [CloseMusic()](https://www.hollywood-mal.com/docs/html/hollywood/CloseMusic_.html) instead.\n\nThis function frees the memory of the module specified by `id`. This is normally not necessary because Hollywood frees all memory when it quits. However, if you are running out of memory and want to free the sample by yourself, use this function.",
    "inputsDocs": "* `id` — identifier of the module",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "FreeModule(${1:id})"
  },
  {
    "name": "FreeSample",
    "helpId": "FreeSample",
    "shortDescription": "free a sample",
    "version": "1.0",
    "synopsis": "FreeSample(id)",
    "functionDocs": "This function frees the memory of the sample specified by `id`. This is normally not necessary because Hollywood frees all memory when it quits. However, if you are running out of memory and want to free the sample by yourself, use this function.",
    "inputsDocs": "* `id` — identifier of the sample",
    "example": "See [LoadSample](https://www.hollywood-mal.com/docs/html/hollywood/LoadSample_.html)",
    "platforms": ["All"],
    "insertText": "FreeSample(${1:id})"
  },
  {
    "name": "GetChannels",
    "helpId": "GetChannels",
    "shortDescription": "get number of available channels",
    "version": "6.1",
    "synopsis": "n = GetChannels()",
    "functionDocs": "This function returns the total number of available channels for audio output. This defaults to 8 but can be changed by using the `-numchannels` console argument. See [Console arguments](https://www.hollywood-mal.com/docs/html/hollywood/ManualUsage_.html).\n\nNote that this argument doesn't return the free audio channels but the total audio channels. To check if there is a channel that can be used for audio output, use the [HaveFreeChannel()](https://www.hollywood-mal.com/docs/html/hollywood/HaveFreeChannel_.html) function instead. See [HaveFreeChannel](https://www.hollywood-mal.com/docs/html/hollywood/HaveFreeChannel_.html).\n\nAlso note that if the legacy audio driver is active on AmigaOS (it is by default on AmigaOS 3.x for performance reasons) the first four channels will be reserved for Protracker playback. The console argument `-nolegacyaudio` can be used to disable the legacy audio driver on AmigaOS 3.x. See [console arguments](https://www.hollywood-mal.com/docs/html/hollywood/ManualUsage_.html).",
    "inputsDocs": "none",
    "resultsDocs": "* `n` — total number of available channels",
    "platforms": ["All"],
    "insertText": "GetChannels()"
  },
  {
    "name": "GetPatternPosition",
    "helpId": "GetPatternPosition",
    "shortDescription": "get current pattern position",
    "version": "1.9",
    "synopsis": "pos = GetPatternPosition()",
    "functionDocs": "This function returns the pattern position of the currently playing Protracker module. If no module is playing, -1 is returned. You can time your script to the music with this function.\n\nYou can also use [WaitPatternPosition()](https://www.hollywood-mal.com/docs/html/hollywood/WaitPatternPosition_.html) which halts the program flow until a certain pattern position is reached.",
    "inputsDocs": "none",
    "resultsDocs": "* `pos` — current pattern position or -1",
    "platforms": ["All"],
    "insertText": "GetPatternPosition()"
  },
  {
    "name": "GetSampleData",
    "helpId": "GetSampleData",
    "shortDescription": "retrieve sample's raw data",
    "version": "5.0",
    "synopsis": "table, count = GetSampleData(id)",
    "functionDocs": "This function can be used to retrieve the raw PCM samples of the sample specified in `id`. The PCM samples will be returned inside a table. The format of the individual samples will be either 8-bit signed (ranging from -128 to +127) or 16-bit signed (ranging from -32768 to 32767). You can find out the sample format by querying the `#ATTRTYPE` of the sample using the [GetAttribute()](https://www.hollywood-mal.com/docs/html/hollywood/GetAttribute_.html) function. If the sample uses two channels (i.e. stereo), the PCM data will be returned in interleaved order, i.e. left channel sample is followed by right channel sample is followed by left channel sample, and so on.\n\nThe second return value of this function is a counter value that indicates the number of sample frames in the table. Be warned that this value does not return the actual total array elements but the number of sample frames. For stereo samples, the left and right channel samples together form a single sample frame. Thus, if you get stereo data, there will be twice as many samples in the table than indicated by `count` because the latter counts in sample frames instead of raw samples.\n\nIf you get large sample tables from this function, please do not forget to set these tables to [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) when you no longer need them. Otherwise you will waste great amounts of memory.\n\nTo convert a table of PCM data back into a sample, you can use the [CreateSample()](https://www.hollywood-mal.com/docs/html/hollywood/CreateSample_.html) command.",
    "inputsDocs": "* `id` — identifier of sample to use",
    "resultsDocs": "* `table` — a table containing the raw PCM data of the specified sample\n* `count` — number of sample frames inside the table",
    "platforms": ["All"],
    "insertText": "GetSampleData(${1:id})"
  },
  {
    "name": "GetSongPosition",
    "helpId": "GetSongPosition",
    "shortDescription": "get current song position",
    "version": "1.9",
    "synopsis": "pos = GetSongPosition()",
    "functionDocs": "This function returns the song position of the currently playing Protracker module. If no module is playing, -1 is returned. You can time your script to the music with this function.\n\nYou can also [WaitSongPosition()](https://www.hollywood-mal.com/docs/html/hollywood/WaitSongPosition_.html) which halts the program flow until a certain song position is reached.",
    "inputsDocs": "none",
    "resultsDocs": "* `pos` — current song position or -1",
    "platforms": ["All"],
    "insertText": "GetSongPosition()"
  },
  {
    "name": "HaveFreeChannel",
    "helpId": "HaveFreeChannel",
    "shortDescription": "check if a free channel is available",
    "version": "6.1",
    "synopsis": "n = HaveFreeChannel()",
    "functionDocs": "This function checks if there is a free channel for audio output. If there is, `HaveFreeChannel()` will return the index of this channel, otherwise 0 is returned.\n\nNote that if the legacy audio driver is active on AmigaOS (it is by default on AmigaOS 3.x for performance reasons) the first four channels will be reserved for Protracker playback. The console argument `-nolegacyaudio` can be used to disable the legacy audio driver on AmigaOS 3.x. See [console arguments](https://www.hollywood-mal.com/docs/html/hollywood/ManualUsage_.html).",
    "inputsDocs": "none",
    "resultsDocs": "* `n` — index of free channel or 0 if all channels are currently occupied",
    "platforms": ["All"],
    "insertText": "HaveFreeChannel()"
  },
  {
    "name": "InsertSample",
    "helpId": "InsertSample",
    "shortDescription": "insert one sample into another one",
    "version": "5.0",
    "synopsis": "InsertSample(src, dst, pos[, len, table])",
    "functionDocs": "This function can be used to insert `len` PCM frames of the sample specified in `src` into PCM frame position `pos` of the sample specified in `dst`. If the optional argument `len` is not specified, the whole sample will be inserted into the position specified in `pos`. If the two samples do not use the same format, this function will automatically perform an appropriate conversion of the audio data so that sample depth, channel layout, and sampling rate of the two samples match.\n\nThe optional table argument allows you to configure advanced options for the insert operation. The following tags are currently recognized by the optional table argument:\n\n- `Start, End`: These two tags allow you to specify a range in the source sample that should be inserted into the destination one. This is useful if you want to insert only a part of the source sample into the destination. Both values have to be specified in PCM frames. These tags default to 0 for `Start` and length of the source sample for `End`. This means that by default the whole sample will be inserted.\n\n- `Offset`: Specifies an offset into the source sample at which `InsertSample()` should start fetching PCM data for the destination sample. This offset must be specified in PCM frames and is relative to the position specified in `Start`. For instance, if you pass 10000 in `Start` and 100 in `Offset`, then `InsertSample()` will start fetching PCM data at offset 10100. This tag defaults to 0 which means start fetching PCM data from the beginning of the source sample.\n\n- `Loop`: Specifies whether or not `InsertSample()` should continue to fetch PCM data at the beginning of the source sample once its end has been reached. This defaults to `True` which means `InsertSample()` will automatically revert to the beginning of the sample if its end has been reached and more PCM data is required. The beginning of the sample is defined by the value specified in the `Start` tag.\n\nPlease note that this command will extend the length of the destination sample. Existing audio data will not be overwritten. It will just be shifted forward by the insert operation.",
    "inputsDocs": "* `src` — identifier of the source sample\n* `dst` — identifier of the sample that shall be modified\n* `pos` — position in PCM frames where `src` should be inserted into `dst`\n* `len` — optional: number of PCM frames to insert into `src` (defaults to the length of `dst`)\n* `table` — optional: table containing further parameters (see above)",
    "example": "```\nInsertSample(1, 2, 44100, 44100, {Start = 25000, End = 30000})\n```\n\nThe code above inserts one second of audio data from sample 1 into sample 2. The sample will be inserted at offset 44100. Audio data will be fetched from sample 1 but only in the range of PCM frames 25000 to 30000 in a loop.",
    "platforms": ["All"],
    "insertText": "InsertSample(${1:src}, ${2:dst}, ${3:pos})"
  },
  {
    "name": "IsChannelPlaying",
    "helpId": "IsChannelPlaying",
    "shortDescription": "check if a channel is playing",
    "version": "6.1",
    "synopsis": "playing[, type, id] = IsChannelPlaying(n)",
    "functionDocs": "This function checks if the channel specified by `n` is currently playing and returns `True` if it is, `False` otherwise. If the channel is currently playing, `IsChannelPlaying()` will also return type and id of the object that is currently playing on this channel. This can be `#MUSIC`, `#SAMPLE`, or `#VIDEO`.",
    "inputsDocs": "* `n` — channel index to check; channel indices start from 1 to the number of available channels",
    "resultsDocs": "* `playing` — `True` if the channel is playing, `False` otherwise\n* `type` — optional: object type currently playing on this channel; only returned if the channel is currently playing\n* `id` — optional: object id currently playing on this channel; only returned if the channel is currently playing",
    "platforms": ["All"],
    "insertText": "IsChannelPlaying(${1:n})"
  },
  {
    "name": "IsModule",
    "helpId": "IsModule",
    "shortDescription": "determine if a module is in a supported format / OBSOLETE",
    "version": "1.0",
    "synopsis": "ret = IsModule(file$)",
    "functionDocs": "Important note: This command is obsolete. Please use [IsMusic()](https://www.hollywood-mal.com/docs/html/hollywood/IsMusic_.html) instead.\n\nThis function will check if the file specified `file$` is in a supported module format. If it is, this function will return `True`, otherwise `False`. If this function returns `True`, you can load the module by calling [LoadModule()](https://www.hollywood-mal.com/docs/html/hollywood/LoadModule_.html).",
    "inputsDocs": "* `file$` — file to check",
    "resultsDocs": "* `ret` — `True` if the module is in a supported format, `False` otherwise",
    "platforms": ["All"],
    "insertText": "IsModule(${1:file$})"
  },
  {
    "name": "IsMusicPlaying",
    "helpId": "IsMusicPlaying",
    "shortDescription": "check if music is currently playing",
    "version": "4.5",
    "synopsis": "playing = IsMusicPlaying(id)",
    "functionDocs": "This function checks if the music object specified by `id` is currently playing. If it is, `True` is returned, `False` otherwise.",
    "inputsDocs": "* `id` — identifier of music object to check",
    "resultsDocs": "* `playing` — `True` if music object is currently playing; `False` otherwise",
    "platforms": ["All"],
    "insertText": "IsMusicPlaying(${1:id})"
  },
  {
    "name": "IsMusic",
    "helpId": "IsMusic",
    "shortDescription": "determine if a file is in a supported music format",
    "version": "2.0",
    "synopsis": "ret, fmt$ = IsMusic(file$[, table])",
    "functionDocs": "This function will check if the file specified in `file$` is in a supported music format. If it is, this function will return `True` in the first return value, otherwise `False`. If this function returns `True`, you can open the music file using [OpenMusic()](https://www.hollywood-mal.com/docs/html/hollywood/OpenMusic_.html).\n\nThe second return value is a string containing the music format of the file.\n\nStarting with Hollywood 6.0 this function accepts an optional table argument which allows you to configure further options:\n\n- `Loader`: This tag allows you to specify one or more format loaders that should be asked to load this music object. This must be set to a string containing the name(s) of one or more loader(s). Defaults to the loader set using [SetDefaultLoader()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultLoader_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked to open the specified file. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to loaders and adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\nSee [OpenMusic](https://www.hollywood-mal.com/docs/html/hollywood/OpenMusic_.html).",
    "inputsDocs": "* `file$` — file to check\n* `table` — optional: table configuring further options (V6.0)",
    "resultsDocs": "* `ret` — `True` if the music object is in a supported format, `False` otherwise\n* `fmt$` — format of the music file",
    "platforms": ["All"],
    "insertText": "IsMusic(${1:file$})"
  },
  {
    "name": "IsSamplePlaying",
    "helpId": "IsSamplePlaying",
    "shortDescription": "check if a sample is playing",
    "version": "1.0",
    "synopsis": "playing = IsSamplePlaying(id)",
    "functionDocs": "This function checks if the sample specified by `id` is currently playing and returns `True` if it is, `False` otherwise.",
    "inputsDocs": "* `id` — identifier of a sample",
    "resultsDocs": "* `playing` — `True` if the sample specified by `id` is playing, `False` otherwise",
    "example": "```\nLoadSample(1, \"Sound/Samples/ChurchOrgan.wav\")\nPlaySample(1)\nRepeat\n  Wait(2)\nUntil IsSamplePlaying(1) = False\nFreeSample(1)\n```\n\nThe above code loads the sample \"Sound/Samples/ChurchOrgan.wav\", plays it and then waits for it to finish. After that, the sample is freed. If you just want to do something like above, it is easier for you to use the [WaitSampleEnd()](https://www.hollywood-mal.com/docs/html/hollywood/WaitSampleEnd_.html) command. But if you want to do some things during the sample is playing, you will have to do it this way (using `IsSamplePlaying()` and a loop).",
    "platforms": ["All"],
    "insertText": "IsSamplePlaying(${1:id})"
  },
  {
    "name": "IsSample",
    "helpId": "IsSample",
    "shortDescription": "determine if a sample is in a supported format",
    "version": "1.0",
    "synopsis": "ret = IsSample(file$[, table])",
    "functionDocs": "This function will check if the file specified `file$` is in a supported sample format. If it is, this function will return `True`, otherwise `False`. If this function returns `True`, you can load the sample by calling [LoadSample()](https://www.hollywood-mal.com/docs/html/hollywood/LoadSample_.html).\n\nStarting with Hollywood 6.0 this function accepts an optional table argument which allows you to configure further options:\n\n- `Loader`: This tag allows you to specify one or more format loaders that should be asked to load this sample. This must be set to a string containing the name(s) of one or more loader(s). Defaults to the loader set using [SetDefaultLoader()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultLoader_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked to open the specified file. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to loaders and adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `file$` — file to check\n* `table` — optional: table configuring further options (V6.0)",
    "resultsDocs": "* `ret` — `True` if the sample is in a supported format, `False` otherwise",
    "platforms": ["All"],
    "insertText": "IsSample(${1:file$})"
  },
  {
    "name": "IsSound",
    "helpId": "IsSound",
    "shortDescription": "determine if Hollywood can output audio",
    "version": "1.0",
    "synopsis": "ret = IsSound()",
    "functionDocs": "This function checks if Hollywood can output audio. You can use this function if your application cannot run without audio being output. Normally, if Hollywood cannot output audio it will just skip all audio related code and still execute the script. If you do not want that, use `IsSound()` to determine if audio can be output.\n\nStarting with Hollywood 8.0, you can also use the [ForceSound()](https://www.hollywood-mal.com/docs/html/hollywood/ForceSound_.html) function to make Hollywood fail if the audio hardware cannot be allocated. See [ForceSound](https://www.hollywood-mal.com/docs/html/hollywood/ForceSound_.html).",
    "inputsDocs": "none",
    "resultsDocs": "* `ret` — `True` if sound can be played, `False` otherwise",
    "example": "```\nIf IsSound() = False\n  SystemRequest(\"My App\", \"Sorry, sound is required!\", \"OK\")\n  End\nEndIf\n```\n\nThe above code checks if it can output sound and quits with a error message if this is not possible.",
    "platforms": ["All"],
    "insertText": "IsSound()"
  },
  {
    "name": "LoadModule",
    "helpId": "LoadModule",
    "shortDescription": "load a module / OBSOLETE",
    "version": "1.0",
    "synopsis": "LoadModule(id, filename$)",
    "functionDocs": "Important note: This command is obsolete. Please use [OpenMusic()](https://www.hollywood-mal.com/docs/html/hollywood/OpenMusic_.html) instead.\n\nThis function loads the module specified by `filename$` into memory and gives it the identifier `id`. The module must be in Protracker format.",
    "inputsDocs": "* `id` — identifier for the module\n* `filename$` — file to load",
    "example": "```\nLoadModule(5, \"Modules/StardustMemories.mod\")\n```\n\nThe above declaration assigns module number 5 to the module \"StardustMemories.mod\" located in a subdrawer named \"Modules\".",
    "platforms": ["All"],
    "insertText": "LoadModule(${1:id}, ${2:filename$})"
  },
  {
    "name": "LoadSample",
    "helpId": "LoadSample",
    "shortDescription": "load a sample",
    "version": "1.0",
    "synopsis": "[id] = LoadSample(id, filename$[, table])",
    "functionDocs": "This function loads the sample specified by `filename$` into memory and assigns the identifier `id` to it. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `LoadSample()` will automatically choose an identifier and return it.\n\nSample formats that are supported on all platforms are RIFF WAVE, IFF 8SVX, IFF 16SV, and sample formats you have a plugin for. Depending on the platform Hollywood is running on, more sample formats might be supported. For example, on Amiga compatible systems Hollywood will be able to open all sample formats you have datatypes for as well.\n\nStarting with Hollywood 6.0, this function accepts an optional table argument which allows you to pass additional parameters:\n\n- `Loader`: This tag allows you to specify one or more format loaders that should be asked to load this sample. This must be set to a string containing the name(s) of one or more loader(s). Defaults to the loader set using [SetDefaultLoader()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultLoader_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked to open the specified file. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to loaders and adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\nThis command is also available from the preprocessor: Use [@SAMPLE](https://www.hollywood-mal.com/docs/html/hollywood/atSAMPLE_.html) to preload samples!\n\nPlease note that this function loads sample data completely into memory. If you plan to play long samples, you should better use [OpenMusic()](https://www.hollywood-mal.com/docs/html/hollywood/OpenMusic_.html) which buffers only small portions of the sound data in memory.",
    "inputsDocs": "* `id` — identifier for the sample or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `filename$` — file to load\n* `table` — optional: table configuring further options (see above) (V6.0)",
    "resultsDocs": "* `id` — optional: identifier of the sample; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "example": "```\nLoadSample(1, \"Sound/Samples/WahWah.wav\")\nPlaySample(1)\nWaitSampleEnd(1)\nFreeSample(1)\n```\n\nThe above code loads the sample \"Sound/Samples/WahWah.wav\", plays it, waits for it to end and frees it.",
    "platforms": ["All"],
    "insertText": "LoadSample(${1:id}, ${2:filename$})"
  },
  {
    "name": "MixSample",
    "helpId": "MixSample",
    "shortDescription": "mix existing sample(s) into a new sample",
    "version": "5.0",
    "synopsis": "[id] = MixSample(id, len, pitch, fmt, smp1, opt1, ...)",
    "functionDocs": "This function can be used to mix one or more existing samples into a new sample. The new sample will be added to Hollywood's sample list and can be accessed by the specified id. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `MixSample()` will automatically select an identifier and return it to you. The second argument `len` specifies the desired length of the new sample in PCM frames. The third argument `pitch` specifies how many frames per second should be sent to the audio device. For CD quality, you would pass 44100 as the `pitch` argument but in many cases 22050 is also sufficient. The `fmt` argument specifies the desired sample format for the new sample. Currently, the following formats are supported: `#MONO8`, `#STEREO8`, `#MONO16`, and `#STEREO16`. The former two specify 8-bit PCM encodings while the latter two use 16-bits per channel.\n\nThe samples that should be mixed into the new sample are passed to `MixSample()` from argument 5 onwards. For each sample that should be mixed into the new sample you have to pass its identifier as well as a table that contains further parameters for the mixing operation. You can repeat this pattern as many times as you like. The options table that has to be passed for each sample supports the following tags:\n\n- `Pitch`: Specifies the frequency that should be used when mixing this sample. This tag defaults to the sample's current frequency defined using [SetPitch()](https://www.hollywood-mal.com/docs/html/hollywood/SetPitch_.html).\n\n- `Offset`: Specifies the offset inside the sample from which PCM data should be fetched for mixing. This must be specified in PCM frames. This tag defaults to 0 which means start fetching data from the beginning.\n\n- `Length`: Specifies the maximum number of PCM frames that should be mixed. Defaults to -1 which means mix as many frames as available into the new sample.\n\n- `Loop`: Specifies whether or not the mixer should continue to fetch PCM data at the beginning of the sample once its end has been reached. This defaults to `True` which means the mixer will automatically revert to the beginning of the sample if its end has been reached and more PCM data is required.\n\n- `Scale`: Specifies a scaling factor that should be applied to the mixing operation. If you are mixing many samples together, you are likely to get some noise artefacts you do not want. You can reduce these artefacts by reducing the volume level. This can be achieved using this tag. Every PCM frame will be multiplied with the scaling factor you pass here. Thus, to reduce the volume by 50%, simply pass 0.5 here. This tag defaults to 1.0 which means no scaling should be applied.\n\n- `Threshold`: This tag allows you to specify a threshold at which this sample should be mixed into the destination sample. For example, if you would like this sample to kick in after 10,000 PCM frames have been mixed, you would specify 10000 here. The value specified here must be passed in PCM frames. This tag defaults to 0 which means that this sample should be mixed into the destination sample right from the start.\n\nThis function is powerful. It will perform automatic conversion between different sample encodings, sampling rates, and channel layouts. Also, you can mix as many samples into the new sample as you like. The samples to be mixed can also be the same, i.e. you can mix the same sample into the new samples multiple times using different mixing parameters like varying pitch speed or thresholds. If you get unwanted noise artefacts, try reducing the volume of single samples using the `Scale` tag (see above).",
    "inputsDocs": "* `id` — identifier for the new sample or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `len` — desired length for the new sample in PCM frames\n* `pitch` — desired playback frequency for the new sample\n* `fmt` — desired format for the new sample\n* `smp1` — first sample to mix\n* `opt1` — options table for first sample to mix\n* `...` — optional: you can repeat the id/options sequence as often as you want so you can mix as many samples together as you like",
    "resultsDocs": "* `id` — optional: identifier of new sample; this is only used if [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) is passed in the first argument",
    "example": "```\nMixSample(1, 10 * 44100, 44100, #STEREO16, 2, {}, 3,\n          {Threshold = 3 * 44100}, 4, {6 * 44100})\n```\n\nThe code above creates a new sample in 44.1 format, using 16 bits per PCM frame and two channels. The sample's length will be exactly 10 seconds. The sample will start with sample 2. After three seconds sample 3 will kick in and after six seconds sample 4 will start to play.",
    "platforms": ["All"],
    "insertText": "MixSample(${1:id}, ${2:len}, ${3:pitch}, ${4:fmt}, ${5:smp1}, ${6:opt1})"
  },
  {
    "name": "OpenAudio",
    "helpId": "OpenAudio",
    "shortDescription": "open audio hardware",
    "version": "8.0",
    "synopsis": "OpenAudio()",
    "functionDocs": "This function can be used to open the audio hardware. It is normally not necessary to call this command because Hollywood will automatically open the audio hardware as soon as it needs it. On AmigaOS and compatibles, however, there are situations where you might need fine-tuned control over the audio hardware, for example because another program tries to get exclusive access to the audio hardware, which means that your script has to release it first. In those situations you might want to call `OpenAudio()` and [CloseAudio()](https://www.hollywood-mal.com/docs/html/hollywood/CloseAudio_.html) manually. Apart from that particular situation, there is no need to call these functions at all.",
    "inputsDocs": "none",
    "example": "```\nOpenAudio()\nOpenMusic(1, \"Turrican2_Remix.mod\")\nPlayMusic(1)\nWaitLeftMouse\nStopMusic(1)\nCloseAudio()\n```\n\nThe code above plays \"Turrican2_Remix.mod\" and then closes the audio hardware, making it possible for other programs on AmigaOS aiming for exclusive audio hardware access to reserve it.",
    "platforms": ["All"],
    "insertText": "OpenAudio()"
  },
  {
    "name": "OpenMusic",
    "helpId": "OpenMusic",
    "shortDescription": "open a music file",
    "version": "2.0",
    "synopsis": "[id] = OpenMusic(id, filename$[, table])",
    "functionDocs": "This function opens the music file specified by `filename$` and assigns the `id` to it. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `OpenMusic()` will automatically choose an identifier and return it. The file specified in `filename$` will be opened and prepared for playback. Please note that files opened using `OpenMusic()` will be played using audio streaming. [LoadSample()](https://www.hollywood-mal.com/docs/html/hollywood/LoadSample_.html) on the other hand, will load the entire sound file into memory first. Thus, you should use [LoadSample()](https://www.hollywood-mal.com/docs/html/hollywood/LoadSample_.html) for playing short sounds and `OpenMusic()` for longer sounds and background music.\n\nMusic formats that are supported on all platforms are RIFF WAVE, IFF 8SVX, IFF 16SV, Protracker modules, and formats you have a plugin for. Depending on the platform Hollywood is running on, more music formats might be supported. For example, on Windows, Hollywood supports all formats that DirectShow can load, and on macOS, all formats recognized by Apple's AudioFile interface are supported.\n\nStarting with Hollywood 6.0, this function accepts an optional table argument which allows you to pass additional parameters:\n\n- `Loader`: This tag allows you to specify one or more format loaders that should be asked to load this music file. This must be set to a string containing the name(s) of one or more loader(s). Defaults to the loader set using [SetDefaultLoader()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultLoader_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked to open the specified file. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to loaders and adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\nThis command is also available from the preprocessor: Use [@MUSIC](https://www.hollywood-mal.com/docs/html/hollywood/atMUSIC_.html) to preload music objects!",
    "inputsDocs": "* `id` — identifier for the music object or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `filename$` — file to load\n* `table` — optional: table configuring further options (see above) (V6.0)",
    "resultsDocs": "* `id` — optional: identifier of the music object; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "example": "```\nOpenMusic(1, \"Turrican2_Remix.mod\")\nPlayMusic(1)\n```\n\nThe code above plays \"Turrican2_Remix.mod\".",
    "platforms": ["All"],
    "insertText": "OpenMusic(${1:id}, ${2:filename$})"
  },
  {
    "name": "PauseModule",
    "helpId": "PauseModule",
    "shortDescription": "pause the currently playing module / OBSOLETE",
    "version": "1.0",
    "synopsis": "PauseModule()",
    "functionDocs": "Important note: This command is obsolete. Please use [PauseMusic()](https://www.hollywood-mal.com/docs/html/hollywood/PauseMusic_.html) instead.\n\nThis function pauses the currently playing module. It can be resumed with the [ResumeModule()](https://www.hollywood-mal.com/docs/html/hollywood/ResumeModule_.html).",
    "inputsDocs": "none",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "PauseModule()"
  },
  {
    "name": "PauseMusic",
    "helpId": "PauseMusic",
    "shortDescription": "pause a playing music",
    "version": "2.0",
    "synopsis": "PauseMusic(id)",
    "functionDocs": "This function pauses the music object with the identifier `id`. This music object must be playing when you call this command. You can resume the playback by using the [ResumeMusic()](https://www.hollywood-mal.com/docs/html/hollywood/ResumeMusic_.html) command.",
    "inputsDocs": "* `id` — identifier of the music object to pause",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "PauseMusic(${1:id})"
  },
  {
    "name": "PlayModule",
    "helpId": "PlayModule",
    "shortDescription": "start playing a music module / OBSOLETE",
    "version": "1.0",
    "synopsis": "PlayModule(number)",
    "functionDocs": "Important note: This command is obsolete. Please use [PlayMusic()](https://www.hollywood-mal.com/docs/html/hollywood/PlayMusic_.html) instead.\n\nStarts playing the music module with the number `number`. This music module must have been loaded with [LoadModule()](https://www.hollywood-mal.com/docs/html/hollywood/LoadModule_.html). If there is already a music module playing, it will be stopped automatically.",
    "inputsDocs": "* `number` — number of the music module to start",
    "example": "```\nLoadModule(1,\"StardustMemories.mod\")\nPlayModule(1)\n```",
    "platforms": ["All"],
    "insertText": "PlayModule(${1:number})"
  },
  {
    "name": "PlayMusic",
    "helpId": "PlayMusic",
    "shortDescription": "start playback of a music object",
    "version": "2.0",
    "synopsis": "PlayMusic(id[, table])",
    "functionDocs": "This command starts the playback of the music object specified by `id`. This music object must have been opened with either the [@MUSIC](https://www.hollywood-mal.com/docs/html/hollywood/atMUSIC_.html) preprocessor command or the [OpenMusic()](https://www.hollywood-mal.com/docs/html/hollywood/OpenMusic_.html) command.\n\nPlease note that before Hollywood 6.0 only one music could be played at a time. Starting with Hollywood 6.0 this limit is no longer there, but it is still enforced in order to be compatible with older scripts. Thus, if a music object is already playing and you call this command, that music will be stopped first before playback of the new music starts. If you need to play multiple music objects at the same time, you will have to explicitly disable this behaviour by calling [LegacyControl()](https://www.hollywood-mal.com/docs/html/hollywood/LegacyControl_.html) and setting the `SingleMusic` tag to `False`. `PlayMusic()` will no longer stop any playing music. See [LegacyControl](https://www.hollywood-mal.com/docs/html/hollywood/LegacyControl_.html).\n\nPrior to Hollywood 4.5, the second argument was optional and specified how many times the music object should be played. Starting with Hollywood 4.5, the second argument is now an optional table argument. Of course, the old syntax is still supported for compatibility. New scripts should use the new syntax though. The optional table argument recognizes the following tags:\n\n- `Times`: This tag can be used to specify how many times the music object shall be played. This tag defaults to 1 which means that the music object is only played once. If you want your music object to loop infinitely, pass 0 as the second argument.\n\n- `Volume`: Set this to the desired playback volume. This field can range from 0 to 64. If not specified, the music object's default volume will be used (you can modify the default volume of a music object by calling [SetMusicVolume()](https://www.hollywood-mal.com/docs/html/hollywood/SetMusicVolume_.html)).\n\n- `Channel`: Channel to use for playback of this music object. By default, `PlayMusic()` will automatically choose a vacant channel and will fail if there is no vacant channel. To override this behaviour, you can use this field. When specified, it will always enforce playback on the very channel specified here. If the channel is already playing, it will be stopped first. (V6.1)",
    "inputsDocs": "* `id` — identifier of the music object to start\n* `table` — optional: table argument specifying further options (V4.5)",
    "example": "See [OpenMusic](https://www.hollywood-mal.com/docs/html/hollywood/OpenMusic_.html)",
    "platforms": ["All"],
    "insertText": "PlayMusic(${1:id})"
  },
  {
    "name": "PlaySample",
    "helpId": "PlaySample",
    "shortDescription": "start playing a sample",
    "version": "1.0",
    "synopsis": "PlaySample(id[, table], ...)",
    "functionDocs": "Starts playing the sample specified by `id`. You can load samples either using the [LoadSample()](https://www.hollywood-mal.com/docs/html/hollywood/LoadSample_.html) command or by using the [@SAMPLE](https://www.hollywood-mal.com/docs/html/hollywood/atSAMPLE_.html) preprocessor command (the sample will be preloaded then).\n\nStarting with Hollywood 2.0, you can also pass a table as the second argument that defines parameters for the sample playback. The table can contain the following fields:\n\n- `Times`: This field can be used to specify how many times the sample shall be played. This defaults to 1 which means that the sample will be played once. If you want the sample to loop infinitely, set `Times` to 0.\n\n- `Volume`: Set this to the desired playback volume. This field can range from 0 to 64. If not specified, the sample's default volume will be used (you can modify the default volume of a sample by calling [SetVolume()](https://www.hollywood-mal.com/docs/html/hollywood/SetVolume_.html)).\n\n- `Pitch`: Set this to the desired playback pitch. This value has to be passed in hertz. If not specified, the sample's default pitch will be used (you can modify the default pitch of a sample by calling [SetPitch()](https://www.hollywood-mal.com/docs/html/hollywood/SetPitch_.html)).\n\n- `Time`: This field can be used to define how long the sample shall be played. Hollywood will loop the sample until the given time has elapsed. Time must be specified in milliseconds. This tag is mutually exclusive with the `Times` tag.\n\n- `Panning`: This field allows you to set the channel panning for this sample. This must be in the range of 0 to 255. 0 means left speaker playback only, 128 means both speakers, and 255 means right speaker only. If not specified, the sample's default pan setting will be used (you can modify the default panning of a sample by calling [SetPanning()](https://www.hollywood-mal.com/docs/html/hollywood/SetPanning_.html)). (V4.5)\n\n- `Channel`: Channel to use for playback of this sample. By default, `PlaySample()` will automatically choose a vacant channel and will fail if there is no vacant channel. To override this behaviour, you can use this field. When specified, it will always enforce playback on the very channel specified here. If the channel is already playing, it will be stopped first. (V6.1)\n\nAlso new in Hollywood 2.0 is the possibility to play multiple samples at once with one call to `PlaySample()`. Simply repeat the argument list as many times as you like and `PlaySample()` will play all specified samples together - perfectly synchronized. Please note that for each additional sample there is also an additional optional argument, that either specifies the number of times the sample shall be played or it is a table that contains further attributes for the sample playback. See above for all possibilities.",
    "inputsDocs": "* `id` — identifier of sample to play\n* `table` — a table that contains playback parameters for the sample (V2.0)\n* `...` — the argument list can be repeated as many times as you like; `PlaySample()` will start all samples at the same time if you specify more than one",
    "example": "```\nPlaySample(1)\n```\n\nThe above code starts playing sample 1. The sample will not be looped.\n\n---\n\n```\nPlaySample(1, {Time = 10000})\n```\n\nThe code above plays sample 1 for exactly 10 seconds (= 10000 milliseconds).\n\n---\n\n```\nPlaySample(1, {Times = 2}, 2, {Times = 4}, 3, {Time=5000})\n```\n\nThe code above plays sample 1 two times, sample 2 four times and sample 3 is played for 5 seconds. All three samples are started at once.",
    "platforms": ["All"],
    "insertText": "PlaySample(${1:id})"
  },
  {
    "name": "PlaySubsong",
    "helpId": "PlaySubsong",
    "shortDescription": "play subsong of music object",
    "version": "1.0",
    "synopsis": "PlaySubsong(number[, id, table])",
    "functionDocs": "This command can be used to play the specified subsong of a music object. If you omit the optional argument `id` the currently playing music is used.\n\nThe optional table argument can be used to specify further options. This table argument supports the same fields like the [PlayMusic()](https://www.hollywood-mal.com/docs/html/hollywood/PlayMusic_.html) command. See [PlayMusic](https://www.hollywood-mal.com/docs/html/hollywood/PlayMusic_.html).\n\nPlease note that only some music formats support subsongs. For example, old tracker module formats can often contain multiple subsongs. If a Protracker module is used, this command will jump to the specified song position.",
    "inputsDocs": "* `number` — number of subsong to play\n* `id` — optional: identifier of the music object to use (defaults to currently playing music) (V5.3)\n* `table` — optional: table argument specifying further options (V5.3)",
    "example": "```\nPlaySubsong(5, 1)\n```\n\nThe above code starts playing Protracker module number 1, starting at song position 5.",
    "platforms": ["All"],
    "insertText": "PlaySubsong(${1:number})"
  },
  {
    "name": "ResumeModule",
    "helpId": "ResumeModule",
    "shortDescription": "resume the paused module / OBSOLETE",
    "version": "1.0",
    "synopsis": "ResumeModule()",
    "functionDocs": "Important note: This command is obsolete. Please use [ResumeMusic()](https://www.hollywood-mal.com/docs/html/hollywood/ResumeMusic_.html) instead.\n\nThis function resumes the currently paused module. It can be paused with the [PauseModule()](https://www.hollywood-mal.com/docs/html/hollywood/PauseModule_.html).",
    "inputsDocs": "none",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "ResumeModule()"
  },
  {
    "name": "ResumeMusic",
    "helpId": "ResumeMusic",
    "shortDescription": "resume a paused music object",
    "version": "2.0",
    "synopsis": "ResumeMusic(id)",
    "functionDocs": "This function resumes the playback of the paused music object with the identifier `id`. You can pause the playback of a music object with the [PauseMusic()](https://www.hollywood-mal.com/docs/html/hollywood/PauseMusic_.html).",
    "inputsDocs": "* `id` — identifier of the music object to be resumed",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "ResumeMusic(${1:id})"
  },
  {
    "name": "SaveSample",
    "helpId": "SaveSample",
    "shortDescription": "save sample to disk",
    "version": "5.0",
    "synopsis": "SaveSample(id, f$[, fmt, t])",
    "functionDocs": "This command saves the sample specified in `id` to the file specified in `f$`. The optional argument `fmt` specifies the format in which the sample should be exported. Currently, only `#SMPFMT_WAVE` is supported here. This will save the sample in the RIFF WAVE format.\n\nStarting with Hollywood 10.0, `SaveSample()` accepts an optional table argument that allows you to pass additional arguments to the function. The following tags are currently supported by the optional table argument:\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked if they want to save the specified file. If you use this tag, you must set it to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to loaders and adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `id` — identifier of sample to save\n* `f$` — path to save location\n* `fmt` — optional: format in which to export the sample (defaults to `#SMPFMT_WAVE`)\n* `t` — optional: table containing further options (see above) (V10.0)",
    "example": "```\n@SAMPLE 1, \"ouch.8svx\"\n\nSaveSample(1, \"ouch.wav\")\n```\n\nThe code above loads a sample in the IFF 8SVX format and saves it as a RIFF WAVE sample.",
    "platforms": ["All"],
    "insertText": "SaveSample(${1:id}, ${2:f$})"
  },
  {
    "name": "SeekMusic",
    "helpId": "SeekMusic",
    "shortDescription": "seek to a certain position in a music object",
    "version": "2.0",
    "synopsis": "SeekMusic(id, pos)",
    "functionDocs": "You can use this function to seek to the specified position in the music specified by `id`. The music object does not have to be playing. If the music is playing and you call `SeekMusic()`, it will immediately skip to the specified position. The position is specified in milliseconds. Thus, if you want to skip to the position 3:24, you would have to pass the value 204000 because 3 * 60 * 1000 + 24 * 1000 = 204000.\n\nPlease note that this function does not work with Protracker modules.",
    "inputsDocs": "* `id` — identifier of the music object to use\n* `pos` — new position for the music",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "SeekMusic(${1:id}, ${2:pos})"
  },
  {
    "name": "SetChannelVolume",
    "helpId": "SetChannelVolume",
    "shortDescription": "set channel volume",
    "version": "6.1",
    "synopsis": "SetChannelVolume(n, volume)",
    "functionDocs": "This function modifies the volume of the channel specified by `n`. Channel indices range from 1 to the number of channels. `volume` can be a number ranging from 0 (mute) to 64 (full) or a string containing a percent specification, e.g. \"50%\".",
    "inputsDocs": "* `n` — channel index\n* `volume` — new volume for the channel",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "SetChannelVolume(${1:n}, ${2:volume})"
  },
  {
    "name": "SetMasterVolume",
    "helpId": "SetMasterVolume",
    "shortDescription": "set the master volume",
    "version": "1.5",
    "synopsis": "SetMasterVolume(vol)",
    "functionDocs": "Please note: This command is somewhat obsolete and subject to removal. You should better use [SetVolume()](https://www.hollywood-mal.com/docs/html/hollywood/SetVolume_.html) for samples and [SetMusicVolume()](https://www.hollywood-mal.com/docs/html/hollywood/SetMusicVolume_.html) for music files/Protracker modules.\n\nThis function sets the master volume to the specified value `vol`. Using this command you can realise sound fade outs or ins.\n\nStarting with Hollywood 2.0, `vol` can also be a string containing a percent specification, e.g. \"50%\".",
    "inputsDocs": "* `vol` — new master volume (range 0 to 64 or percent specification)",
    "example": "```\nFor k = 64 To 0 Step -5\n   SetMasterVolume(k)\nNext\n```\n\nThe code above fades out all playing sounds by modifying the master volume.",
    "platforms": ["All"],
    "insertText": "SetMasterVolume(${1:vol})"
  },
  {
    "name": "SetMusicVolume",
    "helpId": "SetMusicVolume",
    "shortDescription": "modify volume of a music object",
    "version": "2.0",
    "synopsis": "SetMusicVolume(id, volume)",
    "functionDocs": "This function modifies the volume of the music object specified by `id`. If the music object is currently playing, the volume will be modified on-the-fly which can be used for sound fades etc.\n\nStarting with Hollywood 2.0, `volume` can also be a string containing a percent specification, e.g. \"50%\".",
    "inputsDocs": "* `id` — identifier of the music object\n* `volume` — new volume for the music object (range: 0=mute until 64=full volume or percent specification)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "SetMusicVolume(${1:id}, ${2:volume})"
  },
  {
    "name": "SetPanning",
    "helpId": "SetPanning",
    "shortDescription": "set sample panning",
    "version": "1.9",
    "synopsis": "SetPanning(id, pan)",
    "functionDocs": "This function allows you to specify where the sample with the identifier `id` shall be played. The parameter `pan` ranges from 0 to 255 where 0 means that the sample will only be played through the left speaker and 255 means that the sample will only be played through the right speaker. If you want to play the sample through both speakers at the same level, use 128 which is also the default.\n\nYou can also specify the special constances `#LEFT`, `#CENTER`, and `#RIGHT` which correspond to 0, 128, and 255, respectively.\n\nIf the sample is currently playing, the panning will be modified on-the-fly which can be used for some nice effects.",
    "inputsDocs": "* `id` — identifier of the sample to use\n* `pan` — new pan value (ranges from 0 to 255)",
    "example": "```\nSetPanning(1, 255)\nPlaySample(1)\n```\n\nThe code above will play the sample only through the right speaker.",
    "platforms": ["All"],
    "insertText": "SetPanning(${1:id}, ${2:pan})"
  },
  {
    "name": "SetPitch",
    "helpId": "SetPitch",
    "shortDescription": "modify pitch of a sample",
    "version": "1.0",
    "synopsis": "SetPitch(id,pitch)",
    "functionDocs": "This function modifies the pitch of the sample specified by `id`. If the sample is currently playing, the pitch is modified on-the-fly which can be used for some nice sound effects. Pitch is specified in hertz.",
    "inputsDocs": "* `id` — identifier of a sample\n* `pitch` — new pitch for the sample in hertz",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "SetPitch(${1:id}, ${2:pitch})"
  },
  {
    "name": "SetVolume",
    "helpId": "SetVolume",
    "shortDescription": "modify volume of a sample",
    "version": "1.0",
    "synopsis": "SetVolume(id,volume)",
    "functionDocs": "This function modifies the volume of the sample specified by `id`. If the sample is currently playing, the volume will be modified on-the-fly which can be used for sound fades etc.\n\nStarting with Hollywood 2.0, `volume` can also be a string containing a percent specification, e.g. \"50%\".",
    "inputsDocs": "* `id` — identifier of a sample\n* `volume` — new volume for the sample (range: 0=mute until 64=full volume or percent specification)",
    "example": "```\nLoadSample(1, \"Sound/Samples/GroovyLoop.wav\")\nPlaySample(1)\nWait(100)\nFor k = 64 To 0 Step -1\n   SetVolume(1,vol)\nNext\n```\n\nThe above code loads the sample \"Sound/Samples/GroovyLoop.wav\", plays it, waits 2 seconds and then does a fade out.",
    "platforms": ["All"],
    "insertText": "SetVolume(${1:id}, ${2:volume})"
  },
  {
    "name": "StopChannel",
    "helpId": "StopChannel",
    "shortDescription": "stop channel playback",
    "version": "6.1",
    "synopsis": "StopChannel(n)",
    "functionDocs": "Stops playback on the channel specified by `n`. Channel indices range from 1 to the number of available channels.",
    "inputsDocs": "* `n` — index of channel to stop",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "StopChannel(${1:n})"
  },
  {
    "name": "StopModule",
    "helpId": "StopModule",
    "shortDescription": "stop the currently playing module / OBSOLETE",
    "version": "1.0",
    "synopsis": "StopModule()",
    "functionDocs": "Important note: This command is obsolete. Please use [StopMusic()](https://www.hollywood-mal.com/docs/html/hollywood/StopMusic_.html) instead.\n\nStops the module that is currently playing and frees all used audio channels.",
    "inputsDocs": "none",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "StopModule()"
  },
  {
    "name": "StopMusic",
    "helpId": "StopMusic",
    "shortDescription": "stop a currently playing music",
    "version": "2.0",
    "synopsis": "StopMusic(id)",
    "functionDocs": "This function stops the music object specified by `id`. This won't fail if the specified music isn't currently playing.",
    "inputsDocs": "* `id` — identifier of the music object to be stopped",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "StopMusic(${1:id})"
  },
  {
    "name": "StopSample",
    "helpId": "StopSample",
    "shortDescription": "stop playing a sample",
    "version": "1.0",
    "synopsis": "StopSample(id)",
    "functionDocs": "Stops playback of the sample with the specified id. This won't fail if the specified sample isn't currently playing.",
    "inputsDocs": "* `id` — identifier of sample to stop",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "StopSample(${1:id})"
  },
  {
    "name": "WaitMusicEnd",
    "helpId": "WaitMusicEnd",
    "shortDescription": "halt until music has finished playing",
    "version": "10.0",
    "synopsis": "WaitMusicEnd(id)",
    "functionDocs": "This function halts the script execution until the music specified by `id` has finished playing. After that, the execution of your script is continued. If you need to do something while your music is playing, use the [IsMusicPlaying()](https://www.hollywood-mal.com/docs/html/hollywood/IsMusicPlaying_.html) command in conjunction with a loop.",
    "inputsDocs": "* `id` — identifier of a music that is currently playing",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "WaitMusicEnd(${1:id})"
  },
  {
    "name": "WaitPatternPosition",
    "helpId": "WaitPatternPosition",
    "shortDescription": "halt program until module reaches pattern position",
    "version": "1.0",
    "synopsis": "WaitPatternPosition(pos)",
    "functionDocs": "This function halts the program flow until the currently playing module reaches the specified pattern position `pos`. You have to call [PlayModule()](https://www.hollywood-mal.com/docs/html/hollywood/PlayModule_.html) before using this command. This is useful for timing your applications with the music.",
    "inputsDocs": "* `pos` — pattern position to wait for",
    "example": "```\nPlayModule(1)\nWaitPatternPosition(63)\n```\n\nThe above code starts playing module number 1 and waits then for reaching the end of the first pattern.",
    "platforms": ["All"],
    "insertText": "WaitPatternPosition(${1:pos})"
  },
  {
    "name": "WaitSampleEnd",
    "helpId": "WaitSampleEnd",
    "shortDescription": "halt until sample has finished playing",
    "version": "1.0",
    "synopsis": "WaitSampleEnd(id)",
    "functionDocs": "This function halts the program flow until the sample specified by `id` has finished playing. After that, the execution of your script is continued. If you need to do something while your sample is playing, use the [IsSamplePlaying()](https://www.hollywood-mal.com/docs/html/hollywood/IsSamplePlaying_.html) command in conjunction with a loop.",
    "inputsDocs": "* `id` — identifier of a sample that is currently playing",
    "example": "See [LoadSample](https://www.hollywood-mal.com/docs/html/hollywood/LoadSample_.html)",
    "platforms": ["All"],
    "insertText": "WaitSampleEnd(${1:id})"
  },
  {
    "name": "WaitSongPosition",
    "helpId": "WaitSongPosition",
    "shortDescription": "halt program until module reaches song position",
    "version": "1.0",
    "synopsis": "WaitSongPosition(pos)",
    "functionDocs": "This function halts the program flow until the currently playing module reaches the specified song position `pos`. You have to call [PlayModule()](https://www.hollywood-mal.com/docs/html/hollywood/PlayModule_.html) before using this command. This is useful for timing your applications with the music.",
    "inputsDocs": "* `pos` — song position to wait for",
    "example": "```\nPlayModule(1)\nWaitSongPosition(2)\n```\n\nThe above code starts playing module number 1 and waits then for song position 2.",
    "platforms": ["All"],
    "insertText": "WaitSongPosition(${1:pos})"
  }
]
