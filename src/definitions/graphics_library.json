[
  {
    "name": "ARGB",
    "helpId": "ARGB",
    "shortDescription": "compose a color with alpha transparency",
    "version": "2.0",
    "synopsis": "color = ARGB(alpha, rgb)",
    "functionDocs": "This function combines an alpha transparency value with a color in [RGB](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html) notation. A 32-bit [ARGB color](https://www.hollywood-mal.com/docs/html/hollywood/ARGBInfo_.html) in the format $AARRGGBB will be returned. This is useful in connection with the commands of the drawing library because they can draw alpha-blended graphics, too.",
    "inputsDocs": "* `alpha` — desired alpha transparency (0-255)\n* `rgb` — standard [RGB color](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html)",
    "resultsDocs": "* `color` — [ARGB color](https://www.hollywood-mal.com/docs/html/hollywood/ARGBInfo_.html)",
    "example": "```\nBox(#CENTER, #CENTER, 320, 240, ARGB(128, #WHITE))\n```\n\nThe code above draws an alpha-blended white rectangle. The mixing ratio is 128 (50%).",
    "platforms": ["All"],
    "insertText": "ARGB(${1:alpha}, ${2:rgb})"
  },
  {
    "name": "BeginDoubleBuffer",
    "helpId": "BeginDoubleBuffer",
    "shortDescription": "start double buffering for current display",
    "version": "2.0",
    "synopsis": "BeginDoubleBuffer([hardware])",
    "functionDocs": "This command puts the current display in double buffering mode. The graphics that are drawn after this command was called will not be visible until you call [Flip()](https://www.hollywood-mal.com/docs/html/hollywood/Flip_.html). Double buffering is used to avoid that screen updates are visible to the user. As the name implies, you have two buffers in double buffering mode: A front buffer (visible to the user) and a back buffer (in memory). Your screen updates are always drawn to the back (memory) buffer and when you are finished with that, you call the [Flip()](https://www.hollywood-mal.com/docs/html/hollywood/Flip_.html) command to bring the back buffer to the front. After that, you can draw the next update. This technique ensures that no flickering will be visible because [Flip()](https://www.hollywood-mal.com/docs/html/hollywood/Flip_.html) will always refresh the whole display in one go.\n\nDouble buffers are extremely useful if many graphics have to be drawn in a screen update. If you only need to move a little player image around, you should better use sprites because that is faster. Remember that a double buffered display will always refresh the whole screen. Thus, if you have an application running in 640x480 at 25fps, it will be quite some work for Hollywood because it has to draw a screen of 640x480 25 times a second.\n\nDouble buffers are installed on a per display basis. Thus, when you call `BeginDoubleBuffer()`, it will change the currently selected display into a double-buffered one. It will not change all displays to double-buffered! If you want all your displays to be double-buffered, you need to call `BeginDoubleBuffer()` for each of your displays.\n\nSome restrictions apply:\n\n- You cannot use double buffering when layers are enabled.\n- You cannot use sprites together with a double buffered display.\n- The BGPic that is active when `BeginDoubleBuffer()` is called must not be transparent.\n\nStarting with Hollywood 5.0, there is a new optional argument `hardware` that allows you to enable hardware double buffering. On supported systems, this is much faster than software double buffering because it will completely operate in video memory which can use the GPU for drawing. There are some restrictions, though: If you use a hardware double buffer, you should draw to it using hardware brushes whenever this is possible. All other drawing commands will be much slower! Only by using hardware brushes can you get full hardware accelerated drawing. Using normal drawing functions with a hardware double buffer can even be slower than using them on a software double buffer. This is especially the case with graphics that use an alpha channel, e.g. anti-aliased text or vector shapes, because for alpha channel drawing, Hollywood has to read from the destination device which will be very slow for hardware double buffers because reading from video memory is very slow. Thus, you should try to use hardware brushes whereever possible when you work with a hardware double buffer. See [hardware brushes](https://www.hollywood-mal.com/docs/html/hollywood/HardwareBrushNote_.html).\n\nPlease note that currently hardware double buffering is only supported on AmigaOS and Android by default. However, plugins that install a display adapter are also able to support hardware double buffers for their display adapter. In that case you can also use hardware double buffers on systems other than AmigaOS and Android. For example, the GL Galore and RebelSDL plugins allow you to use hardware double buffers on Windows, macOS, and Linux. See [Obtaining plugins](https://www.hollywood-mal.com/docs/html/hollywood/PluginsObtaining_.html).\n\nPlease note that Hollywood might also fall back to single buffering on some systems. Therefore, it is not safe to assume that calling [Flip()](https://www.hollywood-mal.com/docs/html/hollywood/Flip_.html) will really switch buffers. It could also just draw the single buffer and then simply let you draw on it again.",
    "inputsDocs": "* `hardware` — optional: whether or not to create a hardware double buffer (defaults to `False` which means software double buffering) (V5.0)",
    "example": "```\nBeginDoubleBuffer()\nCreateBrush(1, 64, 64, #RED)\nFor k = -64 To 640\n   Cls\n   DisplayBrush(1, k, #CENTER)\n   Flip\nNext\nEndDoubleBuffer()\n```\n\nThe code above moves a red rectangle from the outer left to the outer right without any visible flickering. This is not a good example because we only move a little image around. It is a lot of overhead to refresh the whole 640x480 pixels just for this little image, so you should better use sprites in this case. Remember that double buffering is only recommended when there are a lot of graphics to draw.",
    "platforms": ["All"],
    "insertText": "BeginDoubleBuffer()"
  },
  {
    "name": "BeginRefresh",
    "helpId": "BeginRefresh",
    "shortDescription": "prepare display for optimized refresh",
    "version": "5.3",
    "synopsis": "BeginRefresh([force])",
    "functionDocs": "This command prepares the active display for optimized refreshing. On platforms supporting optimized refreshing, this means that all drawing commands that follow `BeginRefresh()` will be queued until you call [EndRefresh()](https://www.hollywood-mal.com/docs/html/hollywood/EndRefresh_.html). By caching all drawing commands that are called between `BeginRefresh()` and [EndRefresh()](https://www.hollywood-mal.com/docs/html/hollywood/EndRefresh_.html), the latter will be able to refresh your whole display in a single frame which on many platforms is the most efficient way of drawing besides using a double buffer. On platforms that don't support optimized refreshing, calling `BeginRefresh()` and [EndRefresh()](https://www.hollywood-mal.com/docs/html/hollywood/EndRefresh_.html) won't have any effect at all so it is safe to always use it in your scripts and Hollywood will enable it automatically when needed.\n\nOptimized refreshing is always supported on Windows (except when the software renderer is active), macOS (except on PowerPC), iOS and Android. On all other platforms optimized refreshing is only supported when the auto scaling engine is active. See [Scaling engines](https://www.hollywood-mal.com/docs/html/hollywood/AutoScalingInfo_.html).\n\nTo better understand the concept behind optimized refreshing, you need to understand that on some systems all drawing operations will always result in a complete redraw of the whole display, even if just a single pixel is changed. Now imagine the following situation: For every new frame your game has to draw 48 sprites to the screen. On systems that always refresh the whole display even if just a single pixel has changed this means that Hollywood has to redraw the whole screen 48 times and this 50 times a second if your game runs at 50fps. Thus, 2400 complete screen refreshes (48 * 50) would be necessary per second (!). This of course will significantly kill your game's performance. If you encapsulate the drawing of the 48 sprites inside a `BeginRefresh()` and [EndRefresh()](https://www.hollywood-mal.com/docs/html/hollywood/EndRefresh_.html) section instead, Hollywood will only have to refresh the screen once per frame (50 times per second), which leads to a much smoother appearance. Thus, using `BeginRefresh()` in this case is absolutely mandatory to ensure a good performance of your game.\n\nOptimized refresh can also greatly enhance the performance of your script when autoscaling is active. If you use normal drawing with autoscaling, Hollywood will have to scale its refresh buffer to the desired dimensions on every single command that draws something. If you use a `BeginRefresh()` section here instead, Hollywood will just have to scale its refresh buffer once [EndRefresh()](https://www.hollywood-mal.com/docs/html/hollywood/EndRefresh_.html) is called. This of course can also enhance the performance significantly.\n\nBy default, `BeginRefresh()` will only use optimized refresh if its use is either encouraged on the host platform or if autoscaling is enabled. You can change this behaviour by passing `True` in the optional force argument. If `force` is set to `True`, `BeginRefresh()` will always use optimized refresh but this is not recommended because optimized refresh can also be slower than normal refresh in some cases. That is why you should leave the decision whether to use optimized refresh or not to Hollywood.\n\nPlease note that you only need to use `BeginRefresh()` sections if your script does its drawing without a double buffer. If your script uses a double-buffer, drawing is already pipelined to one refresh per frame and thus using `BeginRefresh()` is not needed in this case.",
    "inputsDocs": "* `force` — optional: force the use of optimized refresh or leave the decision to Hollywood. See above for more information (defaults to `False` which means leave the decision to Hollywood)",
    "example": "```\nBeginRefresh()\nFor Local k = 1 To 48\n   DisplaySprite(k, sprites[k].x, sprites[k].y)\nNext\nEndRefresh()\n```\n\nThe code above updates the positions of 48 sprites using a `BeginRefresh()` section. This means that on systems that always refresh the whole display (e.g. Android) Hollywood just has to update the screen once to reposition all 48 sprites. Without `BeginRefresh()` Hollywood would have to update the screen 48 times which is of course much slower.",
    "platforms": ["All"],
    "insertText": "BeginRefresh()"
  },
  {
    "name": "Blue",
    "helpId": "Blue",
    "shortDescription": "return blue portion of a color",
    "version": "1.9",
    "synopsis": "b = Blue(color)",
    "functionDocs": "This function returns the 8-bit blue component of a color in the [RGB format](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html).",
    "inputsDocs": "* `color` — input color in [RGB format](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html)",
    "resultsDocs": "* `b` — blue component of the color",
    "example": "```\nb = Red($C0C024)\n```\n\nThe above code will return $24 which is the blue component of the color.",
    "platforms": ["All"],
    "insertText": "Blue(${1:color})"
  },
  {
    "name": "ClearScreen",
    "helpId": "ClearScreen",
    "shortDescription": "clear screen with a transition effect",
    "version": "1.0",
    "synopsis": "[handle] = ClearScreen(effect, color[, table])",
    "functionDocs": "This function clears the screen with one of Hollywood's transition effects. The color is a RGB value specifying the color of the transition effect.\n\nNote that this function will automatically create a new BGPic filled with the specified color and switch to it.\n\nStarting with Hollywood 5.0 this function uses a new syntax with just a single table as an optional argument. The old syntax is still supported for compatibility reasons. The optional table argument can be used to configure the transition effect. The following options are possible:\n\n- `Speed`: Specifies the desired speed for the transition. The higher the value you specify here, the faster the effect will be displayed. (defaults to `#NORMALSPEED`)\n\n- `Parameter`: Some transition effects accept an additional parameter. This can be specified here. (defaults to `#RANDOMPARAMETER`)\n\n- `Async`: You can use this field to create an asynchronous draw object for this transition. If you pass `True` here DisplayTransitionFX() will exit immediately, returning a handle to an asynchronous draw object which you can then draw using AsyncDrawFrame(). See [AsyncDrawFrame](https://www.hollywood-mal.com/docs/html/hollywood/AsyncDrawFrame_.html).\n\n- `X`: Specifies the new x-position for the display. If you want the display to keep its current x-position, specify the special constant `#KEEPPOSITION`. Defaults to `#CENTER`.\n\n- `Y`: Specifies the new y-position for the display. If you want the display to keep its current y-position, specify the special constant `#KEEPPOSITION`. Defaults to `#CENTER`.\n\nHave a look at the documentation of [DisplayTransitionFX()](https://www.hollywood-mal.com/docs/html/hollywood/DisplayTransitionFX_.html) to see the list of all transition effects that can be used.",
    "inputsDocs": "* `effect` — special effect constant (see [DisplayTransitionFX()](https://www.hollywood-mal.com/docs/html/hollywood/DisplayTransitionFX_.html))\n* `color` — color that shall be used for the effect\n* `table` — optional: table configuring the transition effect",
    "resultsDocs": "* `handle` — optional: handle to an asynchronous draw object; will only be returned if `Async` has been set to `True` (see above)",
    "example": "```\nClearScreen(#VBLINDS32, $000000, {Speed = 10})\n```\n\nThe above code clears the screen with color black and the effect `#VBLINDS32` and speed of 10.",
    "platforms": ["All"],
    "insertText": "ClearScreen(${1:effect}, ${2:color})"
  },
  {
    "name": "Collision",
    "helpId": "Collision",
    "shortDescription": "check if two objects collide",
    "version": "2.0",
    "synopsis": "bool = Collision(type, ...)  \nbool = Collision(#BOX, x1, y1, width1, height1, x2, y2, width2, height2)  \nbool = Collision(#BRUSH, id1, x1, y1, id2, x2, y2)  \nbool = Collision(#LAYER, id1, id2)  \nbool = Collision(#SPRITE, id1, id2)  \nbool = Collision(#BRUSH_VS_BOX, id, x, y, x2, y2, width2, height2) (V4.5)  \nbool = Collision(#LAYER_VS_BOX, id, x, y, width, height) (V4.5)  \nbool = Collision(#SPRITE_VS_BOX, id, x, y, width, height) (V4.5)  \nbool = Collision(#SPRITE_VS_BRUSH, id1, id2, x, y) (V7.1)",
    "functionDocs": "This function checks if two objects collide. There are several possibilities how you can use this function depending on the type you specify.\n\nThe following collision types are currently supported:\n\n- `#BOX`: You have to specify the position and size of two rectangles and this function will determine if they collide or not. This is a quick calculation but is probably not exact enough for some purposes.\n\n- `#BRUSH`: Checks if the two brushes specified by `id1` and `id2` would collide if they were shown at `x1` and `y1` and `x2` and `y2`, respectively. Normally, transparent areas (mask or alpha channel) of the brushes will be fully respected so that you get an exact result if pixels collide or not. If you use hardware brushes, however, only the bounding rectangles are checked for collision so for hardware brushes collision detection won't respect transparent areas and won't be pixel-perfect.\n\n- `#LAYER`: Checks if the two layers specified by `id1` and `id2` collide. If the layers have transparent areas, they will be respected. If you use this type, layers must be enabled of course.\n\n- `#SPRITE`: Checks if the two sprites specified by `id1` and `id2` collide. If the sprites have transparent areas, they will be respected.\n\n- `#BRUSH_VS_BOX`: Checks if the specified brush collides with the specified rectangular area. If the brush has transparent areas, they will be taken into account as long as the brush is not a hardware brush. (V4.5)\n\n- `#LAYER_VS_BOX`: Checks if the specified layer collides with the specified rectangular area. If the layer has transparent areas, they will be taken into account. (V4.5)\n\n- `#SPRITE_VS_BOX`: Checks if the specified sprite collides with the specified rectangular area. If the sprite has transparent areas, they will be taken into account. (V4.5)\n\n- `#SPRITE_VS_BRUSH`: Checks if the sprite specified by `id1` collides with the brush specified by `id2` in case the brush was displayed at the position specified by `x` and `y`. (V7.1)",
    "inputsDocs": "* `type` — either `#BOX`, `#BRUSH`, `#SPRITE`, `#LAYER`, `#BRUSH_VS_BOX`, `#LAYER_VS_BOX`, `#SPRITE_VS_BOX`, or `#SPRITE_VS_BRUSH` (see above)\n* `...` — optional arguments depend on the type specified (see above)",
    "resultsDocs": "* `bool` — `True` for collision, `False` otherwise",
    "example": "```\nBox(10, 10, 100, 100, #RED)\nBox(70, 70, 100, 100, #BLUE)\nb = Collision(#BOX, 10, 10, 100, 100, 70, 70, 100, 100)\n```\n\nThis returns `True` because the rectangles collide.",
    "platforms": ["All"],
    "insertText": "Collision(${1:type})"
  },
  {
    "name": "CreateClipRegion",
    "helpId": "CreateClipRegion",
    "shortDescription": "create a clip region",
    "version": "2.0",
    "synopsis": "[id] = CreateClipRegion(id, type, ...)  \n[id] = CreateClipRegion(id, #BOX, x, y, width, height)  \n[id] = CreateClipRegion(id, #SHAPE, id, x, y)",
    "functionDocs": "This function can be used to create a clip region which all Hollywood graphics functions will respect. `CreateClipRegion()` creates a new clip region and assigns the identifier `id` to it. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `CreateClipRegion()` will automatically choose an identifier and return it. Note that `CreateClipRegion()` does not activate the clip region; this has to be done using [SetClipRegion()](https://www.hollywood-mal.com/docs/html/hollywood/SetClipRegion_.html).\n\nClip regions are useful to limit the area of your display, where graphics can be displayed, e.g. if you have a game screen with two parts: The level area and the status bar (lifes, ammo etc.) it can be useful to install a clip region which matches the bounds of the level area so that sprites will never be drawn outside of this area. All Hollywood graphics functions will respect the clip region you install using this function. No graphics will ever be drawn outside the bounds of your clip region.\n\nThere are two different clip region types: Rectangular (`#BOX`) and custom shaped (`#SHAPE`) clip regions. Drawing to rectangular clip regions is generally faster. If you want to install a rectangular clip region, you have to specify its `x` and `y` position as well as its `width` and `height`. A custom shaped clip region can be installed by specifying a brush, whose mask is to be used as the clip region. Also, you need to specify `x` and `y` offsets where the clip region shall be positioned on the display, e.g. if you have a mask of size 320x240 but a display of size 640x480, you might want to center the clip region on the display. If you install a custom shaped clip region using a brush's mask, Hollywood will be able to draw to all visible pixels of the mask and all invisible pixels of the mask will be clipped.\n\nSee [SetClipRegion](https://www.hollywood-mal.com/docs/html/hollywood/SetClipRegion_.html).\n\nTo free a clip region created with `CreateClipRegion()`, use the [FreeClipRegion()](https://www.hollywood-mal.com/docs/html/hollywood/FreeClipRegion_.html) function.",
    "inputsDocs": "* `id` — identifier for the clip region or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `type` — type of clip region to install; `#BOX`, `#SHAPE` or `#NONE`\n* `...` — the following arguments depend on the type; see above",
    "resultsDocs": "* `id` — optional: identifier of the clip region; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "example": "See [SetClipRegion](https://www.hollywood-mal.com/docs/html/hollywood/SetClipRegion_.html)",
    "platforms": ["All"],
    "insertText": "CreateClipRegion(${1:id}, ${2:type})"
  },
  {
    "name": "DisablePrecalculation",
    "helpId": "DisablePrecalculation",
    "shortDescription": "disable precalculation (V1.5 only)",
    "version": "1.0",
    "synopsis": "DisablePrecalculation()",
    "functionDocs": "Attention: This command was removed in Hollywood 1.9. Get a faster CPU.\n\nThis function disables precalculation of certain effects.",
    "inputsDocs": "none",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "DisablePrecalculation()"
  },
  {
    "name": "DisableVWait",
    "helpId": "DisableVWait",
    "shortDescription": "disable vertical refresh timing",
    "version": "9.0",
    "synopsis": "DisableVWait()",
    "functionDocs": "This command disables internal vertical refresh timing. `DisableVWait()` is only useful for debugging purposes. You should not use it in your scripts.",
    "inputsDocs": "none",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "DisableVWait()"
  },
  {
    "name": "EnablePrecalculation",
    "helpId": "EnablePrecalculation",
    "shortDescription": "enable precalculation (V1.5 only)",
    "version": "1.0",
    "synopsis": "EnablePrecalculation()",
    "functionDocs": "Attention: This command was removed in Hollywood 1.9. Get a faster CPU.\n\nThis function enables precalculation for certain cpu-intensive effects from the library of [DisplayTransitionFX()](https://www.hollywood-mal.com/docs/html/hollywood/DisplayTransitionFX_.html). Effects which support precalculation, will be precalculated then. This is only useful on 68k systems. PPC systems should be able to display those cpu-intensive effects in real time.",
    "inputsDocs": "none",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "EnablePrecalculation()"
  },
  {
    "name": "EnableVWait",
    "helpId": "EnableVWait",
    "shortDescription": "enable vertical refresh timing",
    "version": "9.0",
    "synopsis": "EnableVWait()",
    "functionDocs": "This command enables internal vertical refresh timing. `EnableVWait()` is only useful for debugging purposes. You should not use it in your scripts.",
    "inputsDocs": "none",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "EnableVWait()"
  },
  {
    "name": "EndDoubleBuffer",
    "helpId": "EndDoubleBuffer",
    "shortDescription": "stop double buffering for current display",
    "version": "2.0",
    "synopsis": "EndDoubleBuffer()",
    "functionDocs": "This command ends the double buffering mode in the current display. See [BeginDoubleBuffer](https://www.hollywood-mal.com/docs/html/hollywood/BeginDoubleBuffer_.html).",
    "inputsDocs": "none",
    "example": "See [BeginDoubleBuffer](https://www.hollywood-mal.com/docs/html/hollywood/BeginDoubleBuffer_.html)",
    "platforms": ["All"],
    "insertText": "EndDoubleBuffer()"
  },
  {
    "name": "EndRefresh",
    "helpId": "EndRefresh",
    "shortDescription": "flush drawing queue",
    "version": "5.3",
    "synopsis": "EndRefresh()",
    "functionDocs": "This command draws all graphics that have been queued since the last call to [BeginRefresh()](https://www.hollywood-mal.com/docs/html/hollywood/BeginRefresh_.html). See [BeginRefresh](https://www.hollywood-mal.com/docs/html/hollywood/BeginRefresh_.html).",
    "inputsDocs": "none",
    "example": "See [BeginRefresh](https://www.hollywood-mal.com/docs/html/hollywood/BeginRefresh_.html)",
    "platforms": ["All"],
    "insertText": "EndRefresh()"
  },
  {
    "name": "Flip",
    "helpId": "Flip",
    "shortDescription": "flip front and back buffers",
    "version": "2.0",
    "synopsis": "Flip([sync])",
    "functionDocs": "This command brings the back buffer to the front and makes the front buffer the back buffer so that you can draw the next screen update.\n\nStarting with Hollywood 5.0, there is an optional argument called `sync`. If this is set to `False`, `Flip()` will not wait for the vertical refresh but will draw the back buffer immediately. This is useful if you would like to refresh the double buffer more often than the refresh rate of the monitor. If not specified, `sync` defaults to `True` which means that `Flip()` will synchronize its double buffer with the monitor refresh.\n\nPlease note that Hollywood might also fall back to single buffering on some systems. Therefore, it is not safe to assume that calling `Flip()` will really switch buffers. It could also just draw the single buffer and then simply let you draw on it again.\n\nSee [BeginDoubleBuffer](https://www.hollywood-mal.com/docs/html/hollywood/BeginDoubleBuffer_.html).",
    "inputsDocs": "* `sync` — optional: whether or not to synchronize double buffer with monitor refresh (defaults to `True`) (V5.0)",
    "example": "See [BeginDoubleBuffer](https://www.hollywood-mal.com/docs/html/hollywood/BeginDoubleBuffer_.html)",
    "platforms": ["All"],
    "insertText": "Flip()"
  },
  {
    "name": "FreeClipRegion",
    "helpId": "FreeClipRegion",
    "shortDescription": "free a clip region",
    "version": "2.0",
    "synopsis": "FreeClipRegion(id)",
    "functionDocs": "This function frees a clip region created by CreateClipRegion().\n\nIf there are sprites which are attached to this clip region, they will be let out and the clip region is freed immediately.\n\nThe behaviour for layers is different: If there are layers which reference this clip region, then Hollywood will keep the clip region until these layers are gone. As soon as there are no more layers which reference this clip region, the Hollywood garbage collector will free the clip region automatically if you have previously called `FreeClipRegion()` on it.\n\nPlease see also the documentation of [CreateClipRegion()](https://www.hollywood-mal.com/docs/html/hollywood/CreateClipRegion_.html) for more information on clip regions.",
    "inputsDocs": "* `id` — identifier of the clip region to be freed",
    "example": "See [SetClipRegion](https://www.hollywood-mal.com/docs/html/hollywood/SetClipRegion_.html)",
    "platforms": ["All"],
    "insertText": "FreeClipRegion(${1:id})"
  },
  {
    "name": "GetFPSLimit",
    "helpId": "GetFPSLimit",
    "shortDescription": "get current frames per second limit",
    "version": "1.5",
    "synopsis": "fps = GetFPSLimit()",
    "functionDocs": "This function returns the current fps limit set using [SetFPSLimit()](https://www.hollywood-mal.com/docs/html/hollywood/SetFPSLimit_.html). If SetFPSLimit() is not active, 0 will be returned. See [SetFPSLimit](https://www.hollywood-mal.com/docs/html/hollywood/SetFPSLimit_.html).",
    "inputsDocs": "none",
    "resultsDocs": "* `fps` — current fps limit or 0",
    "platforms": ["All"],
    "insertText": "GetFPSLimit()"
  },
  {
    "name": "GetRandomColor",
    "helpId": "GetRandomColor",
    "shortDescription": "choose a random color",
    "version": "4.7",
    "synopsis": "color = GetRandomColor()",
    "functionDocs": "This function simply chooses a random color and returns it. The color will be returned in [RGB notation](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html).",
    "inputsDocs": "none",
    "resultsDocs": "* `color` — a randomly chosen color",
    "platforms": ["All"],
    "insertText": "GetRandomColor()"
  },
  {
    "name": "GetRandomFX",
    "helpId": "GetRandomFX",
    "shortDescription": "choose a random transition effect",
    "version": "4.0",
    "synopsis": "fx = GetRandomFX(objfx)",
    "functionDocs": "This function simply chooses a random transition effect from Hollywood's palette of transition effects. You need to specify in argument 1 whether or not the transition effect shall be applicable for objects or only for background pictures. `GetRandomFX()` then scans the available effects and returns a random effect for you which you can then pass to the special effects functions like [DisplayBrushFX()](https://www.hollywood-mal.com/docs/html/hollywood/DisplayBrushFX_.html) and [DisplayTransitionFX()](https://www.hollywood-mal.com/docs/html/hollywood/DisplayTransitionFX_.html).\n\nNormally, you do not have to use this function because you can simply pass `#RANDOMEFFECT` with all special effects functions. `GetRandomFX()` is only useful if you want to filter effects, i.e. you want to choose a random effect but not `#WATER1`, for example. In that case, you can call `GetRandomFX()` until it returns an effect that is different from the ones you don't want.\n\nSee [DisplayTransitionFX](https://www.hollywood-mal.com/docs/html/hollywood/DisplayTransitionFX_.html).",
    "inputsDocs": "* `objfx` — `True` if you want to have an object effect or `False` for a background picture effect",
    "resultsDocs": "* `fx` — a randomly chosen transition effect",
    "example": "```\nRepeat\n   fx = GetRandomFX(FALSE)\nUntil fx <> #WATER1\nDisplayTransitionFX(2, fx)\n```\n\nThe code above chooses a random background picture effect but never the `#WATER1` effect. After having chosen the effect, background picture 2 is display with this effect.",
    "platforms": ["All"],
    "insertText": "GetRandomFX(${1:objfx})"
  },
  {
    "name": "GetRealColor",
    "helpId": "GetRealColor",
    "shortDescription": "return representation of a color on the current screen",
    "version": "1.5",
    "synopsis": "color = GetRealColor(col)",
    "functionDocs": "This function returns the color which represents the specified color on the current screen. On 24-bit and 32-bit screens, the returned color is always the same as the color you specified. On 15-bit and 16-bit screens, the returned color is slightly different from the original color in most cases because those screens do not have 16.7 million colors but only 65536 (16-bit screens) respectively 32768 (15-bit screens).\n\nThis is command is mostly used in connection with [ReadPixel()](https://www.hollywood-mal.com/docs/html/hollywood/ReadPixel_.html).",
    "inputsDocs": "* `col` — color to find the representation for",
    "resultsDocs": "* `color` — color which represents the specified input color",
    "example": "```\ncolor = GetRealColor($FFFFFF)\n```\n\nColor will get the following values on...  1) 24-bit and 32-bit screens: $FFFFFF 2) 16-bit screens: $F8FCF8 3) 15-bit screens: $F8F8F8",
    "platforms": ["All"],
    "insertText": "GetRealColor(${1:col})"
  },
  {
    "name": "GrabDesktop",
    "helpId": "GrabDesktop",
    "shortDescription": "create a brush of the desktop screen",
    "version": "4.5",
    "synopsis": "[id] = GrabDesktop(id[, table])",
    "functionDocs": "This function can be used to copy the contents of desktop screen into a brush. You have to pass an identifier for the new brush that shall be created by this function. If you pass a [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) identifier, `GrabDesktop()` will return a handle to the new brush containing the desktop screen to you.\n\nThe optional table argument is useful if you only want to grab a portion of the desktop screen. In that case, you can use the optional table argument to define the portion that shall be grabbed.\n\nThe optional table argument recognizes the following tags:\n\n- `X, Y`: Defines the top left corner of the rectangle on the desktop that shall be grabbed by this function. Defaults to 0/0.\n\n- `Width, Height`: Defines the size of the rectangle that shall be grabbed by this function. Defaults to the size of the desktop.\n\n- `PubScreen`: This tag is only supported in the Amiga versions of Hollywood. It allows you to specify the name of the screen which `GrabDesktop()` should copy to a brush. By default, `GrabDesktop()` will always grab the frontmost screen. (V5.3)",
    "inputsDocs": "* `id` — identifier of a brush that shall be created by this function or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `table` — optional: table specifying the portion of the desktop screen that shall be grabbed (see above)",
    "resultsDocs": "* `id` — optional: handle to the newly created brush; this will only be returned if you passed [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`",
    "example": "```\ndesktop_brush = GrabDesktop(Nil)\nBrushToGray(desktop_brush)\nDisplayBrush(desktop_brush, 0, 0)\n```\n\nThe code above grabs the whole desktop screen to a brush, converts the brush to gray, and then displays it. The result will be a desktop screen that suddenly lost its color information.",
    "platforms": ["All"],
    "insertText": "GrabDesktop(${1:id})"
  },
  {
    "name": "Green",
    "helpId": "Green",
    "shortDescription": "return green portion of a color",
    "version": "1.9",
    "synopsis": "g = Green(color)",
    "functionDocs": "This function returns the 8-bit green component of a color in the [RGB format](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html).",
    "inputsDocs": "* `color` — input color in [RGB format](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html)",
    "resultsDocs": "* `g` — green component of the color",
    "example": "```\ng = Green($24C0C0)\n```\n\nThe above code will return $C0 which is the green component of the color.",
    "platforms": ["All"],
    "insertText": "Green(${1:color})"
  },
  {
    "name": "Intersection",
    "helpId": "Intersection",
    "shortDescription": "compute intersection of two rectangles",
    "version": "6.1",
    "synopsis": "ix, iy, iw, ih = Intersection(x1, y1, w1, h1, x2, y2, w2, h2)",
    "functionDocs": "This function computes the intersection between the two rectangles whose positions and dimensions are passed to it. If the two rectangles don't intersect, the returned dimensions will be 0.",
    "inputsDocs": "* `x1` — x position of first rectangle\n* `y1` — y position of first rectangle\n* `w1` — width of first rectangle\n* `h1` — height of first rectangle\n* `x2` — x position of second rectangle\n* `y2` — y position of second rectangle\n* `w2` — width of second rectangle\n* `h2` — height of second rectangle",
    "resultsDocs": "* `ix` — x position of intersecting rectangle\n* `iy` — y position of intersecting rectangle\n* `iw` — width of intersecting rectangle\n* `ih` — height of intersecting rectangle",
    "example": "```\nSetFillStyle(#FILLCOLOR)\nBox(100, 100, 80, 100, #RED)\nBox(160, 120, 100, 40, #YELLOW)\n\nix, iy, iw, ih = Intersection(100, 100, 80, 100, 160, 120, 100, 40)\n\nBox(ix, iy, iw, ih, #GREEN)\n```\n\nThe code above computes the intersection of the red and yellow rectangles and visualizes it by drawing a green rectangle.",
    "platforms": ["All"],
    "insertText": "Intersection(${1:x1}, ${2:y1}, ${3:w1}, ${4:h1}, ${5:x2}, ${6:y2}, ${7:w2}, ${8:h2})"
  },
  {
    "name": "IsPicture",
    "helpId": "IsPicture",
    "shortDescription": "determine if a picture is in a supported format",
    "version": "1.0",
    "synopsis": "ret, table = IsPicture(file$[, table])",
    "functionDocs": "This function will check if the file specified by `file$` is in a supported picture format. If it is, this function will return `True`, otherwise `False`. If this function returns `True`, you can load the picture by calling [LoadBGPic()](https://www.hollywood-mal.com/docs/html/hollywood/LoadBGPic_.html) or [LoadBrush()](https://www.hollywood-mal.com/docs/html/hollywood/LoadBrush_.html).\n\nNew in Hollywood 4.5: This function returns a table now as the second return value. If the specified file is an image, the table will contain some information about the image file. The following fields of the return table will be initialized:\n\n- `Width`: Contains the width of the image in pixels.\n\n- `Height`: Contains the height of the image in pixels.\n\n- `Depth`: Contains the bit depth of the image. (V9.0)\n\n- `Alpha`: `True` if image has an alpha channel, `False` otherwise.\n\n- `Vector`: `True` if image is in a scalable vector format, `False` otherwise. (V5.0)\n\n- `Transparency`: `True` if image has a monochrome transparency channel, i.e. a transparent pen in a palette-based image. (V6.0)\n\n- `Format`: This contains the image format type Hollywood has detected for this file. It can be one of the following special constants:\n\n  - `#IMGFMT_BMP`: BMP image.\n\n  - `#IMGFMT_PNG`: PNG image.\n\n  - `#IMGFMT_JPEG`: JPEG image.\n\n  - `#IMGFMT_ILBM`: IFF ILBM image.\n\n  - `#IMGFMT_GIF`: GIF image.\n\n  - `#IMGFMT_TIFF`: TIFF image.\n\n  - `#IMGFMT_NATIVE`: The image is in a format that can be loaded by the host operating system Hollywood is currently running on. For example, if there is a datatype which can load the image on AmigaOS, you can get `#IMGFMT_NATIVE` as the result.\n\n  - `#IMGFMT_PLUGIN`: The image is in a format supported by a Hollywood plugin that is installed.\n\n  (V8.0)\n\nThis function is much faster than [LoadBrush()](https://www.hollywood-mal.com/docs/html/hollywood/LoadBrush_.html) or [LoadBGPic()](https://www.hollywood-mal.com/docs/html/hollywood/LoadBGPic_.html) because it will not load the picture. It will just check its format header and return whether or not Hollywood can handle it. However, please note that image plugins you have installed might not be as optimized as Hollywood's inbuilt image loader and so they can slow down `IsPicture()` significantly because by default `IsPicture()` will first ask all plugins if they can load the picture and then Hollywood's inbuilt image loader will be asked. Thus, you might want to disable plugins for `IsPicture()` by setting the `Loader` tag (see below) to `Inbuilt`. This means that `IsPicture()` will never ask any plugins if they can load the picture. Only Hollywood's very optimized inbuilt image loader will be asked in that case.\n\nStarting with Hollywood 6.0 this function accepts an optional table argument which allows you to configure further options:\n\n- `Loader`: This tag allows you to specify one or more format loaders that should be asked to load this picture. This must be set to a string containing the name(s) of one or more loader(s). You might want to set this to `Inbuilt` for the best performance, but then only formats supported by Hollywood's inbuilt image loader will be recognized (see above for details). Defaults to the loader set using [SetDefaultLoader()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultLoader_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked to open the specified file. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to loaders and adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\nSee [LoadBrush](https://www.hollywood-mal.com/docs/html/hollywood/LoadBrush_.html).",
    "inputsDocs": "* `file$` — file to check\n* `table` — optional: table configuring further options (V6.0)",
    "resultsDocs": "* `ret` — `True` if the picture is in a supported format, `False` otherwise\n* `table` — table initialized with the fields listed above; only valid if first return argument is `True` (V4.5)",
    "platforms": ["All"],
    "insertText": "IsPicture(${1:file$})"
  },
  {
    "name": "Matrix2D",
    "helpId": "Matrix2D",
    "shortDescription": "construct 2x2 transformation matrix",
    "version": "10.0",
    "synopsis": "m = Matrix2D(sx, sy, angle)",
    "functionDocs": "This function combines the scaling coefficients specified by `sx` and `sy` and the rotation factor specified by `angle` into a 2x2 transformation matrix and returns it. The 2x2 transformation matrix is returned as a table which has the following fields initialized:\n\n- `sx`: Amount of scaling on the x axis.\n\n- `rx`: Amount of rotation on the x axis.\n\n- `ry`: Amount of rotation on the y axis.\n\n- `sy`: Amount of scaling on the y axis.\n\nYou could then pass the matrix to functions like [TransformBox()](https://www.hollywood-mal.com/docs/html/hollywood/TransformBox_.html) or [TransformPoint()](https://www.hollywood-mal.com/docs/html/hollywood/TransformPoint_.html).",
    "inputsDocs": "* `sx` — scale x coefficient\n* `sy` — scale y coefficient\n* `angle` — rotation angle",
    "resultsDocs": "* `m` — 2x2 transformation matrix returned as a table",
    "platforms": ["All"],
    "insertText": "Matrix2D(${1:sx}, ${2:sy}, ${3:angle})"
  },
  {
    "name": "MixRGB",
    "helpId": "MixRGB",
    "shortDescription": "mix two colors",
    "version": "2.0",
    "synopsis": "color = MixRGB(col1, col2, ratio)",
    "functionDocs": "This function mixes the two specified colors at a specified ratio which must be in the range of 0 to 255. The second color will be mixed with the first color at the specified ratio, i.e. if `ratio` is 0, `col1` will returned and if `ratio` is 255, `col2` will be returned.\n\n`ratio` can also be a string containing a percent specification, e.g. \"50%\".",
    "inputsDocs": "* `col1` — color 1 in [RGB format](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html)\n* `col2` — color 2 in [RGB format](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html)\n* `ratio` — mixing ratio (0 to 255 or percent specification)",
    "resultsDocs": "* `color` — mixed color",
    "example": "```\nc = MixRGB(#RED, #BLUE, 128)\n```\n\nThis will mix a pink sort of color.",
    "platforms": ["All"],
    "insertText": "MixRGB(${1:col1}, ${2:col2}, ${3:ratio})"
  },
  {
    "name": "Red",
    "helpId": "Red",
    "shortDescription": "return red portion of a color",
    "version": "1.9",
    "synopsis": "r = Red(color)",
    "functionDocs": "This function returns the 8-bit red component of a color in the [RGB format](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html).",
    "inputsDocs": "* `color` — input color in [RGB format](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html)",
    "resultsDocs": "* `r` — red component of the color",
    "example": "```\nr = Red($24C0C0)\n```\n\nThe above code will return $24 which is the red component of the color.",
    "platforms": ["All"],
    "insertText": "Red(${1:color})"
  },
  {
    "name": "RGB",
    "helpId": "RGB",
    "shortDescription": "compose a color",
    "version": "1.9",
    "synopsis": "color = RGB(red, green, blue)",
    "functionDocs": "This function composes a [RGB color](https://www.hollywood-mal.com/docs/html/hollywood/RGBInfo_.html) by mixing the three basic colors red, green and blue. You must specify an intensity of 0 to 255 for each basic color.",
    "inputsDocs": "* `red` — red intensity (0-255)\n* `green` — green intensity (0-255)\n* `blue` — blue intensity (0-255)",
    "resultsDocs": "* `color` — RGB color",
    "example": "```\ncolor = RGB(255, 255, 255)  ; mix white\ncolor = RGB(255, 0, 0)      ; mix red\ncolor = RGB(255, 255, 0)    ; mix yellow (red + green)\ncolor = RGB(255, 0, 255)    ; mix magenta (green + blue)\n```",
    "platforms": ["All"],
    "insertText": "RGB(${1:red}, ${2:green}, ${3:blue})"
  },
  {
    "name": "SaveSnapshot",
    "helpId": "SaveSnapshot",
    "shortDescription": "take a snapshot",
    "version": "2.0",
    "synopsis": "SaveSnapshot(f$[, mode, fmt, table])",
    "functionDocs": "This function takes a snapshot and saves it as the file specified in `f$`. The `mode` argument specifies the area to be grabbed. This can be one of the following constants:\n\n- `#SNAPWINDOW`: Grabs the complete Hollywood display, i.e. with window decorations. This is the default.\n\n- `#SNAPDISPLAY`: Grabs the display's contents only, i.e. without window decorations.\n\n- `#SNAPDESKTOP`: Grabs the complete host screen.\n\nNote that if the display is a palette mode display and you want the image file to be palette-based as well, you need to use `#SNAPDISPLAY` as this is the only snap mode that doesn't contain any other graphics besides the display's contents.\n\nThe `fmt` argument specifies the desired output image format. This can either be one of the following constants or an image saver provided by a plugin:\n\n- `#IMGFMT_BMP`: Windows bitmap. Hollywood's BMP saver supports RGB and palette images. `#IMGFMT_BMP` is the default format used by `SaveSnapshot()`.\n\n- `#IMGFMT_PNG`: PNG format. Hollywood's PNG saver supports RGB and palette images. RGB images also can have an alpha channel, palette images can have a transparent pen. (V2.5)\n\n- `#IMGFMT_JPEG`: JPEG format. Note that the JPEG format does not support alpha channels or palette-based graphics. The `Quality` field (see below) allows you to specify the quality level for the JPEG image (valid values are 0 to 100 where 100 is the best quality). (V4.0)\n\n- `#IMGFMT_GIF`: GIF format. Because GIF images are always palette-based, RGB graphics have to be quantized before they can be exported as GIF. You can use the `Colors` and `Dither` tags (see below) to specify the number of palette entries to allocate for the image and whether or not dithering shall be applied. When using `#IMGFMT_GIF` with a palette display, no quantizing will be done. `#IMGFMT_GIF` also supports palette images with a transparent pen. (V4.5)\n\n- `#IMGFMT_ILBM`: IFF ILBM format. Hollywood's IFF ILBM saver supports RGB and palette images. Palette images can also have a transparent pen, alpha channels are unsupported for this output format. (V4.5)\n\nThe optional table argument allows you to configure further parameters:\n\n- `Dither`: Set to `True` to enable dithering. This tag is only handled when the destination format is palette-based and the source data is RGB. Defaults to `False` which means no dithering.\n\n- `Depth`: Specifies the desired image depth. This is only handled when the format is palette-based and the source data is RGB. Valid values are between 1 (= 2 colors) and 8 (= 256 colors). Defaults to 8. (V9.0)\n\n- `Colors`: This is an alternative to the `Depth` tag. Instead of a bit depth, you can pass how many colors the image shall use here. Again, this is only handled for palette-based formats when the source data is RGB. Valid values are between 1 and 256. Defaults to 256.\n\n- `Quality`: Here you can specify a value between 0 and 100 indicating the compression quality for lossy compression formats. A value of 100 means best quality, 0 means worst quality. This is only available for image formats that support lossy compression. Defaults to 90 which means pretty good quality.\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked if they want to save the specified file. If you use this tag, you must set it to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to loaders and adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\nHere is an overview that shows which formats support which tags:\n\n![imgformats](https://www.hollywood-mal.com/docs/html/hollywood/img/imgformats.png)",
    "inputsDocs": "* `f$` — destination file\n* `mode` — optional: specifies which area shall be grabbed (defaults to `#SNAPWINDOW`)\n* `fmt` — optional: output format; either `#IMGFMT_BMP`, `#IMGFMT_PNG`, (V2.5) `#IMGFMT_JPEG`, `#IMGFMT_GIF` or `#IMGFMT_ILBM` (V4.0) (defaults to `#IMGFMT_BMP`)\n* `table` — optional: table argument for configuring further options (V4.5)",
    "example": "```\nSaveSnapshot(\"Snap.bmp\")\n```\n\nSaves a snapshot of the Hollywood window to \"Snap.bmp\".",
    "platforms": ["All"],
    "insertText": "SaveSnapshot(${1:f$})"
  },
  {
    "name": "SetClipRegion",
    "helpId": "SetClipRegion",
    "shortDescription": "activate a clip region",
    "version": "2.0",
    "synopsis": "SetClipRegion(id)",
    "functionDocs": "This function installs a clip region that has been previously created using the [CreateClipRegion()](https://www.hollywood-mal.com/docs/html/hollywood/CreateClipRegion_.html) command. The clip region will be active until you call `SetClipRegion()` with the special value `#NONE` - this will remove the clip region then. Hollywood will automatically kill the clip region if you display a new background picture.\n\nIf a clip region is installed, this will also affect Hollywood's special coordinate constants, e.g. `#RIGHT` means the right-side of the clip region then. Margin settings will also be adapted.\n\nYou can also install a clip region while [SelectBrush()](https://www.hollywood-mal.com/docs/html/hollywood/SelectBrush_.html) is active. This clip region will then be deactivated when [EndSelect()](https://www.hollywood-mal.com/docs/html/hollywood/EndSelect_.html) is called.\n\nIf you have a clip region installed on your main display and call one of the off-screen rendering functions (e.g. [SelectBrush()](https://www.hollywood-mal.com/docs/html/hollywood/SelectBrush_.html)), the clip region will be temporarily disabled but restored when you call [EndSelect()](https://www.hollywood-mal.com/docs/html/hollywood/EndSelect_.html).\n\nIf layers are active, every layer can have its private clip region. In case the layer is transformed (scaled or rotated), its clip region will also be transformed. The default clip region of a layer is the clip region that was active when the layer was created. You can change the clip region of a layer by using the style element `ClipRegion` of the [SetLayerStyle()](https://www.hollywood-mal.com/docs/html/hollywood/SetLayerStyle_.html) command.\n\nExceptions. You cannot use `SetClipRegion()` if...\n\n- current output device is an alpha channel, i.e. [SelectAlphaChannel()](https://www.hollywood-mal.com/docs/html/hollywood/SelectAlphaChannel_.html) is active\n- current output device is a mask, i.e. [SelectMask()](https://www.hollywood-mal.com/docs/html/hollywood/SelectMask_.html) is active\n\nSee [CreateClipRegion](https://www.hollywood-mal.com/docs/html/hollywood/CreateClipRegion_.html).",
    "inputsDocs": "* `id` — identifier of the clip region to install; use [CreateClipRegion()](https://www.hollywood-mal.com/docs/html/hollywood/CreateClipRegion_.html) to create clip regions",
    "example": "```\nCreateClipRegion(1, #BOX, #CENTER, #CENTER, 320, 240)\nSetClipRegion(1)\nCircle(0, 0, 100, #RED)\nCircle(439, 0, 100, #RED)\nCircle(439, 279, 100, #RED)\nCircle(0, 279, 100, #RED)\n```\n\nInstalls a clip region of size 320x240 in the center of a 640x480 display and draws four circles in all corners. However, only parts of the circles will be visible because of the clip region.",
    "platforms": ["All"],
    "insertText": "SetClipRegion(${1:id})"
  },
  {
    "name": "SetDrawTagsDefault",
    "helpId": "SetDrawTagsDefault",
    "shortDescription": "set default values for standard draw tags",
    "version": "5.0",
    "synopsis": "SetDrawTagsDefault(table)",
    "functionDocs": "This command can be used to modify the default values of the standard draw tags. The [standard draw tags](https://www.hollywood-mal.com/docs/html/hollywood/StandardDrawTags_.html) are generic options that are supported by most of Hollywood's drawing commands. The standard draw tags are always passed inside an optional table that constitutes the last argument to a function. If a certain draw tag is not specified, Hollywood will fall back to an internal default setting. This default setting can be modified using `SetDrawTagsDefault()`.\n\nFor example, let's assume that you always want to use an anchor point of 0.5/0.5 instead of 0.0/0.0 which is Hollywood's default anchor point. So instead of explicitly passing your desired anchor point to all draw commands that you call, you can simply define this anchor point as the new default anchor point that all drawing commands should use when no other point is given. See below for an example. You could also use `SetDrawTagsDefault()` to change the default insert position for layers from frontmost to backmost position etc.\n\nThe table you need to pass to this function can contain all tags that are listed in the [documentation](https://www.hollywood-mal.com/docs/html/hollywood/StandardDrawTags_.html) of the standard draw tags. For each tag that you specify, you have to provide a default value that Hollywood should use if no other value is given.\n\nSee [Standard drawing tags](https://www.hollywood-mal.com/docs/html/hollywood/StandardDrawTags_.html).",
    "inputsDocs": "* `table` — a table containing one or more of the [standard draw tags](https://www.hollywood-mal.com/docs/html/hollywood/StandardDrawTags_.html) and a default value for each tag",
    "example": "```\nSetDrawTagsDefault({AnchorX = 0.5, AnchorY = 0.5})\nDisplayBrush(1, 0, 0)\nBox(100, 100, 200, 150, #RED)\n```\n\nThe code above sets 0.5/0.5 as the default anchor point. The calls to [DisplayBrush()](https://www.hollywood-mal.com/docs/html/hollywood/DisplayBrush_.html) and [Box()](https://www.hollywood-mal.com/docs/html/hollywood/Box_.html) will then use this anchor point because no other anchor point is given. In that case, the drawing commands fall back to the default anchor point which has been modified by the call to `SetDrawTagsDefault()`.",
    "platforms": ["All"],
    "insertText": "SetDrawTagsDefault(${1:table})"
  },
  {
    "name": "SetFPSLimit",
    "helpId": "SetFPSLimit",
    "shortDescription": "limit frames per second",
    "version": "1.5",
    "synopsis": "SetFPSLimit(fps)",
    "functionDocs": "This function restricts the number of frames per second of certain Hollywood commands which call [VWait()](https://www.hollywood-mal.com/docs/html/hollywood/VWait_.html). These commands are: [PlayAnim()](https://www.hollywood-mal.com/docs/html/hollywood/PlayAnim_.html), [MoveBrush()](https://www.hollywood-mal.com/docs/html/hollywood/MoveBrush_.html) etc., [DisplayTransitionFX()](https://www.hollywood-mal.com/docs/html/hollywood/DisplayTransitionFX_.html) etc., and [Flip()](https://www.hollywood-mal.com/docs/html/hollywood/Flip_.html). Under normal circumstances it is not necessary to use this command because Hollywood automatically restricts the drawing speed internally. By default, the commands listed above will never draw more frames per second than the monitor refreshes. You can disable this behaviour with this command but this is not suggested (unless you really know what you are doing).\n\nThe best thing is to use the default video synchronizer of Hollywood will should give you the smoothest graphics. Use this command with care or better not at all.\n\nIf you pass 0 in `fps`, the default video synchronizer will be restored.",
    "inputsDocs": "* `fps` — maximum allowed number of frames per second or 0 to bring back Hollywood's default video synchronizer",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "SetFPSLimit(${1:fps})"
  },
  {
    "name": "TransformBox",
    "helpId": "TransformBox",
    "shortDescription": "apply affine transformation to rectangle",
    "version": "10.0",
    "synopsis": "tx, ty, tw, th = TransformBox(x, y, w, h, m[, origin, anchorx, anchory])",
    "functionDocs": "This function applies the 2x2 transformation matrix specified by `m` to the rectangle specified by `x`, `y`, `w` and `h` and returns the size and coordinates of the transformed rectangle. The `origin` parameter is a boolean value which specifies whether or not the rectangle should be moved to the origin before transforming it. The `anchorx` and `anchory` values specify the anchor point to use for the transformation. This should be a floating point value between 0.0 and 1.0 where 0.0 means the left/upper edge and 1.0 indicates the right/bottom edge. `anchorx` and `anchory` both default to 0 which means the upper-left corner of the rectangle is the default anchor point.\n\nThe transformation matrix `m` must be passed as a table that has the following fields initialized:\n\n- `sx`: Amount of scaling on the x axis.\n\n- `rx`: Amount of rotation on the x axis.\n\n- `ry`: Amount of rotation on the y axis.\n\n- `sy`: Amount of scaling on the y axis.\n\nYou can use the [Matrix2D()](https://www.hollywood-mal.com/docs/html/hollywood/Matrix2D_.html) function to construct such a matrix. See [Matrix2D](https://www.hollywood-mal.com/docs/html/hollywood/Matrix2D_.html).",
    "inputsDocs": "* `x` — left edge of rectangle\n* `y` — upper edge of rectangle\n* `w` — rectangle width\n* `h` — rectangle height\n* `m` — table containing a 2x2 transformation matrix\n* `origin` — optional: whether or not to move the rectangle to the origin before transforming it (defaults to `True`)\n* `anchorx` — optional: horizontal anchor point (defaults to 0 which means left edge)\n* `anchory` — optional: vertical anchor point (defaults to 0 which means top edge)",
    "resultsDocs": "* `tx` — transformed left edge\n* `ty` — transformed upper edge\n* `tw` — transformed width\n* `th` — transformed height",
    "platforms": ["All"],
    "insertText": "TransformBox(${1:x}, ${2:y}, ${3:w}, ${4:h}, ${5:m})"
  },
  {
    "name": "TransformPoint",
    "helpId": "TransformPoint",
    "shortDescription": "apply affine transformation to point",
    "version": "10.0",
    "synopsis": "tx, ty = TransformPoint(px, py, m)",
    "functionDocs": "This function applies the 2x2 transformation matrix specified by `m` to the point specified by `px` and `py` and returns the coordinates of the transformed point. The transformation matrix `m` must be passed as a table that has the following fields initialized:\n\n- `sx`: Amount of scaling on the x axis.\n\n- `rx`: Amount of rotation on the x axis.\n\n- `ry`: Amount of rotation on the y axis.\n\n- `sy`: Amount of scaling on the y axis.\n\nYou can use the [Matrix2D()](https://www.hollywood-mal.com/docs/html/hollywood/Matrix2D_.html) function to construct such a matrix. See [Matrix2D](https://www.hollywood-mal.com/docs/html/hollywood/Matrix2D_.html).",
    "inputsDocs": "* `px` — horizontal point coordinate\n* `py` — vertical point coordinate\n* `m` — table containing a 2x2 transformation matrix",
    "resultsDocs": "* `tx` — transformed horizontal position\n* `ty` — transformed vertical position",
    "platforms": ["All"],
    "insertText": "TransformPoint(${1:px}, ${2:py}, ${3:m})"
  },
  {
    "name": "VWait",
    "helpId": "VWait",
    "shortDescription": "wait for vertical blank",
    "version": "1.0",
    "synopsis": "VWait()",
    "functionDocs": "This command waits for the next vertical blank to begin.",
    "inputsDocs": "none",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "VWait()"
  }
]
