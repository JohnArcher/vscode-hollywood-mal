[
  {
    "name": "CanonizePath",
    "helpId": "CanonizePath",
    "shortDescription": "convert path into canonical format",
    "version": "9.0",
    "synopsis": "p$ = CanonizePath(path$)",
    "functionDocs": "This function can be used to turn the path specified in `path$` into a canonical one. Canonizing a path involves the following operations:\n\n- shortcuts like \"..\" or \".\" will be resolved to fully qualified paths\n- relative paths will be converted to fully qualified paths\n- on platforms with case-insensitive file systems, the spelling of all path components will be adapted to the spelling as it is stored in the file system\n- slashes and backslashes will be adapted to the host operating system's convention\n- any assigns in the path will be resolved on AmigaOS and compatibles\n\nNote that the path passed to `CanonizePath()` needn't exist. If it doesn't exist, `CanonizePath()` will try to resolve as many components in the path as possible. Note, however, that `CanonizePath()` doesn't perform path validation. If you pass a path that is invalid because of syntactical errors, the result is undefined.",
    "inputsDocs": "* `path$` — path to canonize",
    "resultsDocs": "* `p$` — fully qualified path in the host system's canonical format",
    "example": "```\nPrint(CanonizePath(\"../image.jpg\"))\n```\n\nThe code above will print the fully qualified path of the file `image.jpg`.",
    "platforms": ["All"],
    "insertText": "CanonizePath(${1:path$})"
  },
  {
    "name": "ChangeDirectory",
    "helpId": "ChangeDirectory",
    "shortDescription": "change the current directory",
    "version": "1.0",
    "synopsis": "ChangeDirectory(dir$[, t])",
    "functionDocs": "This function changes the directory to the one specified in `dir$`.\n\nStarting with Hollywood 10.0, this function accepts an optional table argument which supports the following tags:\n\n- `Adapter`: This tag allows you to specify one or more filesystem adapters that should be asked to handle the operation. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to filesystem adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `dir$` — directory to make the current directory\n* `t` — optional: table argument containing further options (see above) (V10.0)",
    "example": "```\nChangeDirectory(\"Data\")\nOpenFile(1, \"Highscores.txt\")\nCloseFile(1)\n```\n\nThe above code changes the current directory to \"Data\" and opens the file \"Highscores.txt\" inside the \"Data\" directory.",
    "platforms": ["All"],
    "insertText": "ChangeDirectory(${1:dir$})"
  },
  {
    "name": "CloseDirectory",
    "helpId": "CloseDirectory",
    "shortDescription": "close an open directory",
    "version": "4.0",
    "synopsis": "CloseDirectory(id)",
    "functionDocs": "This function closes a directory previously opened using [OpenDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/OpenDirectory_.html), [@DIRECTORY](https://www.hollywood-mal.com/docs/html/hollywood/atDIRECTORY_.html), or [MonitorDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/MonitorDirectory_.html). You should always close directories as soon as you are finished with them. This ensures that the file system does not unnecessarily keep directories locked.",
    "inputsDocs": "* `id` — identifier of the directory to close",
    "example": "See [OpenDirectory](https://www.hollywood-mal.com/docs/html/hollywood/OpenDirectory_.html)",
    "platforms": ["All"],
    "insertText": "CloseDirectory(${1:id})"
  },
  {
    "name": "CloseFile",
    "helpId": "CloseFile",
    "shortDescription": "close an open file",
    "version": "1.0",
    "synopsis": "CloseFile(id)",
    "functionDocs": "Closes the file with the identifier `id` which was opened with [OpenFile()](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html).",
    "inputsDocs": "* `id` — number that the file was opened with",
    "example": "See [OpenFile](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html)",
    "platforms": ["All"],
    "insertText": "CloseFile(${1:id})"
  },
  {
    "name": "CompressFile",
    "helpId": "CompressFile",
    "shortDescription": "compress a file",
    "version": "4.0",
    "synopsis": "size = CompressFile(src$, dst$)",
    "functionDocs": "This function compresses file `src$` and saves the packed data to `dst$`. The return value specifies the size of the compressed file. Hollywood uses zlib for data compression.\n\nTo decompress files packed by `CompressFile()` use the Hollywood function [DecompressFile()](https://www.hollywood-mal.com/docs/html/hollywood/DecompressFile_.html).",
    "inputsDocs": "* `src$` — file to compress\n* `dst$` — output file",
    "resultsDocs": "* `size` — size of the compressed file",
    "example": "```\nCompressFile(\"image.bmp\", \"image.pak\")\n```\n\nThe code above compresses file image.bmp to image.pak.",
    "platforms": ["All"],
    "insertText": "CompressFile(${1:src$}, ${2:dst$})"
  },
  {
    "name": "CopyFile",
    "helpId": "CopyFile",
    "shortDescription": "copy file or directory",
    "version": "2.0",
    "synopsis": "CopyFile(src$, dst$[, t])",
    "functionDocs": "This function copies the file or directory specified in `src$` to the directory specified in `dst$`. Note that by default, existing files will be overwritten without asking. You can customize this behaviour by specifying a callback function (see below). Also note that you have to specify a directory, not a file, in `dst$`.\n\nThis function is powerful. It will fully recurse into all subdirectories and copy the file attributes, date stamps and comments as well. If the destination directory does not exist, it will be created for you (even if it contains subdirectories that do not exist yet). All path specifications can be local to the current directory or qualified. You can also copy files to the current directory by specifying \"\" as `dst$`.\n\n`CopyFile()` supports many optional arguments. Before Hollywood 9.0, those had to be passed as optional parameters (see above). Since Hollywood 9.0, however, it is recommended to use the new syntax, which has a single optional table argument that can be used to pass one or more optional arguments to `CopyFile()`.\n\nThe following table fields are recognized by this function:\n\n- `NewName`: If you would like to change the name of the file while copying it, set this field to the desired new name for the file. Obviously, setting this field only makes sense when you specify a file in `src$`.\n\n- `Pattern`: You can pass a filter pattern in this table field. In that case, `CopyFile()` will only copy the files that match the specified pattern. For example, passing `*.jpg` in `Pattern` will only copy files that use the `.jpg` file extension. Of course, using a filter pattern makes only sense if you pass a directory in `src$`. Note that for historical reasons, the pattern specified in `Pattern` will also be matched against all subdirectories that are to be copied. If you don't want that, set the `MatchDir` table tag to `False` (see below). The pattern specified in `Pattern` must adhere to the pattern rules as described in the documentation of the [MatchPattern()](https://www.hollywood-mal.com/docs/html/hollywood/MatchPattern_.html) function. See [MatchPattern](https://www.hollywood-mal.com/docs/html/hollywood/MatchPattern_.html). (V5.0)\n\n- `MatchDir`: This table field specifies whether or not the filter pattern specified in `Pattern` should also be matched against subdirectories. If this is set to `True`, `CopyFile()` will only recurse into subdirectories that match the specified filter pattern. If it is set to `False`, `CopyFile()` will recurse into all subdirectories. For compatibility reasons, `MatchDir` defaults to `True`, but most of the time you will want to pass `False` here because it usually does not make sense to match a file pattern against a directory name. For example, it does not make sense to match the `*.jpg` example from above against directories as well. (V5.0)\n\n- `BufferSize`: This table field can be used to set the buffer size that should be used for copying files. The value passed here must be specified in bytes. The default is 16384, i.e. 16 kilobytes. (V9.0)\n\n- `FailOnError`: By default, `CopyFile()` will fail when an error occurs. You can change this behaviour by setting `FailOnError` to `False`. In that case, `CopyFile()` won't fail on an error but instead your callback function, if there is one, will be notified using the `#COPYFILE_FAILED` message and your callback must tell `CopyFile()` how to proceed (retry, continue, abort). See below to learn how to set up a callback function for `CopyFile()`. `FailOnError` defaults to `True`. (V9.0)\n\n- `Force`: If this tag is set to `True`, write- or delete-protected files will automatically be overwritten without asking the callback function first. Note that if there is no callback function and `Force` is set to `False` (the default), `CopyFile()` will fail if it can't overwrite a file because that file is write- or delete-protected. Defaults to `False`. (V9.0)\n\n- `Async`: If this is set to `True`, `CopyFile()` will operate in asynchronous mode. This means that it will return immediately, passing an asynchronous operation handle to you. You can then use this asynchronous operation handle to finish the operation by repeatedly calling [ContinueAsyncOperation()](https://www.hollywood-mal.com/docs/html/hollywood/ContinueAsyncOperation_.html) until it returns `True`. This is very useful in case your script needs to do something else while the operation is in progress, e.g. displaying a status animation or something similar. By putting `CopyFile()` into asynchronous mode, it is easily possible for your script to do something else while the operation is being processed. See [ContinueAsyncOperation](https://www.hollywood-mal.com/docs/html/hollywood/ContinueAsyncOperation_.html). Defaults to `False`. (V9.0)\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked if they want to open the source file or directory. If you use this tag, you must set it to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to file or directory adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\n- `DstAdapter`: This tag allows you to specify one or more filesystem adapters that should be asked to handle all operations on the side of the copy target. The filesystem adapter specified here will be responsible for creating directories and setting file and directory attributes, for example. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to `default`. See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `DstUserTags`: This tag can be used to specify additional data that should be passed to filesystem adapters specified in `DstAdapter`. See above for details. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\n- `Callback`: This table field can be used to pass a callback function which will be called by `CopyFile()` on various occasions, e.g. to allow you to update a progress bar for example. The callback function also gets called if a destination file already exists or is write/delete protected. The callback function receives one argument: A table that contains more information.\n\n  The following callback types are available:\n\n  - `#COPYFILE_OVERWRITE`: `CopyFile()` will run this callback to ask if a file can be overwritten. Your callback function has to return `True` if the file shall be overwritten or `False` if it shall be skipped. To abort the copy operation completely, return -1. The following fields will be set in the table parameter that is passed to your callback function:\n\n    - `Action`: `#COPYFILE_OVERWRITE`\n\n    - `Source`: Contains the fully qualified path of the file to copy.\n\n    - `Destination`: Contains the fully qualified path of the file that does already exist.\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n  - `#COPYFILE_UNPROTECT`: The callback function of type `#COPYFILE_UNPROTECT` will be called if the file that should be overwritten is write- or delete-protected. This callback function needs to return `True` if it is okay to unprotect the file or `False` if it shall be skipped. If you return -1, the copy operation will be completely aborted.\n\n    Starting with Hollywood 9.0, your callback function can also return -2 to indicate that copying should still be attempted even though the file is write- or delete-protected. This, however, will typically lead to an error because write- or delete-protected files can't be overwritten without unprotecting them first. However, if you return -2 you can catch the ensuing error in your `#COPYFILE_FAILED` callback if you have set `FailOnError` to `False` (see above).\n\n    The following fields will be set in the table parameter that is passed to your callback function:\n\n    - `Action`: `#COPYFILE_UNPROTECT`\n\n    - `Destination`: Contains the write or delete protected destination file to be unprotected.\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n  - `#COPYFILE_STATUS`: This callback function is run from time to time so that you can update a status bar or something similar. The callback function of type `#COPYFILE_STATUS` should normally return `False`. If it returns `True`, the copy operation will be aborted. The following fields will be set in the table parameter that is passed to your callback function:\n\n    - `Action`: `#COPYFILE_STATUS`\n\n    - `Source`: Contains the fully qualified path of the file that is currently being copied (source).\n\n    - `Destination`: Contains the fully qualified path of the file that is currently being written (destination).\n\n    - `Copied`: Contains the number of bytes that were already copied.\n\n    - `Filesize`: Contains the filesize of the source file.\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n  - `#COPYFILE_FAILED`: This callback can only be called if the `FailOnError` tag has been set to `False` (see above). In that case, the callback function of type `#COPYFILE_FAILED` will be called whenever a copy operation has failed. It has to return `True` to abort the copy operation, `False` to continue even though an error has occurred or -1 to retry the copy operation that has just failed. The following fields will be set in the table parameter that is passed to your callback function:\n\n    - `Action`: `#COPYFILE_FAILED`\n\n    - `Source`: Contains the fully qualified path of the file that is currently being copied (source).\n\n    - `Destination`: Contains the fully qualified path of the file that is currently being written (destination).\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n    (V9.0)\n\n- `UserData`: This field can be used to pass an arbitrary value to your callback function. The value you specify here will be passed to your callback function whenever it is called. This is useful if you want to avoid working with global variables. Using the `UserData` tag you can easily pass data to your callback function. You can specify a value of any type in `UserData`. Numbers, strings, tables, and even functions can be passed as user data. Your callback will receive this data in the `UserData` field in the table that is passed to it. (V5.1)",
    "inputsDocs": "* `src$` — source file or directory to copy\n* `dst$` — destination directory\n* `t` — optional: table containing additional options (see above) (V9.0)",
    "example": "```\nCopyFile(\"image.png\", \"TestDir\")\n```\n\nCopy the file \"image.png\" from the current directory to \"TestDir\".\n\n---\n\n```\nCopyFile(\"Images\", \"Images_Bak\")\n```\n\nCreate a backup of the \"Images\" directory in the \"Images_Bak\" directory (the new directory will be created by this function automatically). All files including subdirectories will be copied to the new location.\n\n---\n\n```\nCopyFile(\"Hollywood_Sources/WarpOS\", \"HW_BAK\", {Pattern = \"*.c;*.h\",\n  MatchDir = False})\n```\n\nCopies all source code and header files from Hollywood_Sources/WarpOS to HW_BAK.\n\n---\n\n```\nFunction p_CopyCallback(msg)\n  Switch msg.action\n  Case #COPYFILE_STATUS:\n    DebugPrint(\"Now copying\", FilePart(msg.source), \"to\",\n               PathPart(msg.destination))\n  Case #COPYFILE_OVERWRITE:\n    Return(SystemRequest(\"Hollywood\", FilePart(msg.destination) ..\n      \" does already exist!\\nDo you want me to overwrite it?\",\n      \"Yes|No\"))\n  Case #COPYFILE_UNPROTECT:\n    Return(SystemRequest(\"Hollywood\", FilePart(msg.destination) ..\n      \" is write/delete protected!\\nDo you want me to unprotect it?\",\n      \"Yes|No\"))\n  EndSwitch\n  Return(False)\nEndFunction\nCopyFile(\"Images\", \"Copy_of_Images\", {Callback = p_CopyCallback})\n```\n\nDemonstrates the use of a callback function.",
    "platforms": ["All"],
    "insertText": "CopyFile(${1:src$}, ${2:dst$})"
  },
  {
    "name": "CountDirectoryEntries",
    "helpId": "CountDirectoryEntries",
    "shortDescription": "count entries in directory",
    "version": "8.0",
    "synopsis": "n, ... = CountDirectoryEntries(id[, what, recursive])",
    "functionDocs": "This function can be used to count all entries in the directory specified by `id`. This directory must have been opened using [OpenDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/OpenDirectory_.html) or [@DIRECTORY](https://www.hollywood-mal.com/docs/html/hollywood/atDIRECTORY_.html) before.\n\nThe optional argument `what` can be used to specify what kind of entries should be counted. The following entry types are currently supported:\n\n- `#COUNTFILES`: Count all files in the directory. This is the default.\n\n- `#COUNTDIRECTORIES`: Count all directories in the directory.\n\n- `#COUNTBOTH`: Count both, files and directories.\n\n- `#COUNTSEPARATE`: In that mode, files and directories will be counted separately. This means that two values will be returned: The first return value contains the number of files counted, the second return value the number of directories counted. (V9.0)\n\nStarting with Hollywood 9.0, there is a new optional argument named `recursive`. If this is set to `True`, `CountDirectoryEntries()` will recurse into all subdirectories and include those in the count as well.\n\nNote that `CountDirectoryEntries()` will iterate through all entries in the directory so it must not be used during an iteration using [NextDirectoryEntry()](https://www.hollywood-mal.com/docs/html/hollywood/NextDirectoryEntry_.html). Doing so will automatically rewind any existing directory iterations.",
    "inputsDocs": "* `id` — identifier of the directory whose entries should be counted\n* `what` — optional: what should be counted (see above) (defaults to `#COUNTFILES`)\n* `recursive` — optional: whether or not counting should recurse into subdirectories as well (defaults to `False`) (V9.0)",
    "resultsDocs": "* `n` — number of entries of desired type in directory\n* `...` — optional: additional return values depending on the current count mode (see above)",
    "example": "```\nOpenDirectory(1, \"data\")\nNPrint(CountDirectoryEntries(1))\n```\n\nThe code above prints the number of files in the directory `data`.",
    "platforms": ["All"],
    "insertText": "CountDirectoryEntries(${1:id})"
  },
  {
    "name": "CRC32",
    "helpId": "CRC32",
    "shortDescription": "calculate 32-bit checksum of a file",
    "version": "2.0",
    "synopsis": "chk = CRC32(f$)",
    "functionDocs": "This function computes the 32-bit cyclic redundancy checksum (CRC32) for a given file. This checksum allows you to identify your files.\n\nIf you want to compute the CRC32 checksum of a string, use the [CRC32Str()](https://www.hollywood-mal.com/docs/html/hollywood/CRC32Str_.html) function instead.",
    "inputsDocs": "* `f$` — source file",
    "resultsDocs": "* `chk` — 32-bit CRC32 of `f$`",
    "platforms": ["All"],
    "insertText": "CRC32(${1:f$})"
  },
  {
    "name": "DecompressFile",
    "helpId": "DecompressFile",
    "shortDescription": "decompress a file",
    "version": "4.0",
    "synopsis": "size = DecompressFile(src$, dst$)",
    "functionDocs": "This function decompresses file `src$` and saves the unpacked data to `dst$`. The file must have been packed by the [CompressFile()](https://www.hollywood-mal.com/docs/html/hollywood/CompressFile_.html) function. The return value specifies the size of the uncompressed file.",
    "inputsDocs": "* `src$` — file to decompress\n* `dst$` — output file",
    "resultsDocs": "* `size` — size of the decompressed file",
    "example": "```\nDecompressFile(\"image.pak\", \"image.bmp\")\n```\n\nThe code above decompresses file image.pak to image.bmp.",
    "platforms": ["All"],
    "insertText": "DecompressFile(${1:src$}, ${2:dst$})"
  },
  {
    "name": "DefineVirtualFile",
    "helpId": "DefineVirtualFile",
    "shortDescription": "define a virtual file inside a real file",
    "version": "4.0",
    "synopsis": "virtfile$ = DefineVirtualFile(file$, offset, size, name$)",
    "functionDocs": "This function allows you to define a virtual file inside another file which can be useful in several situations. Imagine you are working on a game and you want to store all data of the game in one huge resource file. Now you need to load some data from this huge resource file and that is when `DefineVirtualFile()` comes into play.\n\nAs parameter 1 you pass the name of the file that shall be the source of the virtual file. Parameters 2 and 3 then define the location of the virtual file inside `file$`. The virtual file to be created will be located inside `file$` from file position offset to file position offset+size. Parameter 4 finally specifies the file name for the virtual file. The only thing that is important here is the file extension because it gives Hollywood a hint of the virtual file's type. Thus, you should make sure that you pass the correct file extension. The name does not matter, but the file extension should be passed because not all files can be easily identified by their header.\n\n`DefineVirtualFile()` returns a string describing the virtual file. You can pass this string to all Hollywood functions which accept a file name. Of course, only read access is supported by virtual files. Attempting to write to virtual files will not work.",
    "inputsDocs": "* `file$` — source file from which data of the virtual file shall be taken\n* `offset` — start position of the virtual file inside `file$`\n* `size` — length in bytes of the virtual file inside `file$`\n* `name$` — the name and file extension of the virtual file (see above)",
    "resultsDocs": "* `virtfile$` — string describing the virtual file",
    "example": "```\nvf$ = DefineVirtualFile(\"hugeresource.dat\", 100000, 32768, \"image.png\")\nLoadBrush(1, vf$, {LoadAlpha = True})\n```\n\nThe code above defines a virtual file inside \"hugeresource.dat\". The virtual file is of the size of 32768 bytes and starts at position 100000 inside \"hugeresource.dat\". The virtual file is a PNG image. After describing the virtual file, the image will be loaded with a simple call to LoadBrush().",
    "platforms": ["All"],
    "insertText": "DefineVirtualFile(${1:file$}, ${2:offset}, ${3:size}, ${4:name$})"
  },
  {
    "name": "DefineVirtualFileFromString",
    "helpId": "DefineVirtualFileFromString",
    "shortDescription": "define a virtual file from a string source",
    "version": "5.0",
    "synopsis": "virtfile$ = DefineVirtualFileFromString(data$, name$[, writable])",
    "functionDocs": "This function allows you to define a virtual file from a string source. A virtual file is a file that exists only in memory but you can still pass it to all Hollywood functions and they will act as if the file was really present on a physical drive. `DefineVirtualFileFromString()` takes two mandatory arguments: In the first argument you have to provide the data that shall constitute your virtual file's contents. Argument two specifies the name of the virtual file. The only thing that is important here is the file extension because it gives Hollywood a hint of the virtual file's type. Thus, you should make sure that you pass the correct file extension. The name does not matter, but the file extension should be passed because not all files can be easily identified by looking at their header bytes.\n\nStarting with Hollywood version 6.1 `DefineVirtualFileFromString()` also supports the creation of virtual files that can be written to. If you want the virtual file to be writable, you have to set the `writable` parameter to `True`. In that case, `DefineVirtualFileFromString()` will create a writable virtual file for you. The writable file will be initialized with the contents passed in `data$`. If you pass an empty string in `data$`, an empty new writable virtual file will be created.\n\n`DefineVirtualFileFromString()` returns a string describing the virtual file. You can pass this string to all Hollywood functions which accept a file name.\n\nPlease note that the file's contents are not limited to text only. You can also pass binary data inside `data$` because Hollywood strings can contain special control characters and the `NULL` character as well. Thus, it is perfectly possible to create virtual files containing binary data with this function.\n\nWhen you are finished dealing with the virtual file, you should free the virtual file by calling the [UndefineVirtualStringFile()](https://www.hollywood-mal.com/docs/html/hollywood/UndefineVirtualStringFile_.html) function. Doing this is important because it will free any memory occupied by the virtual file.",
    "inputsDocs": "* `data$` — source string that constitutes the virtual file's contents\n* `name$` — the name and file extension of the virtual file (see above)\n* `writable` — optional: `True` if this virtual file should be writable, `False` otherwise (defaults to `False`) (V6.1)",
    "resultsDocs": "* `virtfile$` — string describing the virtual file",
    "example": "```\nvf$ = DefineVirtualFileFromString(\"This is a virtual file test.\",\n                                  \"test.txt\")\nOpenFile(1, vf$)\nWhile Not Eof(1) Do Print(Chr(ReadChr(1)))\nCloseFile(1)\nUndefineVirtualStringFile(vf$)\n```\n\nThe code above creates a virtual text file and then reads from this virtual file using the Hollywood DOS library.\n\n---\n\n```\ndata$ = DownloadFile(\"http://www.airsoftsoftwair.de/images/\" ..\n                     \"products/hollywood/47_shot1.jpg\")\nvf$ = DefineVirtualFileFromString(data$, \"image.jpg\")\nLoadBrush(1, vf$)\nDisplayBrush(1, 0, 0)\nUndefineVirtualStringFile(vf$)\ndata$ = Nil\n```\n\nThe code above downloads a JPEG image to a string and loads the image directly into Hollywood without having to save it to an external file first.\n\n---\n\n```\nvf$ = DefineVirtualFileFromString(\"\", \"test.txt\", True)\nOpenFile(1, vf$, #MODE_WRITE)\nWriteLine(1, \"A virtual file test!\")\nCloseFile(1)\nCopyFile(vf$, GetSystemInfo().UserHome)\nUndefineVirtualStringFile(vf$)\n```\n\nThe code above writes a string to a virtual file and then copies this virtual file to the user's home directory.",
    "platforms": ["All"],
    "insertText": "DefineVirtualFileFromString(${1:data$}, ${2:name$})"
  },
  {
    "name": "DeleteFile",
    "helpId": "DeleteFile",
    "shortDescription": "delete a file or directory",
    "version": "1.0",
    "synopsis": "DeleteFile(file$[, t])",
    "functionDocs": "Deletes the file or directory specified in `file$`. Please note that this function will recursively delete whole directories by default. It does not check if the specified directory is empty or not! If you specify a directory, it will be deleted with all subdirectories and all files in it unless explicitly told not to do so. So be very careful with this function!\n\n`DeleteFile()` supports several optional arguments. Before Hollywood 9.0, those had to be passed as optional parameters (see above). Since Hollywood 9.0, however, it is recommended to use the new syntax, which has a single optional table argument that can be used to pass one or more optional arguments to `DeleteFile()`.\n\nThe following table fields are recognized by this function:\n\n- `Recursive`: By default, `DeleteFile()` will recurse into all subdirectories and delete them if `file$` specifies a directory. If you don't want that, set this tag to `False`. (V9.0)\n\n- `Force`: If this tag is set to `True`, write- or delete-protected files will automatically be deleted without asking the callback function first. Note that if there is no callback function and `Force` is set to `False` (the default), `DeleteFile()` will just skip all write- or delete-protected files. Defaults to `False`. (V9.0)\n\n- `MustExist`: By default, `DeleteFile()` will silently fail if you specify a file or directory that does not exist in `file$`. No error will be generated in this case. If you want `DeleteFile()` to show an error instead, set this tag to `True`. (V9.0)\n\n- `Pattern`: You can pass a filter pattern in this table field. In that case, `DeleteFile()` will only delete the files that match the specified pattern. For example, passing `*.jpg` in `Pattern` will only delete files that use the `.jpg` file extension. Of course, using a filter pattern makes only sense if you pass a directory in `file$`. Note that for historical reasons, the pattern specified in `Pattern` will also be matched against all subdirectories that are to be deleted. If you don't want that, set the `MatchDir` table tag to `False` (see below). The pattern specified in `Pattern` must adhere to the pattern rules as described in the documentation of the [MatchPattern()](https://www.hollywood-mal.com/docs/html/hollywood/MatchPattern_.html) function. See [MatchPattern](https://www.hollywood-mal.com/docs/html/hollywood/MatchPattern_.html). (V5.0)\n\n- `MatchDir`: This table field specifies whether or not the filter pattern specified in `Pattern` should also be matched against subdirectories. If this is set to `True`, `DeleteFile()` will only recurse into subdirectories that match the specified filter pattern. If it is set to `False`, `DeleteFile()` will recurse into all subdirectories. For compatibility reasons, `MatchDir` defaults to `True`, but most of the time you will want to pass `False` here because it usually does not make sense to match a file pattern against a directory name. For example, it does not make sense to match the `*.jpg` example from above against directories as well. (V5.0)\n\n- `FailOnError`: By default, `DeleteFile()` will fail if a file or directory can't be deleted. You can change this behaviour by setting `FailOnError` to `False`. In that case, `DeleteFile()` won't fail if a file or directory can't be deleted but instead your callback function, if there is one, will be notified using the `#DELETEFILE_FAILED` message and your callback must tell `DeleteFile()` how to proceed (retry, continue, abort). See below to learn how to set up a callback function for `DeleteFile()`. Note that `FailOnError` isn't used when `file$` is just a single file. It is only used when deleting complete directories or multiple files using patterns. `FailOnError` defaults to `True`. (V9.0)\n\n- `Async`: If this is set to `True`, `DeleteFile()` will operate in asynchronous mode. This means that it will return immediately, passing an asynchronous operation handle to you. You can then use this asynchronous operation handle to finish the operation by repeatedly calling [ContinueAsyncOperation()](https://www.hollywood-mal.com/docs/html/hollywood/ContinueAsyncOperation_.html) until it returns `True`. This is very useful in case your script needs to do something else while the operation is in progress, e.g. displaying a status animation or something similar. By putting `DeleteFile()` into asynchronous mode, it is easily possible for your script to do something else while the operation is being processed. See [ContinueAsyncOperation](https://www.hollywood-mal.com/docs/html/hollywood/ContinueAsyncOperation_.html). Defaults to `False`. (V9.0)\n\n- `Adapter`: This tag allows you to specify one or more filesystem adapters that should be asked to handle the operation. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to filesystem adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\n- `Callback`: For fine-tuned control of the delete operation, you can specify a callback function that will be called on various occasions. For example, `DeleteFile()` will call it from time to time so that you can update a progress bar. It will also be called when a file is delete-protected to ask you how to proceed. If there is no callback function, `DeleteFile()` will silently skip delete-protected files. The callback function receives one argument: A table that contains more information.\n\n  The following callback types are available:\n\n  - `#DELETEFILE_UNPROTECT`: The callback function of type `#DELETEFILE_UNPROTECT` will be called if a file that should be deleted is delete-protected. This callback function needs to return `True`, if it is okay to unprotect the file or `False` if it shall not be unprotected. If you return -1, the delete operation will be completely aborted.\n\n    - `Action`: `#DELETEFILE_UNPROTECT`\n\n    - `File`: Contains the delete protected file that is to be unprotected. (fully qualified path)\n\n    - `UserData`: Contains the value you specified in the `UserData` table field (see below).\n\n    (V2.0)\n\n  - `#DELETEFILE_STATUS`: This callback will be run whenever a file is deleted. This is useful for updating a status bar, for example. The callback function of type `#DELETEFILE_STATUS` should normally return `False`. If it returns `True`, the delete operation will be aborted.\n\n    - `Action`: `#DELETEFILE_STATUS`\n\n    - `File`: Contains the fully qualified path of the file that is to be deleted next\n\n    - `UserData`: Contains the value you specified in the `UserData` table field (see below).\n\n    (V2.0)\n\n  - `#DELETEFILE_FAILED`: This callback can only be called if the `FailOnError` tag has been set to `False` (see above). In that case, the callback function of type `#DELETEFILE_FAILED` will be called whenever a delete operation has failed. It has to return `True` to abort the delete operation, `False` to continue even though an error has occurred or -1 to retry the delete operation that has just failed. The following fields will be set in the table parameter that is passed to your callback function:\n\n    - `Action`: `#DELETEFILE_FAILED`\n\n    - `File`: Contains the fully qualified path of the file that could not be deleted.\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n    (V9.0)\n\n- `UserData`: This field can be used to pass an arbitrary value to your callback function. The value you specify here will be passed to your callback function whenever it is called. This is useful if you want to avoid working with global variables. Using the `UserData` tag you can easily pass data to your callback function. You can specify a value of any type in `UserData`. Numbers, strings, tables, and even functions can be passed as user data. Your callback will receive this data in the `UserData` field in the table that is passed to it. (V3.1)",
    "inputsDocs": "* `file$` — Filename or directory to delete\n* `t` — optional: table containing further options (see above) (V9.0)",
    "example": "```\nDeleteFile(\"FooBar\")\n```\n\nDeletes the file (or directory) \"FooBar\" from the current directory.\n\n---\n\n```\nFunction p_DeleteCallback(msg)\n  Switch msg.action\n  Case #DELETEFILE_STATUS:\n    DebugPrint(\"Now deleting\", FilePart(msg.file))\n  Case #DELETEFILE_UNPROTECT:\n    Return(SystemRequest(\"Hollywood\", FilePart(msg.file) ..\n      \" is delete protected!\\nDo you want me to unprotect it?\",\n      \"Yes|No\"))\n  EndSwitch\n  Return(False)\nEndFunction\nDeleteFile(\"TestDir\", {Callback = p_DeleteCallback})\n```\n\nDemonstrates the usage of a callback function. It will delete the directory \"TestDir\" from the current directory and print out information about the file that is currently being deleted.",
    "platforms": ["All"],
    "insertText": "DeleteFile(${1:file$})"
  },
  {
    "name": "DirectoryItems",
    "helpId": "DirectoryItems",
    "shortDescription": "iterate over all items in a directory",
    "version": "7.0",
    "synopsis": "f = DirectoryItems(d$)",
    "functionDocs": "This function can be used together with the generic [For](https://www.hollywood-mal.com/docs/html/hollywood/PrgFor_.html) statement to traverse all files and sub-directories in a directory. It returns an iterator function which will return two values for each directory item: The first return value will be the name of the file or directory, the second return value will be a table with additional information about the directory item. Once all directory items have been returned, the iterator function will return [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) to break the generic [For](https://www.hollywood-mal.com/docs/html/hollywood/PrgFor_.html) statement.\n\nSee [Generic For statement](https://www.hollywood-mal.com/docs/html/hollywood/PrgFor_.html).\n\nThe table that is returned by `DirectoryItems()` as the second return value when used in a generic [For](https://www.hollywood-mal.com/docs/html/hollywood/PrgFor_.html) loop will have the following fields initialized:\n\n- `Type`: This will be `#DOSTYPE_FILE` if the entry is a file or `#DOSTYPE_DIRECTORY` if the entry is a directory.\n\n- `Size`: This field will only be present if the entry is a file. In that case, this field will receive the size of the file in bytes.\n\n- `Flags`: This field will receive a combination of protection flags of the file or directory. See [Protection flags](https://www.hollywood-mal.com/docs/html/hollywood/ProtFlagsInfo_.html).\n\n- `Time`: This field will receive a string containing the time the file or directory was last modified. The string will always be in the format dd-mmm-yyyy hh:mm:ss. E.g.: 08-Nov-2004 14:32:13.\n\n- `LastAccessTime`: This field will receive a string containing the time the file or directory was last accessed. This attribute is not supported on AmigaOS.\n\n- `CreationTime`: This field will receive a string containing the time the file or directory was created. This attribute is only supported on Windows.\n\n- `Comment`: This field will contain the comment of a file. This is only supported by the Amiga versions.\n\nNote that you can also manually traverse all files and sub-directories inside a directory by using the [OpenDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/OpenDirectory_.html), [NextDirectoryEntry()](https://www.hollywood-mal.com/docs/html/hollywood/NextDirectoryEntry_.html) and [CloseDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/CloseDirectory_.html) functions. Using `DirectoryItems()`, however, is often more convenient.",
    "inputsDocs": "* `d$` — directory to traverse",
    "resultsDocs": "* `f` — iterator function for generic for loop",
    "example": "```\nFunction p_TraverseDir(d$, indent)\n   For s$,t In DirectoryItems(d$)\n      DebugPrint(RepeatStr(\" \", indent) .. s$, t.time)\n      If t.type = #DOSTYPE_DIRECTORY\n        p_TraverseDir(FullPath(d$, s$), indent + 8)\n      EndIf\n   Next\nEndFunction\n\np_TraverseDir(\"images\", 0)\n```\n\nThe function `p_TraverseDir()` can be used recursively print all files and sub-directories in the given directory. The example call prints the contents of a directory named \"images\" that must be stored relative to the script's path.",
    "platforms": ["All"],
    "insertText": "DirectoryItems(${1:d$})"
  },
  {
    "name": "Eof",
    "helpId": "Eof",
    "shortDescription": "returns whether end of file has been reached",
    "version": "1.0",
    "synopsis": "result = Eof(id)",
    "functionDocs": "Returns `True` in case the end of the file specified by `id` has been reached. Otherwise returns `False`.",
    "inputsDocs": "* `id` — identifier of a file",
    "resultsDocs": "* `result` — `True` if end of file was reached or `False`",
    "example": "See [OpenFile](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html)",
    "platforms": ["All"],
    "insertText": "Eof(${1:id})"
  },
  {
    "name": "Execute",
    "helpId": "Execute",
    "shortDescription": "synchronously execute a program",
    "version": "1.0",
    "synopsis": "Execute(file$[, args$, t])",
    "functionDocs": "This function executes the program specified by `file$` synchronously and passes the arguments specified in `args$` to it. If you need to execute a program asynchronously, you have to use the [Run()](https://www.hollywood-mal.com/docs/html/hollywood/Run_.html) function. See [Run](https://www.hollywood-mal.com/docs/html/hollywood/Run_.html).\n\nIf supported by the operating system, this command can also be used to view data files like documents or images using their default viewer. In that case, `file$` can also be a non-executable file like a JPEG image or an MP3 file.\n\nOn Android `file$` has to be either a data file like a JPEG image or a package name like `com.airsoftsoftwair.hollywood` if you want this function to start another app.\n\nNote that due to historical reasons, there are some pitfalls when using this function. Before Hollywood 9.0 this command expected program and arguments combined in just a single `cmdline$` string. In that case, extra care has to be taken when dealing with spaces (see below for details). Starting with Hollywood 9.0, there is a new syntax which allows you to pass program and arguments as two separate arguments which makes things much easier. However, to maintain compatibility with previous versions this new syntax can only be used if you explicitly pass a string in the second argument. So if you want to use the new syntax, make sure to pass a string in the second argument. If the program you want to start doesn't need any arguments, just pass an empty string (\"\") just to signal Hollywood that you want to use the new syntax.\n\nIf you don't pass a string in the second argument, the old syntax will be used which means that you need to be very careful when passing program paths that contain spaces since the very first space in `cmdline$` is interpreted as the separator of program and arguments. If you want to start a program whose path specification uses spaces, you need to use double quotes around this path specification or it won't work. You can easily avoid these complications by simply passing a string in the second argument, even if it is empty (see above for details).\n\nStarting with Hollywood 9.0, it is possible to specify the program and its arguments in two separate arguments, which makes things much more convenient. Also, there is a new optional table argument now that can be used to specify further options.\n\nThe following options are currently supported by the optional table argument:\n\n- `Directory`: This table argument allows you to set the current directory for the program that is to be started. (V9.0)\n\n- `ResetKeys`: This table argument is only interesting for advanced users. If this is set to `False`, `Execute()` won't reset all internal key states after executing the program. By default, all key states will be reset when `Execute()` returns because programs started using `Execute()` often assume the keyboard focus and Hollywood might be unable to reset its internal state flags because the new program started via `Execute()` takes over keyboard focus. That's why by default `Execute()` will reset all internal key state flags when it returns. Disabling this behaviour can make sense if you use `Execute()` to start programs that don't have a GUI and don't take away the keyboard focus. Defaults to `True`. (V5.1)\n\n- `ForceExe`: If this tag is set to `True`, `Execute()` will always treat the file passed in `file$` as an executable. This is only useful on Linux and macOS because on those platforms files that have an extension will be treated as data files so Hollywood will try to launch the corresponding viewer for the data file instead. Thus, trying to use `Execute()` on an executable named \"test.exe\" will not work on Linux and macOS because of the *.exe extension. By setting `ForceExe` to `True`, however, you can make it work. Defaults to `False`. (V9.0)\n\n- `Verb`: On Windows, this can be set to a string telling `Execute()` what to do with the file. This can be one of the following verbs:\n\n  - `edit` Opens the specified file in an editor.\n\n  - `explore` Opens the specified folder in Explorer. When using this verb, you must pass a folder instead of a file to `Execute()`.\n\n  - `find` Opens the search dialog for the specified folder. When using this verb, you must pass a folder instead of a file to `Execute()`.\n\n  - `open` Opens the specified file.\n\n  - `print` Prints the specified file.\n\n  - `runas` Launches the specified file in administrator mode.\n\n  Note that the `Verb` tag is only supported on Windows. (V9.1)",
    "inputsDocs": "* `file$` — the program (or data file) to be started\n* `args$` — optional: arguments to pass to the program; note that you must pass this parameter to signal Hollywood to use the new syntax; you can do so by just passing an empty string (\"\"); see above for a detailed discussion (V9.0)\n* `t` — optional: table containing further arguments (see above) (V9.0)",
    "example": "```\nExecute(\"Sys:Prefs/Locale\")\n```\n\nOn AmigaOS systems the above code executes the locale preferences. Your script's execution will be halted until the user closes the locale preferences (synchronous execution).\n\n---\n\n```\nExecute(\"Echo\", \">Ram:Test \\\"Hello World\\\"\")\n```\n\nOn AmigaOS systems the above code writes \"Hello World\" to \"Ram:Test\".\n\n---\n\n```\nExecute(\"\\\"C:\\\\Program Files (x86)\\\\Hollywood\\\\ide.exe\\\"\")\n```\n\nThe code above runs the Hollywood IDE on Windows systems. Note that we've embedded the program specification inside double quotes. This is absolutely necessary because the first space in the string passed to `Execute()` is normally interpreted as the separator between program and arguments. If we didn't use double quotes in the code above, `Execute()` would try to start the program \"C:\\Program\" and pass the arguments \"Files (x86)\\Hollywood\\ide.exe\" to it which we obviously don't want. Note that since Hollywood 9.0, it is now much easier to deal with spaces in paths. You just need to use the new syntax which takes the program and its arguments in two separate arguments. With Hollywood 9.0, you could simply use this code:\n\n---\n\n```\nExecute(\"C:\\\\Program Files (x86)\\\\Hollywood\\\\ide.exe\", \"\")\n```\n\nNote that passing the empty string in the second argument is absolutely necessary here to signal Hollywood that you want to use the new syntax. See above for a detailed discussion on this.",
    "platforms": ["All"],
    "insertText": "Execute(${1:file$})"
  },
  {
    "name": "Exists",
    "helpId": "Exists",
    "shortDescription": "check if the specified file exists",
    "version": "1.0",
    "synopsis": "result = Exists(filename$)",
    "functionDocs": "Checks if the file specified by `filename$` exists and returns `True` to the variable result if it does. Otherwise result receives the value of `False`.",
    "inputsDocs": "* `filename$` — file to check",
    "resultsDocs": "* `result` — `True` if the specified file exists, `False` otherwise",
    "example": "```\nresult = Exists(\"test.hws\")\nPrint(result)\n```\n\nThis tests whether the file \"test.hws\" exists in the current directory and returns `True` or `False`.",
    "platforms": ["All"],
    "insertText": "Exists(${1:filename$})"
  },
  {
    "name": "FileAttributes",
    "helpId": "FileAttributes",
    "shortDescription": "get attributes of a file",
    "version": "6.0",
    "synopsis": "t = FileAttributes(id)",
    "functionDocs": "This function returns a table that contains the attributes of a file that has been opened using [OpenFile()](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html). This includes information such as the file time, the full path of the file, protection flags, and more, depending on the host file system.\n\nOn return, the table will have the following fields initialized:\n\n- `Path`: This field will contain a string with the full path to this file.\n\n- `Size`: This field will be set to the size of the file in bytes.\n\n- `Flags`: This field will be set to a combination of protection flags of the file. See [Protection flags](https://www.hollywood-mal.com/docs/html/hollywood/ProtFlagsInfo_.html).\n\n- `Time`: This field will receive a string containing the time the file or directory was last modified. The string will always be in the format dd-mmm-yyyy hh:mm:ss. E.g.: 08-Nov-2004 14:32:13.\n\n- `LastAccessTime`: This field will receive a string containing the time the file or directory was last accessed. This attribute is not supported on AmigaOS.\n\n- `CreationTime`: This field will receive a string containing the time the file or directory was created. This attribute is only supported on Windows.\n\n- `Comment`: This field will contain the comment of a file. This is only supported by the Amiga versions.\n\n- `Streaming`: This field will be set to `True` if the file is being streamed from a remote source instead of being read from a physical drive.\n\n- `NoSeek`: This field will be set to `True` if this file cannot be seeked. This could happen if the file is being streamed from a remote source that only allows sequential reads without any seeking capabilities.\n\nIf you want to query the attributes of a file that is not currently open, use [GetFileAttributes()](https://www.hollywood-mal.com/docs/html/hollywood/GetFileAttributes_.html) instead. See [GetFileAttributes](https://www.hollywood-mal.com/docs/html/hollywood/GetFileAttributes_.html).",
    "inputsDocs": "* `id` — identifier of the file to query",
    "resultsDocs": "* `t` — a table initialized as shown above",
    "example": "```\nOpenFile(1, \"test.txt\")\nt = FileAttributes(1)\nPrint(t.time)\nIf t.flags & #FILEATTR_READ_USR\n  Print(\"#FILEATTR_READ_USR is set.\")\nElse\n  Print(\"#FILEATTR_READ_USR is not set.\")\nEndIf\n```\n\nThe code above examines the file \"test.txt\" and prints the time it was last modified to the screen. Additionally, it checks if the protection flag `#FILEATTR_READ_USR` is set.",
    "platforms": ["All"],
    "insertText": "FileAttributes(${1:id})"
  },
  {
    "name": "FileLength",
    "helpId": "FileLength",
    "shortDescription": "return size of an open file",
    "version": "3.0",
    "synopsis": "size = FileLength(id)",
    "functionDocs": "This function returns the current size of the file specified by `id`. The size returned by this function will be up to date with all operations done on this file. For example, you could write to the file and then `FileLength()` would return the new size of the file.\n\nPlease note that `FileLength()` can also return -1 if it does not know the file's size. This can happen in case the file is read from a streamed source through a file adapter, for example.",
    "inputsDocs": "* `id` — identifier of the file to query",
    "resultsDocs": "* `size` — current size of this file",
    "example": "```\nOpenFile(1, \"test.txt\", #MODE_WRITE)\nNPrint(FileLength(1))\nWriteLine(1, \"Hello World.\")\nNPrint(FileLength(1))\nCloseFile(1)\n```\n\nThe code above opens file \"test.txt\" for writing and calls `FileLength()` twice. The first call will return 0 because the file is empty at that point but the second call will return 13 because some characters have been written to the file now.",
    "platforms": ["All"],
    "insertText": "FileLength(${1:id})"
  },
  {
    "name": "FileLines",
    "helpId": "FileLines",
    "shortDescription": "return a line-based iterator function",
    "version": "5.0",
    "synopsis": "f = FileLines(file$)",
    "functionDocs": "This function can be used in conjunction with the generic [For](https://www.hollywood-mal.com/docs/html/hollywood/PrgFor_.html) statement to traverse over all lines of a file. It will return an iterator function which will return the next line of the file specified in `file$`. When the end of the file is reached, the iterator function will return [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) to break the generic [For](https://www.hollywood-mal.com/docs/html/hollywood/PrgFor_.html) statement.\n\nSee [Generic For statement](https://www.hollywood-mal.com/docs/html/hollywood/PrgFor_.html).",
    "inputsDocs": "* `file$` — source filename",
    "resultsDocs": "* `f` — line-based iterator function",
    "example": "```\nFor s$ In FileLines(\"Highscores.txt\") Do DebugPrint(s$)\n```\n\nThis will print all lines of the file \"Highscores.txt\".",
    "platforms": ["All"],
    "insertText": "FileLines(${1:file$})"
  },
  {
    "name": "FilePart",
    "helpId": "FilePart",
    "shortDescription": "return the file component of a path",
    "version": "1.0",
    "synopsis": "file$ = FilePart(path$)",
    "functionDocs": "This function extracts the filename from a path specified by path$ and returns it.",
    "inputsDocs": "* `path$` — source path",
    "resultsDocs": "* `file$` — file part",
    "example": "```\nf$ = FilePart(\"Data/Gfx/Test.jpg\")\nPrint(f$)\n```\n\nThe above code prints \"Test.jpg\" to the screen.",
    "platforms": ["All"],
    "insertText": "FilePart(${1:path$})"
  },
  {
    "name": "FilePos",
    "helpId": "FilePos",
    "shortDescription": "return file cursor position",
    "version": "2.0",
    "synopsis": "pos = FilePos(id)",
    "functionDocs": "This function returns the file cursor position of the file specified by `id`. The cursor starts at 0 (beginning of the file) and ends at the length of the file. You can use this function to find out where you are in a file because all read and write operations will start at this cursor position. You can use [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) to modify the file cursor position.",
    "inputsDocs": "* `id` — identifier of the file to query",
    "resultsDocs": "* `pos` — cursor position of this file",
    "example": "```\nOpenFile(1, \"test.txt\", #MODE_READ)\nSeek(1, 1024)\nPrint(FilePos(1))\nCloseFile(1)\n```\n\nThis prints 1024.",
    "platforms": ["All"],
    "insertText": "FilePos(${1:id})"
  },
  {
    "name": "FileSize",
    "helpId": "FileSize",
    "shortDescription": "return the size of a specified file",
    "version": "1.0",
    "synopsis": "size = FileSize(file$)",
    "functionDocs": "Returns the size of file `file$`. If the file does not exist, -1 is returned.\n\nPlease note that `FileSize()` can also return -1 if it does not know the file's size. This can happen in case the file is read from a streamed source through a file adapter, for example.",
    "inputsDocs": "* `file$` — source filename",
    "resultsDocs": "* `size` — size of the specified file in bytes",
    "example": "```\nresult = FileSize(\"test.jpg\")\nPrint(\"The file test.jpg takes up\", result, \"bytes!\")\n```\n\nThis will print the size of the file \"test.jpg\".",
    "platforms": ["All"],
    "insertText": "FileSize(${1:file$})"
  },
  {
    "name": "FileToString",
    "helpId": "FileToString",
    "shortDescription": "read whole file into a string",
    "version": "5.0",
    "synopsis": "s$, len = FileToString(file$[, t])",
    "functionDocs": "This command is a convenience function which simply reads the specified file into memory and returns it as a string. The second return value contains the file length in bytes. Note that since Hollywood strings can also contain binary data, you can also use this function to read non-text files into strings.\n\nStarting with Hollywood 10.0, `FileToString()` accepts an optional table argument that allows you to pass additional arguments to the function. The following tags are currently supported by the optional table argument:\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked if they want to open the specified file. If you use this tag, you must set it to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to file adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `file$` — file to read into string\n* `t` — optional: table containing additional options (see above) (V10.0)",
    "resultsDocs": "* `s$` — contents of the specified file as a string\n* `len` — length of the file in bytes",
    "platforms": ["All"],
    "insertText": "FileToString(${1:file$})"
  },
  {
    "name": "FlushFile",
    "helpId": "FlushFile",
    "shortDescription": "flush all pending buffers",
    "version": "2.5",
    "synopsis": "FlushFile(id)",
    "functionDocs": "This function flushes any pending buffers on the file specified by `id` and re-adjusts the file cursor. It is important that you call this function if you switch between buffered and unbuffered IO on the same file. If you do not use [SetIOMode()](https://www.hollywood-mal.com/docs/html/hollywood/SetIOMode_.html) at all, you do not have to worry about flushing buffers either because everything will be done automatically by the file system if you only use buffered IO.",
    "inputsDocs": "* `id` — identifier of the file to be flushed",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "FlushFile(${1:id})"
  },
  {
    "name": "FullPath",
    "helpId": "FullPath",
    "shortDescription": "combine directory and file into a path",
    "version": "2.0",
    "synopsis": "path$ = FullPath(dir$, file$[, ...])",
    "functionDocs": "This function combines `dir$` and `file$` into a path specification.\n\nStarting with Hollywood 9.0, this function accepts an unlimited number of arguments, allowing you to combine an unlimited number of path constituents into a single path.",
    "inputsDocs": "* `dir$` — source directory\n* `file$` — source file\n* `...` — optional: additional items to be appended to the path (V9.0)",
    "resultsDocs": "* `path$` — path specification",
    "example": "```\npath$ = FullPath(\"/home/andreas\", \"image.jpg\")\n```\n\n`path$` receives the string \"/home/andreas/image.jpg\".\n\n---\n\n```\npath$ = FullPath(\"/home\", \"andreas\", \"image.jpg\")\n```\n\nThis does the same as the first example but passes three instead of two arguments to `FullPath()`.",
    "platforms": ["All"],
    "insertText": "FullPath(${1:dir$}, ${2:file$})"
  },
  {
    "name": "GetCurrentDirectory",
    "helpId": "GetCurrentDirectory",
    "shortDescription": "return full path of current directory",
    "version": "4.5",
    "synopsis": "dir$ = GetCurrentDirectory([t])",
    "functionDocs": "This function simply returns a fully qualified path to the current directory. You can change the current directory using [ChangeDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/ChangeDirectory_.html).\n\nStarting with Hollywood 10.0, this function accepts an optional table argument which supports the following tags:\n\n- `Adapter`: This tag allows you to specify one or more filesystem adapters that should be asked to handle the operation. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to filesystem adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `t` — optional: table argument containing further options (see above) (V10.0)",
    "resultsDocs": "* `dir$` — path to the current directory",
    "platforms": ["All"],
    "insertText": "GetCurrentDirectory()"
  },
  {
    "name": "GetDirectoryEntry",
    "helpId": "GetDirectoryEntry",
    "shortDescription": "get entry from linked directory",
    "version": "8.0",
    "synopsis": "e$ = GetDirectoryEntry(id, entry$)",
    "functionDocs": "This function can be used to get the entry specified by `entry$` from the directory specified by `id`. This directory must have been opened by using the [@DIRECTORY](https://www.hollywood-mal.com/docs/html/hollywood/atDIRECTORY_.html) preprocessor command before.\n\nWhen called from an applet or executable which has all the files in the directory specified by `id` linked to it, `GetDirectoryEntry()` will return a special handle which can then be passed to all Hollywood functions that accept a file or directory name, e.g. [LoadBrush()](https://www.hollywood-mal.com/docs/html/hollywood/LoadBrush_.html).\n\nIf this function is called when just running a script with the Hollywood interpreter, i.e. not from a stand-alone applet or executable, `GetDirectoryEntry()` will simply return the string that has been passed to it in `entry$`, which makes it possible for scripts using [@DIRECTORY](https://www.hollywood-mal.com/docs/html/hollywood/atDIRECTORY_.html) to behave exactly the same, no matter whether they have been compiled as applets or executables, or if they are run as scripts using the Hollywood interpreter. If they are run using the Hollywood interpreter, they will just load the data from a real file then, whereas the data will be loaded directly from the applet or executable in case `GetDirectoryEntry()` is called from a stand-alone applet or executable.",
    "inputsDocs": "* `id` — identifier of the directory to query\n* `entry$` — entry of the directory you want to receive",
    "resultsDocs": "* `e$` — special handle to this entry that can be passed to all Hollywood functions accepting files or directories as their parameters",
    "example": "See [DIRECTORY](https://www.hollywood-mal.com/docs/html/hollywood/atDIRECTORY_.html)",
    "platforms": ["All"],
    "insertText": "GetDirectoryEntry(${1:id}, ${2:entry$})"
  },
  {
    "name": "GetEnv",
    "helpId": "GetEnv",
    "shortDescription": "read environment variable",
    "version": "5.0",
    "synopsis": "s$, ok = GetEnv(var$)",
    "functionDocs": "This command can be used to read the contents of the environment variable specified in `var$`. If the specified environment variable could not be found, an empty string is returned and the second return value is set to `False`. If the environment variable could be found, the second return value will be `True`.",
    "inputsDocs": "* `var$` — environment variable to examine",
    "resultsDocs": "* `s$` — contents of specified environment variable\n* `ok` — `True` or `False` depending whether or not the specified environment variable could be found",
    "platforms": ["All"],
    "insertText": "GetEnv(${1:var$})"
  },
  {
    "name": "GetFileAttributes",
    "helpId": "GetFileAttributes",
    "shortDescription": "get attributes of a file or directory",
    "version": "3.0",
    "synopsis": "t = GetFileAttributes(f$[, table])",
    "functionDocs": "This function returns a table that contains the attributes of a file or directory. This includes information such as the file time, the full path of the file, protection flags, and more, depending on the host file system. Pass the name of a file or a directory to this command. You can specify an empty string (\"\") to get information of the current directory.\n\nThis function accepts an optional table argument which can be used to pass additional parameters. The following table elements are currently recognized:\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked to open the specified file. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to file adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\nOn return, the table will have the following fields initialized:\n\n- `Type`: This will be `#DOSTYPE_FILE` if `f$` is a file or `#DOSTYPE_DIRECTORY` if `f$` is a directory.\n\n- `Path`: This field will contain a string with the full path to this file or directory.\n\n- `Size`: This field will only be present if `f$` is a file. In that case, this field will receive the size of the file in bytes.\n\n- `Flags`: This field will receive a combination of protection flags of the file or directory. See [Protection flags](https://www.hollywood-mal.com/docs/html/hollywood/ProtFlagsInfo_.html).\n\n- `Time`: This field will receive a string containing the time the file or directory was last modified. The string will always be in the format dd-mmm-yyyy hh:mm:ss. E.g.: 08-Nov-2004 14:32:13.\n\n- `LastAccessTime`: This field will receive a string containing the time the file or directory was last accessed. This attribute is not supported on AmigaOS.\n\n- `CreationTime`: This field will receive a string containing the time the file or directory was created. This attribute is only supported on Windows.\n\n- `Comment`: This field will contain the comment of a file. This is only supported by the Amiga versions.\n\n- `Virtual`: This field will be set to `True` if the file you passed to this function is a virtual file, i.e. a file linked to your applet/executable or a file created using [DefineVirtualFile()](https://www.hollywood-mal.com/docs/html/hollywood/DefineVirtualFile_.html). (V5.2)\n\nIf you want to query the attributes of a file that you have opened using [OpenFile()](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html), use [FileAttributes()](https://www.hollywood-mal.com/docs/html/hollywood/FileAttributes_.html) instead. See [FileAttributes](https://www.hollywood-mal.com/docs/html/hollywood/FileAttributes_.html).",
    "inputsDocs": "* `f$` — name of file or directory to be examined\n* `table` — optional: table containing further options (see above) (V10.0)",
    "resultsDocs": "* `t` — a table initialized as shown above",
    "example": "```\nt = GetFileAttributes(\"test.txt\")\nPrint(t.time)\nIf t.flags & #FILEATTR_READ_USR\n  Print(\"#FILEATTR_READ_USR is set.\")\nElse\n  Print(\"#FILEATTR_READ_USR is not set.\")\nEndIf\n```\n\nThe code above examines the file \"test.txt\" and prints the time it was last modified to the screen. Additionally, it checks if the protection flag `#FILEATTR_READ_USR` is set.",
    "platforms": ["All"],
    "insertText": "GetFileAttributes(${1:f$})"
  },
  {
    "name": "GetProgramDirectory",
    "helpId": "GetProgramDirectory",
    "shortDescription": "return program directory",
    "version": "9.0",
    "synopsis": "dir$ = GetProgramDirectory()",
    "functionDocs": "This function returns the program's directory. Note that using this function only makes sense in compiled programs because when running scripts, `GetProgramDirectory()` will return the directory of the Hollywood interpreter because there is no other program at this time.",
    "inputsDocs": "none",
    "resultsDocs": "* `dir$` — path to the program directory",
    "platforms": ["All"],
    "insertText": "GetProgramDirectory()"
  },
  {
    "name": "GetStartDirectory",
    "helpId": "GetStartDirectory",
    "shortDescription": "return initial directory",
    "version": "9.0",
    "synopsis": "dir$ = GetStartDirectory()",
    "functionDocs": "This function returns the directory that was the current directory when the Hollywood script was started. This is only of use when running Hollywood scripts because in that case Hollywood will always change the current directory to the script's directory (unless you use the [-nochdir](https://www.hollywood-mal.com/docs/html/hollywood/ManualUsage_.html) console argument) so it's not easily possible to find out the directory that was current before Hollywood changed it to the script's directory.\n\nFor compiled programs, the start directory will obviously always be identical to the program directory that you can get using [GetProgramDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/GetProgramDirectory_.html). See [GetProgramDirectory](https://www.hollywood-mal.com/docs/html/hollywood/GetProgramDirectory_.html).",
    "inputsDocs": "none",
    "resultsDocs": "* `dir$` — path to the initial directory",
    "platforms": ["All"],
    "insertText": "GetStartDirectory()"
  },
  {
    "name": "GetTempFileName",
    "helpId": "GetTempFileName",
    "shortDescription": "return name for a temporary file",
    "version": "3.0",
    "synopsis": "f$ = GetTempFileName()",
    "functionDocs": "This function can be used to obtain a file that you can use temporarily. This is useful in case you temporarily need to store some information in a file which you will delete later. Hollywood will delete all temporary files automatically when it terminates but you can also do that manually using [DeleteFile()](https://www.hollywood-mal.com/docs/html/hollywood/DeleteFile_.html).\n\nIt is preferable to use this function if you need to work with temporary files because each operating system stores its temporary files in a different place. By using this function you can be sure that your temporary files end up in the correct folder.\n\nPlease note that this function will not only return a file name but it will also create an empty file for you. This is done to avoid any possible race conditions with other applications which might want to store their own temporary file under the very same name. This is not possible if the file already exists so this is why `GetTempFileName()` will create an empty file for you.",
    "inputsDocs": "none",
    "resultsDocs": "* `f$` — file name that you can use for temporary operations",
    "example": "```\nf$ = GetTempFileName()\nOpenFile(1, f$, #MODE_WRITE)\nWriteLine(1, \"My temporary file\")\nCloseFile(1)\n```\n\nThe code above will obtain the name of a temporary file and then write some text into it. The file will be automatically deleted when Hollywood terminates.",
    "platforms": ["All"],
    "insertText": "GetTempFileName()"
  },
  {
    "name": "GetVolumeInfo",
    "helpId": "GetVolumeInfo",
    "shortDescription": "get space information about a volume",
    "version": "1.0",
    "synopsis": "space = GetVolumeInfo(vol$, type)",
    "functionDocs": "This function queries the volume specified by `vol$` for the information specified by `type`. The following constants are possible for `type`:\n\n- `#FREESPACE`: Returns the free space of the volume\n\n- `#USEDSPACE`: Returns the used space of the volume",
    "inputsDocs": "* `vol$` — name of a DOS volume\n* `type` — one of the constants as listed above",
    "resultsDocs": "* `info` — free/used space of the volume",
    "example": "```\nspace = GetVolumeInfo(\"SYS:\",#FREESPACE)\nPrint(space, \"bytes are free on SYS:!\")\n```\n\nThe above code returns the free space on your SYS: volume on AmigaOS systems.",
    "platforms": ["All"],
    "insertText": "GetVolumeInfo(${1:vol$}, ${2:type})"
  },
  {
    "name": "GetVolumeName",
    "helpId": "GetVolumeName",
    "shortDescription": "get a volume name",
    "version": "1.0",
    "synopsis": "name$ = GetVolumeName(vol$)",
    "functionDocs": "This function tries to get the name of the volume specified by `vol$`. If it is successful, the volume's name is returned to `name$`.",
    "inputsDocs": "* `vol$` — a DOS volume descriptor",
    "resultsDocs": "* `name$` — name of the volume",
    "example": "```\nn$=GetVolumeName(\"df0:\")\nPrint(n$)\n```\n\nThe above code prints the name of the volume in drive df0: (if there is any).",
    "platforms": ["All"],
    "insertText": "GetVolumeName(${1:vol$})"
  },
  {
    "name": "HaveVolume",
    "helpId": "HaveVolume",
    "shortDescription": "check if a volume exists in the system",
    "version": "8.0",
    "synopsis": "r = HaveVolume(vol$)",
    "functionDocs": "This function can be used to check if the volume specified by `vol$` is currently available. This is especially useful on AmigaOS and compatible systems because it will suppress the \"Please insert volume XXX into any drive\" system requester that usually pops up on AmigaOS systems when trying to access non-existent volumes. By checking the existence of the volume using this command first, you can easily get rid of the annoying requester on AmigaOS.",
    "inputsDocs": "* `vol$` — name of a DOS volume whose presence should be checked",
    "resultsDocs": "* `r` — `True` if volume exists, `False` otherwise",
    "example": "```\nPrint(HaveVolume(\"FOOBAR:\"))\n```\n\nThe code above should return 0 because the specified typically doesn't exist. On AmigaOS, there will be no system requester asking for volume \"FOOBAR:\" if you use this code.",
    "platforms": ["All"],
    "insertText": "HaveVolume(${1:vol$})"
  },
  {
    "name": "IsAbsolutePath",
    "helpId": "IsAbsolutePath",
    "shortDescription": "check if path is absolute",
    "version": "9.0",
    "synopsis": "result = IsAbsolutePath(p$)",
    "functionDocs": "This function checks if the path specified by `p$` is an absolute path and returns `True` if it is or `False` if it isn't.\n\nNote that this expects the specified path to be in the host's canonical format. Thus, a path like \"/home\" will be absolute on Linux (among others) but not on AmigaOS where \"/home\" just refers to a directory named \"home\" in the parent directory. To convert a path to the host format, you can use [MakeHostPath()](https://www.hollywood-mal.com/docs/html/hollywood/MakeHostPath_.html).",
    "inputsDocs": "* `p$` — path to check",
    "resultsDocs": "* `result` — `True` if path is absolute, `False` otherwise",
    "platforms": ["All"],
    "insertText": "IsAbsolutePath(${1:p$})"
  },
  {
    "name": "IsDirectory",
    "helpId": "IsDirectory",
    "shortDescription": "check for file or directory",
    "version": "2.0",
    "synopsis": "r = IsDirectory(f$)",
    "functionDocs": "This function checks if `f$` is a file or directory. If it is a directory, this function returns `True`, otherwise `False`.",
    "inputsDocs": "* `f$` — file system object",
    "resultsDocs": "* `r` — `True` if `f$` is a directory, `False` otherwise",
    "example": "```\nr = IsDirectory(\"S:\")\n```\n\nThis returns `True`.",
    "platforms": ["All"],
    "insertText": "IsDirectory(${1:f$})"
  },
  {
    "name": "MakeDirectory",
    "helpId": "MakeDirectory",
    "shortDescription": "make a new directory",
    "version": "1.5",
    "synopsis": "MakeDirectory(dir$[, t])",
    "functionDocs": "This function creates the new directory specified by `dir$`. Note that this function won't fail the directory specified by `dir$` already exists.\n\nThis function can also create more than one directory if required. `MakeDirectory()` will scan `dir$` recursively and create every directory that does not exist yet (Hollywood 1.9 and up).\n\nStarting with Hollywood 10.0, this function accepts an optional table argument which supports the following tags:\n\n- `Adapter`: This tag allows you to specify one or more filesystem adapters that should be asked to handle the operation. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to filesystem adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `dir$` — directory to create\n* `t` — optional: table containing further options (see above) (V10.0)",
    "example": "```\nMakeDirectory(\"Test\")\n```\n\nThe code above creates the new directory \"Test\" in the current directory.\n\n---\n\n```\nMakeDirectory(\"A/B/C/D/E\")\n```\n\nThe code above creates five new directories inside the current directory.",
    "platforms": ["All"],
    "insertText": "MakeDirectory(${1:dir$})"
  },
  {
    "name": "MakeHostPath",
    "helpId": "MakeHostPath",
    "shortDescription": "convert Hollywood path to host path format",
    "version": "9.0",
    "synopsis": "p$ = MakeHostPath(path$)",
    "functionDocs": "This function can be used to convert a platform-independent Hollywood path to a path in the host system's canonical path format. The path that should be converted has to be passed in `path$`.\n\nTo ensure cross-platform compatibility, Hollywood paths may contain several constituents that the underlying host operating system doesn't understand. For example, it is possible to use `..` on AmigaOS and compatibles to indicate the parent directory even though AmigaOS doesn't understand this. It's also possible to use normal slashes in paths on Windows even though that operating system normally uses backslashes. Conversely, it's also possible to use backslashes on all other systems although they use slashes, and so on.\n\n`MakeHostPath()` will make sure that the path it returns is fully compliant with the host operating system's requirements. However, you normally don't have to use this function as all Hollywood functions can deal with platform-independent Hollywood paths. It might only be necessary to call this function when passing paths to external programs which don't understand Hollywood's platform-independent path format.",
    "inputsDocs": "* `path$` — path to convert",
    "resultsDocs": "* `p$` — converted path in the host's canonical format",
    "example": "```\nPrint(MakeHostPath(\"../image.jpg\"))\n```\n\nOn AmigaOS, this will print \"/image.jpg\" since AmigaOS doesn't understand the `..` token. On Windows, this will print \"..\\image.jpg\" since Windows uses backslashes instead of slashes. On all other platforms the source string will be returned because no changes are necessary.",
    "platforms": ["All"],
    "insertText": "MakeHostPath(${1:path$})"
  },
  {
    "name": "MatchPattern",
    "helpId": "MatchPattern",
    "shortDescription": "check for a pattern match with a string",
    "version": "2.0",
    "synopsis": "bool = MatchPattern(src$, pattern$)",
    "functionDocs": "This function checks if the string specified in `src$` matches the pattern specified in `pattern$`. If it does, `True` will be returned, else `False`. `MatchPattern()` will compare `pattern$` to `src$` character by character and abort as soon as it finds a difference. If it does not find a difference, it will return `True`.\n\nThe pattern specified in `pattern$` is a string that can contain normal characters and wildcards. A wildcard is a special character that can be used to match more than one character in the source string. The following wildcards are currently supported:\n\n- `*` Matches all characters.\n\n- `?` Matches just a single character.\n\n- `#` Matches all numbers.\n\n- `[]` Matches one or several characters or a range of characters if delimited using a hyphen. For example, [a] matches only `a`, whereas [af] matches `a` and `f` and [a-f] matches all characters in the range of `a` to `f`. You can use the '!' prefix to negate the result, i.e. [!a] matches every character except `a`.\n\nYou can also combine multiple patterns in a single string by separating them using a semicolon.\n\nIf you need more sophisticated pattern matching, have a look at the [PatternFindStr()](https://www.hollywood-mal.com/docs/html/hollywood/PatternFindStr_.html) function. See [PatternFindStr](https://www.hollywood-mal.com/docs/html/hollywood/PatternFindStr_.html).",
    "inputsDocs": "* `src$` — source string\n* `pattern$` — pattern to compare string with",
    "resultsDocs": "* `bool` — `True` if string matches the pattern or `False`",
    "example": "```\nr = MatchPattern(\"Pictures/JPG/Pic1.jpg\", \"*.jpg\")\n```\n\nReturns `True` because the string matches the pattern.\n\n---\n\n```\nr = MatchPattern(\"Pictures/JPG/Pic1.gif\", \"*.jpg;*.gif\")\n```\n\nReturns `True` because the string matches the pattern.\n\n---\n\n```\nr = MatchPattern(\"Hollywood 2.a\", \"Hollywood #.#\")\n```\n\nReturns `False` because `a` does not match the numeric wildcard (#).",
    "platforms": ["All"],
    "insertText": "MatchPattern(${1:src$}, ${2:pattern$})"
  },
  {
    "name": "MD5",
    "helpId": "MD5",
    "shortDescription": "calculate MD5 checksum of file",
    "version": "5.0",
    "synopsis": "sum$ = MD5(f$)",
    "functionDocs": "This function calculates the MD5 checksum of the file specified in `f$` and returns it. The 128-bit checksum is returned as a string containing 16 hex digits.\n\nIf you want to compute the MD5 checksum of a string, use the [MD5Str()](https://www.hollywood-mal.com/docs/html/hollywood/MD5Str_.html) function instead.",
    "inputsDocs": "* `f$` — file whose checksum you want to have calculated",
    "resultsDocs": "* `sum$` — MD5 checksum of file",
    "platforms": ["All"],
    "insertText": "MD5(${1:f$})"
  },
  {
    "name": "MonitorDirectory",
    "helpId": "MonitorDirectory",
    "shortDescription": "monitor changes in a directory",
    "version": "8.0",
    "synopsis": "[id] = MonitorDirectory(id, dir$[, table])",
    "functionDocs": "This function can be used to monitor changes in the directory specified by `dir$`. In order to monitor directory changes, `MonitorDirectory()` will create a new directory object and assign the specified `id` to it. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `MonitorDirectory()` will automatically choose an identifier and return it.\n\nWhenever something in the directory specified by `dir$` changes, `MonitorDirectory()` will send a `DirectoryChanged` event to your script. In order to handle this event, you need to install an event handler for it first using the [InstallEventHandler()](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html) function. See [InstallEventHandler](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html).\n\n`MonitorDirectory()` also accepts an optional table argument which allows you to configure some further options. The following tags are currently recognized by the optional table argument:\n\n- `All`: If this tag is set to `True`, `MonitorDirectory()` will forward all directory change notifications from the operating system to your script. Think twice before using this because, depending on the operating system and file system, you might get several messages for just a single change because of file system internals. By default, `MonitorDirectory()` will try to filter such duplicate notifications for you so that you don't get several messages for just a single change. If you don't want `MonitorDirectory()` to apply this filter, i.e. if you want all notifications, set this tag to `True`. Defaults to `False`.\n\n- `UserData`: This tag can be set to a value of an arbitrary type. `MonitorDirectory()` will store it in the `MonitorUserData` field of the message that is sent by [InstallEventHandler()](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html). This is useful for avoiding global variables.\n\n- `ReportChanges`: If this tag is set to `True`, your event callback will also be notified about what exactly has changed. Your event callback will receive two new parameters: `Type` informing you about the type of change, i.e. whether a file or directory has been added, removed, or changed, and `Name` will contain the name of the file or directory that has been changed. Note that the `All` table tag (see above) will be ignored when setting `ReportChanges` to `True`. (V9.0)\n\nNote that the directory object created by this function must only be used for monitoring directory changes. It is not possible to pass it to other directory functions like [NextDirectoryEntry()](https://www.hollywood-mal.com/docs/html/hollywood/NextDirectoryEntry_.html) or [RewindDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/RewindDirectory_.html). An exception is the [CloseDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/CloseDirectory_.html) function: You should call [CloseDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/CloseDirectory_.html) as soon as you are finished monitoring the directory. This ensures that no resources are wasted and no unnecessary messages are posted to your script.\n\nAlso note that some file systems do not support monitoring of directories. This can happen especially on network volumes or network file systems. In that case, `MonitorDirectory()` can fail.",
    "inputsDocs": "* `id` — id for the directory or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `dir$` — name of the directory to monitor\n* `table` — optional: table containing further parameters (see above)",
    "resultsDocs": "* `id` — optional: identifier of the directory; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "example": "```\nInstallEventHandler({DirectoryChanged = Function(msg)\n        NPrint(msg.action, msg.id, msg.directory)\n    EndFunction})\nMonitorDirectory(1, \"Data\")\nRepeat\n    WaitEvent\nForever\n```\n\nThe code above monitors all changes in the \"Data\" directory and prints a message whenever something changes in that directory.",
    "platforms": ["All"],
    "insertText": "MonitorDirectory(${1:id}, ${2:dir$})"
  },
  {
    "name": "MoveFile",
    "helpId": "MoveFile",
    "shortDescription": "move file or directory",
    "version": "7.1",
    "synopsis": "MoveFile(src$, dst$[, t])",
    "functionDocs": "This function moves the file or directory specified in `src$` to the file or directory specified in `dst$`. Note that `dst$` must not exist or `MoveFile()` will fail. Also, `src$` must not be a volume's root directory because this obviously cannot be moved anywhere.\n\nMoving files (or directories) on the same volume is really quick and takes almost no time. When moving files from one volume to another, `MoveFile()` first has to copy the files and in a second step, delete them from the original volume. This process is much slower than moving files around on the same volume. That is why you can specify a callback function which monitors the progress of this operation.\n\n`MoveFile()` supports several optional arguments. Before Hollywood 9.0, those had to be passed as optional parameters (see above). Since Hollywood 9.0, however, it is recommended to use the new syntax, which has a single optional table argument that can be used to pass one or more optional arguments to `MoveFile()`.\n\nThe following table fields are recognized by this function:\n\n- `Force`: If this tag is set to `True`, write- or delete-protected files will automatically be deleted without asking the callback function first. Note that if there is no callback function and `Force` is set to `False` (the default), `MoveFile()` will just skip all write- or delete-protected files instead of deleting them. Note that `Force` is only used when `MoveFile()` actually needs to delete files, i.e. when moving files from one volume to another. Moving files on the same volume doesn't involve any deleting. Defaults to `False`. (V9.0)\n\n- `BufferSize`: This table field can be used to set the buffer size that should be used when copying files. The value passed here must be specified in bytes. The default is 16384, i.e. 16 kilobytes. Note that `BufferSize` is only used when `MoveFile()` actually needs to copy files, i.e. when moving files from one volume to another. Moving files on the same volume doesn't involve copying. (V9.0)\n\n- `FailOnError`: By default, `MoveFile()` will fail if a file or directory can't be copied or deleted. You can change this behaviour by setting `FailOnError` to `False`. In that case, `MoveFile()` won't fail if a file or directory can't be copied or deleted but instead your callback function, if there is one, will be notified using the `#MOVEFILE_COPYFAILED` and `#MOVEFILE_DELETEFAILED` messages and your callback must tell `MoveFile()` how to proceed (retry, continue, abort). See below to learn how to set up a callback function for `MoveFile()`. Note that `FailOnError` is only used when `MoveFile()` actually needs to copy and delete files, i.e. when moving files from one volume to another. Moving files on the same volume doesn't involve any copying or deleting. `FailOnError` defaults to `True`. (V9.0)\n\n- `Async`: If this is set to `True`, `MoveFile()` will operate in asynchronous mode. This means that it will return immediately, passing an asynchronous operation handle to you. You can then use this asynchronous operation handle to finish the operation by repeatedly calling [ContinueAsyncOperation()](https://www.hollywood-mal.com/docs/html/hollywood/ContinueAsyncOperation_.html) until it returns `True`. This is very useful in case your script needs to do something else while the operation is in progress, e.g. displaying a status animation or something similar. By putting `MoveFile()` into asynchronous mode, it is easily possible for your script to do something else while the operation is being processed. See [ContinueAsyncOperation](https://www.hollywood-mal.com/docs/html/hollywood/ContinueAsyncOperation_.html). Defaults to `False`. (V9.0)\n\n- `Adapter`: This tag allows you to specify one or more filesystem adapters that should be asked to handle the operation. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to filesystem adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\n- `Callback`: For fine-tuned control of the move operation, you can specify a callback function that will be called on various occasions. For example, `MoveFile()` will call it from time to time so that you can update a progress bar. It will also be called when a file is delete-protected to ask you how to proceed. If there is no callback function, `MoveFile()` will silently skip delete-protected files. The callback function receives one argument: A table that contains more information.\n\n  Note that the callback function will only be called when moving files across volumes. Moving files on the same volume can be done instantly and won't result in any callback invocation. Also note that if files are moved across volumes and you do not specify a callback function, files that are delete-protected won't be deleted but will just be copied to the new location without deleting the old file.\n\n  The following callback types are available:\n\n  - `#MOVEFILE_UNPROTECT`: The callback function of type `#MOVEFILE_UNPROTECT` will be called when `MoveFile()` needs to delete a file which is delete-protected. The parameter table for this callback type will contain the following fields:\n\n    - `Action`: `#MOVEFILE_UNPROTECT`\n\n    - `File`: Contains the fully qualified path to the file that is delete-protected.\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n    This callback function needs to return `True` if it is okay to unprotect the file or `False` if it shall not be unprotected. If you return -1, the move operation will be completely aborted.\n\n  - `#MOVEFILE_DELETE`: This callback will be run whenever a file is deleted. The callback function of type `#MOVEFILE_DELETE` should normally return `False`. If it returns `True`, `MoveFile()` will abort the entire operation.\n\n    - `Action`: `#MOVEFILE_DELETE`\n\n    - `File`: Contains the fully qualified path of the file that is to be deleted next.\n\n    - `UserData`: Contains the value you specified in the `UserData` table field (see below).\n\n  - `#MOVEFILE_COPY`: This callback will be called while `MoveFile()` is copying files. The callback function of type `#MOVEFILE_COPY` should normally return `False`. If it returns `True`, `MoveFile()` will abort the entire operation.\n\n    - `Action`: `#MOVEFILE_COPY`\n\n    - `Source`: Contains the fully qualified path of the file that is currently being copied (source).\n\n    - `Destination`: Contains the fully qualified path of the file that is currently being copied (destination).\n\n    - `Copied`: Contains the number of bytes that have already been copied.\n\n    - `Filesize`: Contains the filesize of the source file.\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n  - `#MOVEFILE_DELETEFAILED`: This callback can only be called if the `FailOnError` tag has been set to `False` (see above). In that case, the callback function of type `#MOVEFILE_DELETEFAILED` will be called whenever a delete operation has failed. It has to return `True` to abort the entire operation, `False` to continue even though an error has occurred or -1 to retry the delete operation that has just failed. The following fields will be set in the table parameter that is passed to your callback function:\n\n    - `Action`: `#MOVEFILE_DELETEFAILED`\n\n    - `File`: Contains the fully qualified path of the file that could not be deleted.\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n    (V9.0)\n\n  - `#MOVEFILE_COPYFAILED`: This callback can only be called if the `FailOnError` tag has been set to `False` (see above). In that case, the callback function of type `#MOVEFILE_COPYFAILED` will be called whenever a copy operation has failed. It has to return `True` to abort the entire operation, `False` to continue even though an error has occurred or -1 to retry the copy operation that has just failed. The following fields will be set in the table parameter that is passed to your callback function:\n\n    - `Action`: `#MOVEFILE_COPYFAILED`\n\n    - `Source`: Contains the fully qualified path of the file that is currently being copied (source).\n\n    - `Destination`: Contains the fully qualified path of the file that is currently being written (destination).\n\n    - `UserData`: Contains the value you passed in the `UserData` table field (see below).\n\n    (V9.0)\n\n- `UserData`: This field can be used to pass an arbitrary value to your callback function. The value you specify here will be passed to your callback function whenever it is called. This is useful if you want to avoid working with global variables. Using the `UserData` tag you can easily pass data to your callback function. You can specify a value of any type in `UserData`. Numbers, strings, tables, and even functions can be passed as user data. Your callback will receive this data in the `UserData` field in the table that is passed to it.",
    "inputsDocs": "* `src$` — source file or directory to move\n* `dst$` — destination file or directory; must not exist\n* `t` — optional: table containing additional options (see above) (V9.0)",
    "example": "```\nMoveFile(\"image.png\", \"images/image.png\")\n```\n\nMoves the file \"image.png\" to the subdirectory \"images\" while keeping its name.",
    "platforms": ["All"],
    "insertText": "MoveFile(${1:src$}, ${2:dst$})"
  },
  {
    "name": "NextDirectoryEntry",
    "helpId": "NextDirectoryEntry",
    "shortDescription": "get next entry from an open directory",
    "version": "4.0",
    "synopsis": "t = NextDirectoryEntry(id)",
    "functionDocs": "This function gets the next entry from a directory previously opened using [OpenDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/OpenDirectory_.html) or [@DIRECTORY](https://www.hollywood-mal.com/docs/html/hollywood/atDIRECTORY_.html). The function will return a table that contains detailed information about the entry just retrieved. If there are no more entries in the specified directory, this function will return [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html). Normally, this function is called in a loop until it returns `Nil`. That way you can scan the whole contents of a directory.\n\nThe table that is returned by this function will have the following fields initialized:\n\n\n- `Name`: This field will contain the name of entry.\n\n- `Type`: This will be `#DOSTYPE_FILE` if the entry is a file or `#DOSTYPE_DIRECTORY` if the entry is a directory.\n\n- `Size`: This field will only be present if the entry is a file. In that case, this field will receive the size of the file in bytes.\n\n- `Flags`: This field will receive a combination of protection flags of the file or directory. See [Protection flags](https://www.hollywood-mal.com/docs/html/hollywood/ProtFlagsInfo_.html).\n\n- `Time`: This field will receive a string containing the time the file or directory was last modified. The string will always be in the format dd-mmm-yyyy hh:mm:ss. E.g.: 08-Nov-2004 14:32:13.\n\n- `LastAccessTime`: This field will receive a string containing the time the file or directory was last accessed. This attribute is not supported on AmigaOS.\n\n- `CreationTime`: This field will receive a string containing the time the file or directory was created. This attribute is only supported on Windows.\n\n- `Comment`: This field will contain the comment of a file. This is only supported by the Amiga versions.\n\nTo rewind a directory iteration, use the [RewindDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/RewindDirectory_.html) function. See [RewindDirectory](https://www.hollywood-mal.com/docs/html/hollywood/RewindDirectory_.html).",
    "inputsDocs": "* `id` — identifier of the directory to query",
    "resultsDocs": "* `t` — a table initialized as shown above",
    "example": "See [OpenDirectory](https://www.hollywood-mal.com/docs/html/hollywood/OpenDirectory_.html)",
    "platforms": ["All"],
    "insertText": "NextDirectoryEntry(${1:id})"
  },
  {
    "name": "OpenDirectory",
    "helpId": "OpenDirectory",
    "shortDescription": "open a directory for examination",
    "version": "4.0",
    "synopsis": "[id] = OpenDirectory(id, dir$[, table])",
    "functionDocs": "This function opens the directory specified in `dir$` and assigns the specified `id` to it. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `OpenDirectory()` will automatically choose an identifier and return it. The directory can then subsequently be examined by using the [NextDirectoryEntry()](https://www.hollywood-mal.com/docs/html/hollywood/NextDirectoryEntry_.html) function which gives you low-level access to the directory which is especially useful for large directories or if you need additional information like sizes/attributes for the individual directory entries. You can get these very fast using a loop as presented in the example below.\n\nStarting with Hollywood 6.0 this function accepts an optional table argument which can be used to pass additional parameters. The following table elements are currently recognized:\n\n- `Adapter`: This tag allows you to specify one or more directory adapters that should be asked to open the specified directory. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to directory adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\nYou should call [CloseDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/CloseDirectory_.html) as soon as you are finished with the directory. This ensures that the directory does not stay locked by the file system longer than needed.\n\nThis command is also available from the preprocessor: Use [@DIRECTORY](https://www.hollywood-mal.com/docs/html/hollywood/atDIRECTORY_.html) to link whole directories to your applet or executable.",
    "inputsDocs": "* `id` — id for the directory or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `dir$` — name of the directory to open\n* `table` — optional: table containing further parameters (V6.0)",
    "resultsDocs": "* `id` — optional: identifier of the directory; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "example": "```\nOpenDirectory(1, \"Data\")\ne = NextDirectoryEntry(1)\nWhile e <> Nil\n  NPrint(IIf(e.type = #DOSTYPE_FILE, \"File:\", \"Directory:\"), e.name)\n  e = NextDirectoryEntry(1)\nWend\nCloseDirectory(1)\n```\n\nThe code above opens directory \"Data\" and prints all files and directories present in that directory.",
    "platforms": ["All"],
    "insertText": "OpenDirectory(${1:id}, ${2:dir$})"
  },
  {
    "name": "OpenFile",
    "helpId": "OpenFile",
    "shortDescription": "open a file for reading and writing",
    "version": "1.0",
    "synopsis": "[id] = OpenFile(id, filename$[, mode, table])",
    "functionDocs": "This function attempts to open the file specified by `filename$` and assigns `id` to it. If you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id`, `OpenFile()` will automatically choose an identifier and return it. If the file does not exist, this function will fail unless you use the `mode` argument to open a file for writing. In that case, `OpenFile()` will create the file for you.\n\nAll read and write operations will start at the current file cursor position. You can manually set the file cursor by using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) function but it is also increased if you use other functions which read from or write to the file.\n\nStarting with Hollywood 2.0 you can use the optional argument `mode` to open the file in read (default) or write mode or in shared mode, which means that you can read from the file and you can also write to it. If a file is opened in read mode, all write operations will fail. If a file is opened in write mode, all read operations will fail.\n\nStarting with Hollywood 6.0 this function accepts an optional table argument which can be used to pass additional parameters. The following table elements are currently recognized:\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked to open the specified file. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V6.0)\n\n- `Encoding`: In case the file is a text file, you can set this tag to the charset used by the file. Hollywood will then handle charset conversions automatically when reading from or writing to the file using functions like [ReadLine()](https://www.hollywood-mal.com/docs/html/hollywood/ReadLine_.html), [ReadString()](https://www.hollywood-mal.com/docs/html/hollywood/ReadString_.html), [WriteLine()](https://www.hollywood-mal.com/docs/html/hollywood/WriteLine_.html) or [WriteString()](https://www.hollywood-mal.com/docs/html/hollywood/WriteString_.html). By default, Hollywood expects text files to be in the UTF-8 charset because that's Hollywood's default charset. If you want to read from or write to a file using the ISO 8859-1 encoding instead, just set `Encoding` to `#ENCODING_ISO8859_1` and Hollywood will handle all conversions to and from ISO 8859-1 automatically. See [SetDefaultEncoding](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultEncoding_.html). (V9.0)\n\n- `WriteBOM`: Set this tag to `True` if you want `OpenFile()` to add the UTF-8 BOM (byte order mark) to the beginning of the file. Obviously, `OpenFile()` will only do this if the file has been opened in write mode (`#MODE_WRITE`) and the file's encoding has been set to `#ENCODING_UTF8`. (V9.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to file adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)\n\nAlthough Hollywood will automatically close all open files when it quits, it is strongly advised that you close an open file when you are done with it using the [CloseFile()](https://www.hollywood-mal.com/docs/html/hollywood/CloseFile_.html) function so that it becomes available to the operating system again.\n\nStarting with Hollywood 9.0, `filename$` may also be one of the special constants `#STDIN`, `#STDOUT`, and `#STDERR`. This is useful for advanced programmers who want to access the `stdin`, `stdout`, and `stderr` file streams associated with each program.\n\nThis command is also available from the preprocessor: Use [@FILE](https://www.hollywood-mal.com/docs/html/hollywood/atFILE_.html) to preopen files.",
    "inputsDocs": "* `id` — identifier of the file or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `filename$` — name of the file to open\n* `mode` — mode to open the file; can be `#MODE_READ`, `#MODE_WRITE` or `#MODE_READWRITE` (defaults to `#MODE_READ`) (V2.0)\n* `table` — optional: table containing further parameters (V6.0)",
    "resultsDocs": "* `id` — optional: identifier of the file; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "example": "```\nOpenFile(1, \"Highscores.txt\")\nWhile Not Eof(1) Do NPrint(ReadLine(1))\nCloseFile(1)\n```\n\nThis code opens the file \"Highscores.txt\" as file 1 and prints all of its lines to the screen.",
    "platforms": ["All"],
    "insertText": "OpenFile(${1:id}, ${2:filename$})"
  },
  {
    "name": "PathPart",
    "helpId": "PathPart",
    "shortDescription": "return the path component of a path",
    "version": "1.0",
    "synopsis": "p$ = PathPart(path$)",
    "functionDocs": "This function extracts the pathname from a path specified by `path$` and returns it. The returned path part will always end with a \"/\" or a \":\" so that you can immediately add a filename to it.",
    "inputsDocs": "* `path$` — source path",
    "resultsDocs": "* `p$` — path part",
    "example": "```\np$ = PathPart(\"Data/Gfx/Test.jpg\")\nPrint(p$)\n```\n\nThe above code prints \"Data/Gfx\" to the screen.",
    "platforms": ["All"],
    "insertText": "PathPart(${1:path$})"
  },
  {
    "name": "ReadByte",
    "helpId": "ReadByte",
    "shortDescription": "read byte from file",
    "version": "7.0",
    "synopsis": "b = ReadByte(id[, flags])",
    "functionDocs": "This function reads a single byte from the file specified by `id` and returns it. Reading starts from the current file cursor position which you can modify using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. After reading, `ReadByte()` will advance the file cursor by one byte.\n\nThe `flags` parameter may be set to one of the following flags:\n\n- `#IO_UNSIGNED`: The return value will be unsigned and will range from 0 to 255. This is the default.\n\n- `#IO_SIGNED`: The return value will be signed and will range from -128 to 127.",
    "inputsDocs": "* `id` — file to read data from\n* `flags` — optional: additional flags (see above) (defaults to `#IO_UNSIGNED`) (V9.0)",
    "resultsDocs": "* `b` — byte read from file",
    "platforms": ["All"],
    "insertText": "ReadByte(${1:id})"
  },
  {
    "name": "ReadBytes",
    "helpId": "ReadBytes",
    "shortDescription": "read bytes from file",
    "version": "7.0",
    "synopsis": "data$ = ReadBytes(id[, len])",
    "functionDocs": "This function reads `len` bytes from the file specified by `id`. If the `len` argument is omitted, `ReadBytes()` will read all bytes from the current file cursor position until the file end. `ReadBytes()` will advance the file cursor position by the number of bytes read.\n\nThis function is useful for reading binary data from a file. Since Hollywood strings can store binary data as well as text, `ReadBytes()` can just copy all the bytes it has read from the file in a Hollywood string and return it.",
    "inputsDocs": "* `id` — file to read data from\n* `len` — optional: number of bytes to read (defaults to 0 which means read until file end)",
    "resultsDocs": "* `data$` — data read from file",
    "example": "See [WriteBytes](https://www.hollywood-mal.com/docs/html/hollywood/WriteBytes_.html)",
    "platforms": ["All"],
    "insertText": "ReadBytes(${1:id})"
  },
  {
    "name": "ReadChr",
    "helpId": "ReadChr",
    "shortDescription": "read a character from the specified file",
    "version": "1.0",
    "synopsis": "chr = ReadChr(id[, encoding])",
    "functionDocs": "This reads a single character from the file specified by `id` and returns its code point value. Note that depending on the character encoding, this might read up to 4 bytes from the file since in UTF-8, characters can use up to 4 bytes. The file cursor position is incremented by the number of bytes read.\n\nThe optional `encoding` parameter can be used to set the character encoding to use. This defaults to the default string encoding set using [SetDefaultEncoding()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultEncoding_.html). See [Character encodings](https://www.hollywood-mal.com/docs/html/hollywood/CharacterEncoding_.html).\n\nIf you want to read a single byte from a file, use [ReadByte()](https://www.hollywood-mal.com/docs/html/hollywood/ReadByte_.html) instead. See [ReadByte](https://www.hollywood-mal.com/docs/html/hollywood/ReadByte_.html).",
    "inputsDocs": "* `id` — identifier of file to use\n* `encoding` — optional: character encoding to use (defaults to default string encoding) (V7.0)",
    "resultsDocs": "* `chr` — next character from file stream",
    "example": "```\nOpenFile(1, \"test\", #MODE_READWRITE)\nWriteLine(1, \"Hello People! How are you?\")\nSeek(1, 0)\ntest = ReadChr(1)\nCloseFile(1)\ntest$ = Chr(test)\nPrint(test$)\n```\n\nThe above code will print \"H\" to the screen.",
    "platforms": ["All"],
    "insertText": "ReadChr(${1:id})"
  },
  {
    "name": "ReadDirectory",
    "helpId": "ReadDirectory",
    "shortDescription": "read a directory into a string array",
    "version": "1.0",
    "synopsis": "fcount, dcount = ReadDirectory(dir$, files$, dirs$[, sort])",
    "functionDocs": "This function examines the directory specified by `dir$` and puts all filenames found in the directory tree to the string array specified in `files$` and all directory names to the string array specified in `dirs$`. After the last item, this function will insert an empty string into the array, so you know how many files/directories were found.\n\nBy default, all file and directory entries will be automatically sorted by this function. If you do not want this behaviour, you can set the optional argument `sort` to `False`.\n\nStarting with Hollywood 2.0 this function returns two values: The first return value indicates how many files were in the directory and the second one indicates how many subdirectories were in the directory.",
    "inputsDocs": "* `dir$` — directory to examine\n* `files$` — string array to put the filenames to\n* `dirs$` — string array to put the directory names to\n* `sort` — optional: whether or not file and directory names shall be sorted (V4.5)",
    "resultsDocs": "* `fcount` — number of files in `dir$` (V2.0)\n* `dcount` — number of subdirectories in `dir$` (V2.0)",
    "example": "```\nf$ = {}\nd$ = {}\nReadDirectory(\"Data\", f$, d$)\n```\n\nThe above code reads the contents of the \"Data\" directory into the string arrays `f$` and `d$`.",
    "platforms": ["All"],
    "insertText": "ReadDirectory(${1:dir$}, ${2:files$}, ${3:dirs$})"
  },
  {
    "name": "ReadFloat",
    "helpId": "ReadFloat",
    "shortDescription": "read a float from a file",
    "version": "2.0",
    "synopsis": "float = ReadFloat(id[, width, le])",
    "functionDocs": "This function reads a signed float value from the file specified by `id` and returns it. Reading starts from the current file cursor position which you can modify using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. A float value takes up 8 bytes which is enough to store really big integers and floats with many decimal places.\n\nStarting with Hollywood 6.0 there is an optional argument which allows you to specify the byte width of the floating point number. This can be 8 for a double-precision floating point number or 4 for a single-precision floating point number. By default, `ReadFloat()` reads double-precision floats.\n\nBy default, this function expects the data to be stored in big endian format (most significant byte first). Starting with Hollywood 6.0 you can use the optional argument `le` to explicitly request this function to use the little endian format instead.",
    "inputsDocs": "* `id` — file to read data from\n* `width` — optional: byte width of the float (defaults to 8) (V6.0)\n* `le` — optional: `True` to read bytes in little endian order, `False` for big endian order (defaults to `False`) (V6.0)",
    "resultsDocs": "* `float` — float value",
    "platforms": ["All"],
    "insertText": "ReadFloat(${1:id})"
  },
  {
    "name": "ReadFunction",
    "helpId": "ReadFunction",
    "shortDescription": "read a function from a file",
    "version": "4.0",
    "synopsis": "func = ReadFunction(id)",
    "functionDocs": "This function reads a Hollywood function from the file specified by `id` and returns it. Reading starts from the current file cursor position which you can modify using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command.\n\nThe function must have been written to the file by the [WriteFunction()](https://www.hollywood-mal.com/docs/html/hollywood/WriteFunction_.html) command.",
    "inputsDocs": "* `id` — file to read from",
    "resultsDocs": "* `func` — the function read from the file",
    "example": "See [WriteFunction](https://www.hollywood-mal.com/docs/html/hollywood/WriteFunction_.html)",
    "platforms": ["All"],
    "insertText": "ReadFunction(${1:id})"
  },
  {
    "name": "ReadInt",
    "helpId": "ReadInt",
    "shortDescription": "read an integer from a file",
    "version": "2.0",
    "synopsis": "int = ReadInt(id[, flags])",
    "functionDocs": "This function reads an integer from the file specified by `id` and returns it. Reading starts from the current file cursor position which you can modify using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. By default, `ReadInt()` will read a 32-bit integer, advancing the file cursor by 4 bytes.\n\nThe `flags` parameter may be a combination of the following flags:\n\n- `#IO_SIGNED`: The return value will be signed and will range from -2147483648 to 2147483647 (if `#IO_FAKE64` isn't set). This is the default.\n\n- `#IO_UNSIGNED`: The return value will be unsigned and will range from 0 to 4294967295. This cannot be combined with `#IO_FAKE64`.\n\n- `#IO_LITTLEENDIAN`: By default, this function expects the data to be stored in big endian format (most significant byte first). You can set this flag to request this function to use the little endian format instead.\n\n- `#IO_FAKE64`: Use 64-bit integers. This is called \"fake 64\" because Hollywood can't use the full 64-bit integer range because its numeric type is a 64-bit floating point value which can't represent exactly the same range as a true 64-bit integer value. Still, Hollywood's fake 64-bit integers should be large enough for almost anything. Using `#IO_FAKE64` you can read integers in the range of -9007199254740992 to 9007199254740992. Note that `#IO_UNSIGNED` can't be used with `#IO_FAKE64`. Hollywood's fake 64-bit integers will always be signed. (V9.0)",
    "inputsDocs": "* `id` — file to read data from\n* `flags` — optional: additional flags (see above) (defaults to `#IO_SIGNED`) (V9.0)",
    "resultsDocs": "* `int` — integer value",
    "platforms": ["All"],
    "insertText": "ReadInt(${1:id})"
  },
  {
    "name": "ReadLine",
    "helpId": "ReadLine",
    "shortDescription": "read a line from the specified file",
    "version": "1.0",
    "synopsis": "string$ = ReadLine(id[, lf])",
    "functionDocs": "This command reads characters from the file specified by `id` until a line feed character occurs. Neither line feed nor carriage return characters are included in the destination string. This function also terminates when it reaches the end-of-file mark. The string read is returned.\n\nStarting with Hollywood 9.0, there is an optional `lf` argument. If this is set to `True`, `ReadLine()` will also include newline characters (i.e. line feed and carriage return) if present in the source file. Note that no platform adaptation will take place in that case. If `lf` is set to `True`, ReadString() will return the exact newline characters that are in the source file, i.e. you might get line feed, carriage return and line feed or just carriage return, depending on the file's contents.",
    "inputsDocs": "* `id` — identifier an open file\n* `lf` — optional: whether or not to include newline characters in the string (defaults to `False`) (V9.0)",
    "resultsDocs": "* `string$` — receives the line read",
    "example": "See [OpenFile](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html)",
    "platforms": ["All"],
    "insertText": "ReadLine(${1:id})"
  },
  {
    "name": "ReadShort",
    "helpId": "ReadShort",
    "shortDescription": "read 16-bit integer from a file",
    "version": "2.0",
    "synopsis": "short = ReadShort(id[, flags])",
    "functionDocs": "This function reads a 16-bit integer from the file specified by `id` and returns it. Reading starts from the current file cursor position which you can modify using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. Since `ReadShort()` reads a 16-bit integer from the file, the file cursor will be advanced by 2 bytes.\n\nThe `flags` parameter may be a combination of the following flags:\n\n- `#IO_UNSIGNED`: The return value will be unsigned and will range from 0 to 65535. This is the default.\n\n- `#IO_SIGNED`: The return value will be signed and will range from -32768 to 32767.\n\n- `#IO_LITTLEENDIAN`: By default, this function expects the data to be stored in big endian format (most significant byte first). You can set this flag to request this function to use the little endian format instead.",
    "inputsDocs": "* `id` — file to read data from\n* `flags` — optional: additional flags (see above) (defaults to `#IO_UNSIGNED`) (V9.0)",
    "resultsDocs": "* `short` — short value read from file",
    "platforms": ["All"],
    "insertText": "ReadShort(${1:id})"
  },
  {
    "name": "ReadString",
    "helpId": "ReadString",
    "shortDescription": "read string from file",
    "version": "1.0",
    "synopsis": "s$ = ReadString(id[, length, encoding])",
    "functionDocs": "This function reads a string from the file specified by `id`. The optional `length` argument allows you to specify the number of characters to read from the file. If it is omitted, all characters from the current file cursor position until the end will be read and returned. The file cursor will be advanced by the number of bytes read from the file. This is not necessarily the same as the character count passed in `length` because in UTF-8 a single character may use up to 4 bytes.\n\nThe optional `encoding` parameter can be used to set the character encoding to use. This defaults to the default string encoding set using [SetDefaultEncoding()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultEncoding_.html). See [Character encodings](https://www.hollywood-mal.com/docs/html/hollywood/CharacterEncoding_.html).\n\nThis function is used for reading text from files. If you need to read binary data from a file, use the [ReadBytes()](https://www.hollywood-mal.com/docs/html/hollywood/ReadBytes_.html) function instead. See [ReadBytes](https://www.hollywood-mal.com/docs/html/hollywood/ReadBytes_.html).",
    "inputsDocs": "* `id` — file to read data from\n* `length` — optional: characters to read or 0 to read all characters until the end of the file (defaults to 0)\n* `encoding` — optional: character encoding to use (defaults to default string encoding) (V7.0)",
    "resultsDocs": "* `s$` — string that contains the characters read",
    "platforms": ["All"],
    "insertText": "ReadString(${1:id})"
  },
  {
    "name": "Rename",
    "helpId": "Rename",
    "shortDescription": "rename a file or directory",
    "version": "2.0",
    "synopsis": "Rename(oldname$, newname$[, t])",
    "functionDocs": "This function renames a file or a directory. `oldname$` is the name of the file or directory to be renamed and can include a path specification. `newname$` is just the desired new name for the file/directory and must not contain any path specification.\n\nStarting with Hollywood 10.0, this function accepts an optional table argument which supports the following tags:\n\n- `Adapter`: This tag allows you to specify one or more filesystem adapters that should be asked to handle the operation. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to filesystem adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `oldname$` — file or directory to rename\n* `newname$` — new name for the file/directory\n* `t` — optional: table argument containing further options (see above) (V10.0)",
    "example": "```\nRename(\"image1.png\", \"image2.png\")\n```\n\nRenames the file \"image1.png\" to \"image2.png\".",
    "platforms": ["All"],
    "insertText": "Rename(${1:oldname$}, ${2:newname$})"
  },
  {
    "name": "RewindDirectory",
    "helpId": "RewindDirectory",
    "shortDescription": "rewind directory iteration",
    "version": "8.0",
    "synopsis": "RewindDirectory(id)",
    "functionDocs": "This function can be used to rewind the iteration of a directory opened by the [OpenDirectory()](https://www.hollywood-mal.com/docs/html/hollywood/OpenDirectory_.html) function or the [@DIRECTORY](https://www.hollywood-mal.com/docs/html/hollywood/atDIRECTORY_.html) preprocessor command. This directory must be passed to `RewindDirectory()` in the `id` argument and the iteration must have been started using the [NextDirectoryEntry()](https://www.hollywood-mal.com/docs/html/hollywood/NextDirectoryEntry_.html) function before. After this function returns, a call to [NextDirectoryEntry()](https://www.hollywood-mal.com/docs/html/hollywood/NextDirectoryEntry_.html) will return the first entry in the directory again.\n\nSee [NextDirectoryEntry](https://www.hollywood-mal.com/docs/html/hollywood/NextDirectoryEntry_.html).",
    "inputsDocs": "* `id` — identifier of the directory to rewind",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "RewindDirectory(${1:id})"
  },
  {
    "name": "Run",
    "helpId": "Run",
    "shortDescription": "asynchronously execute a program",
    "version": "1.0",
    "synopsis": "Run(file$[, args$, t])",
    "functionDocs": "This function executes the program specified by `file$` asynchronously and passes the arguments specified in `args$` to it. If you need to execute a program synchronously, you have to use the [Execute()](https://www.hollywood-mal.com/docs/html/hollywood/Execute_.html) function. See [Execute](https://www.hollywood-mal.com/docs/html/hollywood/Execute_.html).\n\nIf supported by the operating system, this command can also be used to view data files like documents or images using their default viewer. In that case, `file$` can also be a non-executable file like a JPEG image or an MP3 file.\n\nOn Android `file$` has to be either a data file like a JPEG image or a package name like `com.airsoftsoftwair.hollywood` if you want this function to start another app.\n\nIf you want to be informed when the program started using `Run()` is terminated, you can install a listener for the `RunFinished` event handler using [InstallEventHandler()](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html). See [InstallEventHandler](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html).\n\nThere is also a listener called `RunOutput` which can be installed using [InstallEventHandler()](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html). The `RunOutput` listener will redirect the program's output to your program which is useful when writing GUIs for console programs, for example. See [InstallEventHandler](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html).\n\nNote that due to historical reasons, there are some pitfalls when using this function. Before Hollywood 9.0 this command expected program and arguments combined in just a single `cmdline$` string. In that case, extra care has to be taken when dealing with spaces (see below for details). Starting with Hollywood 9.0, there is a new syntax which allows you to pass program and arguments as two separate arguments which makes things much easier. However, to maintain compatibility with previous versions this new syntax can only be used if you explicitly pass a string in the second argument. So if you want to use the new syntax, make sure to pass a string in the second argument. If the program you want to start doesn't need any arguments, just pass an empty string (\"\") just to signal Hollywood that you want to use the new syntax.\n\nIf you don't pass a string in the second argument, the old syntax will be used which means that you need to be very careful when passing program paths that contain spaces since the very first space in `cmdline$` is interpreted as the separator of program and arguments. If you want to start a program whose path specification uses spaces, you need to use double quotes around this path specification or it won't work. You can easily avoid these complications by simply passing a string in the second argument, even if it is empty (see above for details).\n\nStarting with Hollywood 9.0, it is possible to specify the program and its arguments in two separate arguments, which makes things much more convenient. Also, there is a new optional table argument now that can be used to specify further options.\n\nThe following options are currently supported by the optional table argument:\n\n- `Directory`: This table argument allows you to set the current directory for the program that is to be started. (V9.0)\n\n- `ResetKeys`: This table argument is only interesting for advanced users. If this is set to `False`, `Run()` won't reset all internal key states after executing the program. By default, all key states will be reset when `Run()` returns because programs started using `Run()` often assume the keyboard focus and Hollywood might be unable to reset its internal state flags because the new program started via `Run()` takes over keyboard focus. That's why by default `Run()` will reset all internal key state flags when it returns. Disabling this behaviour can make sense if you use `Run()` to start programs that don't have a GUI and don't take away the keyboard focus. Defaults to `True`. (V5.1)\n\n- `RawMode`: This tag is only used when the `RunOutput` event handler is active. By default, the `RunOutput` event handler expects programs to output text only. This is why `RunOutput` will make sure to pass only properly UTF-8 encoded text to your callback function. If you don't want `RunOutput` to format the text as UTF-8, you need to set the `RawMode` argument to `True` when calling `Run()`. In that case, `RunOutput` won't do any preformatting and will just forward the program's raw output to you. This means that your event handler callback has to be ready to process binary data as well. Defaults to `False`. (V9.0)\n\n- `IgnoreHandlers`: If event handlers for `RunFinished` or `RunOutput` are installed, those handlers will automatically trigger whenever `Run()` is called. If you only want those event handlers to trigger for certain calls to `Run()`, you can use this tag to tell `Run()` which event handlers to ignore. This must be set to a string containing the event handlers that should be ignored. Multiple event handlers must be separated by a vertical bar character. For example, setting `IgnoreHandlers` to `RunFinished|RunOutput` would tell `Run()` to not throw events for both event handlers, `RunFinished` and `RunOutput`. (V9.0)\n\n- `ReturnCode`: If you have a `RunFinished` event handler installed, you can set this tag to `True` to indicate that your event handler should also receive the program's return code when it terminates. Note that when setting this tag to `True` on AmigaOS 4 and MorphOS, Hollywood can't be quit before the program started using `Run()` has terminated. Defaults to `False`. (V9.0)\n\n- `ForceExe`: If this tag is set to `True`, `Run()` will always treat the file passed in `file$` as an executable. This is only useful on Linux and macOS because on those platforms files that have an extension will be treated as data files so Hollywood will try to launch the corresponding viewer for the data file instead. Thus, trying to use `Run()` on an executable named \"test.exe\" will not work on Linux and macOS because of the *.exe extension. By setting `ForceExe` to `True`, however, you can make it work. Defaults to `False`. (V9.0)\n\n- `UserData`: This argument can be used to specify user data that should be passed to the `RunFinished` and `RunOutput` event handlers that can be installed via [InstallEventHandler()](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html). See [InstallEventHandler](https://www.hollywood-mal.com/docs/html/hollywood/InstallEventHandler_.html). The user data you specify here can be of any type. (V6.1)\n\n- `Verb`: On Windows, this can be set to a string telling `Run()` what to do with the file. This can be one of the following verbs:\n\n  - `edit` Opens the specified file in an editor.\n\n  - `explore` Opens the specified folder in Explorer. When using this verb, you must pass a folder instead of a file to `Run()`.\n\n  - `find` Opens the search dialog for the specified folder. When using this verb, you must pass a folder instead of a file to `Run()`.\n\n  - `open` Opens the specified file.\n\n  - `print` Prints the specified file.\n\n  - `runas` Launches the specified file in administrator mode.\n\n  Note that the `Verb` tag is only supported on Windows. (V9.1)",
    "inputsDocs": "* `file$` — the program (or data file) to be started\n* `args$` — optional: arguments to pass to the program; note that you must pass this parameter to signal Hollywood to use the new syntax; you can do so by just passing an empty string (\"\"); see above for a detailed discussion (V9.0)\n* `t` — optional: table containing further arguments (see above) (V9.0)",
    "example": "```\nRun(\"Sys:Prefs/Locale\")\n```\n\nThe above code executes the locale preferences on AmigaOS based systems. Your script's execution will go on immediately after executing the locale program (asynchronous execution).\n\n---\n\n```\nRun(\"\\\"C:\\\\Program Files (x86)\\\\Hollywood\\\\ide.exe\\\"\")\n```\n\nThe code above runs the Hollywood IDE on Windows systems. Note that we've embedded the program specification inside double quotes. This is absolutely necessary because the first space in the string passed to `Run()` is normally interpreted as the separator between program and arguments. If we didn't use double quotes in the code above, `Run()` would try to start the program \"C:\\Program\" and pass the arguments \"Files (x86)\\Hollywood\\ide.exe\" to it which we obviously don't want. Note that since Hollywood 9.0, it is now much easier to deal with spaces in paths. You just need to use the new syntax which takes the program and its arguments in two separate arguments. With Hollywood 9.0, you could simply use this code:\n\n---\n\n```\nRun(\"C:\\\\Program Files (x86)\\\\Hollywood\\\\ide.exe\", \"\")\n```\n\nNote that passing the empty string in the second argument is absolutely necessary here to signal Hollywood that you want to use the new syntax. See above for a detailed discussion on this.",
    "platforms": ["All"],
    "insertText": "Run(${1:file$})"
  },
  {
    "name": "Seek",
    "helpId": "Seek",
    "shortDescription": "set file cursor to a new position",
    "version": "1.0",
    "synopsis": "Seek(id, newpos[, mode])",
    "functionDocs": "This function sets the file cursor (from which all read/write operations start) to `newpos`. The beginning of the file is at position 0. If you want to seek to the end-of-file, set `newpos` to the special constant `#EOF`.\n\nTo find out the cursor position of a specific file, you can use the [FilePos()](https://www.hollywood-mal.com/docs/html/hollywood/FilePos_.html) command.\n\nStarting with Hollywood 6.0 you can use the optional `mode` argument to set the seek mode which should be used. This can be one of the following mode constants:\n\n- `#SEEK_BEGINNING`: The specified seeking position is relative to the beginning of the file. Negative positions are not allowed. This is the default seek mode.\n\n- `#SEEK_CURRENT`: The specified seeking position is relative to the current position of the file cursor. You may also pass negative positions here to seek backwards from the current file cursor position.\n\n- `#SEEK_END`: The specified seeking position is relative to the file's ending. You may only pass 0 or negative positions here. To seek to the end of the file, simply pass 0.",
    "inputsDocs": "* `id` — number specifying the file to use\n* `newpos` — position to set the file cursor to\n* `mode` — optional: seek mode to use (defaults to `#SEEK_BEGINNING`) (V6.0)",
    "example": "See [ReadChr](https://www.hollywood-mal.com/docs/html/hollywood/ReadChr_.html)",
    "platforms": ["All"],
    "insertText": "Seek(${1:id}, ${2:newpos})"
  },
  {
    "name": "SetEnv",
    "helpId": "SetEnv",
    "shortDescription": "write environment variable",
    "version": "5.0",
    "synopsis": "SetEnv(var$, s$)",
    "functionDocs": "This command can be used to set the environment variable specified in `var$` to the value specified in `s$`. Please note that the environment variable will be local to your Hollywood script. You cannot modify global environment variables with this function.",
    "inputsDocs": "* `var$` — environment variable to set\n* `s$` — desired value for environment variable",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "SetEnv(${1:var$}, ${2:s$})"
  },
  {
    "name": "SetFileAttributes",
    "helpId": "SetFileAttributes",
    "shortDescription": "set attributes of a file or directory",
    "version": "3.0",
    "synopsis": "SetFileAttributes(f$, t)",
    "functionDocs": "This function can be used to change one or multiple attributes of a file or directory. This includes information such as the file time, protection flags, and more, depending on the host file system.\n\nThe file (or directory) whose attributes you want to change must be passed as parameter `f$`. The second parameter is a table which contains all attributes you want to modify. The following fields can be set in the table:\n\n\n- `Flags`: Use this field to change the protection flags of the file or directory. Set this field to a combination of protection flags or to `#FILEATTR_NORMAL` to reset all protection flags. See [Protection flags](https://www.hollywood-mal.com/docs/html/hollywood/ProtFlagsInfo_.html).\n\n- `Time`: Use this field to change the time stamp of the file or directory. This field can be used to change the time when the file was last changed. You need to set this field to a string in the format dd-mmm-yyyy hh:mm:ss. E.g.: 08-Nov-2004 14:32:13.\n\n- `LastAccessTime`: Use this field to modify the time the file or directory was last accessed. The string you specify here must be in the format dd-mmm-yyyy hh:mm:ss. This attribute is not supported on AmigaOS.\n\n- `CreationTime`: Use this field to modify the creation time of the file or directory. The string you specify here must be in the format dd-mmm-yyyy hh:mm:ss. This attributed is only supported on Windows.\n\n- `Comment`: Use this field to change the comment of a file. This is only supported by the Amiga versions.\n\n- `Adapter`: This tag allows you to specify one or more filesystem adapters that should be asked to handle the operation. This must be set to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to filesystem adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `f$` — name of file or directory whose attributes are to be changed\n* `t` — a table containing the attributes to be set",
    "example": "```\nt = {}\nt.time = \"15-Dec-2006 23:30:12\"\nt.flags = #FILEATTR_READ_USR | #FILEATTR_WRITE_USR\nSetFileAttributes(\"test.txt\", t)\n```\n\nThe code above sets the time stamp of file \"test.txt\" to December 15th, 2006 at 11:30pm and 12 seconds. Additionally it sets the protection flags `#FILEATTR_READ_USR` and `#FILEATTR_WRITE_USR`.",
    "platforms": ["All"],
    "insertText": "SetFileAttributes(${1:f$}, ${2:t})"
  },
  {
    "name": "SetFileEncoding",
    "helpId": "SetFileEncoding",
    "shortDescription": "set file charset",
    "version": "9.0",
    "synopsis": "SetFileEncoding(id, encoding)",
    "functionDocs": "This function changes the charset used by the file specified by `id` to the charset specified by `encoding`. All subsequent read and write operations will then be done using the new charset.\n\nThis must only be used if the file is a text file. In that case, specifying the file's charset can be quite convenient because Hollywood will then handle all charset conversions automatically when reading from or writing to the file using functions like [ReadLine()](https://www.hollywood-mal.com/docs/html/hollywood/ReadLine_.html), [ReadString()](https://www.hollywood-mal.com/docs/html/hollywood/ReadString_.html), [WriteLine()](https://www.hollywood-mal.com/docs/html/hollywood/WriteLine_.html) or [WriteString()](https://www.hollywood-mal.com/docs/html/hollywood/WriteString_.html). By default, Hollywood expects text files to be in the UTF-8 charset because that's Hollywood's default charset. If you want to read from or write to a file using the ISO 8859-1 encoding instead, just pass `#ENCODING_ISO8859_1` in `encoding` and Hollywood will handle all conversions to and from ISO 8859-1 automatically.\n\nSee [SetDefaultEncoding](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultEncoding_.html).",
    "inputsDocs": "* `id` — identifier of file\n* `encoding` — desired new charset to use",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "SetFileEncoding(${1:id}, ${2:encoding})"
  },
  {
    "name": "SetIOMode",
    "helpId": "SetIOMode",
    "shortDescription": "switch between buffered and unbuffered IO",
    "version": "2.5",
    "synopsis": "SetIOMode(mode)",
    "functionDocs": "This function can be used to specify the IO mode the functions of the Hollywood DOS library shall use. By default, all DOS functions use buffered IO. This is especially efficient for small read and write operations. For some cases, however, buffered IO is not very convenient and you might want to use unbuffered IO instead. For example, when you write to the parallel device using the DOS library or you have opened a console window using [OpenFile()](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html). In those cases unbuffered IO is to be preferred because the data is passed directly to the file system.\n\nThe mode you set using this function is respected by all functions of the DOS library but please note that if you switch between buffered and unbuffered IO on the same file, you have to use [FlushFile()](https://www.hollywood-mal.com/docs/html/hollywood/FlushFile_.html) to flush all pending buffers. If you forget to do this, you might end up with data at the wrong positions in your file.\n\nThis function is meant for advanced users. Normally, you do not have to care about the IO mode.",
    "inputsDocs": "* `mode` — desired IO mode for the DOS library; this can be either `#IO_BUFFERED` or `#IO_UNBUFFERED` (by default, Hollywood will always use `#IO_BUFFERED`)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "SetIOMode(${1:mode})"
  },
  {
    "name": "StringToFile",
    "helpId": "StringToFile",
    "shortDescription": "save string to file",
    "version": "5.0",
    "synopsis": "StringToFile(s$, file$[, t])",
    "functionDocs": "This command is a convenience function which simply saves the string specified in by `s$` as the file specified by `file$`. Be warned that this function does not append the string to the file. If the file specified by `file$` already exists, it will be overwritten without any warning. Note that since Hollywood strings can also contain binary data, you can also use this function to write strings containing raw data to files.\n\nStarting with Hollywood 10.0, `StringToFile()` accepts an optional table argument that allows you to pass additional arguments to the function. The following tags are currently supported by the optional table argument:\n\n- `Adapter`: This tag allows you to specify one or more file adapters that should be asked if they want to save the specified file. If you use this tag, you must set it to a string containing the name(s) of one or more adapter(s). Defaults to the adapter set using [SetDefaultAdapter()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultAdapter_.html). See [Loaders and adapters](https://www.hollywood-mal.com/docs/html/hollywood/LoaderAdapterInfo_.html). (V10.0)\n\n- `UserTags`: This tag can be used to specify additional data that should be passed to file adapters. If you use this tag, you must set it to a table of key-value pairs that contain the additional data that should be passed to plugins. See [User tags](https://www.hollywood-mal.com/docs/html/hollywood/UserTagsInfo_.html). (V10.0)",
    "inputsDocs": "* `s$` — string to write to file\n* `file$` — destination file\n* `t` — optional: table containing further options (see above)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "StringToFile(${1:s$}, ${2:file$})"
  },
  {
    "name": "UndefineVirtualStringFile",
    "helpId": "UndefineVirtualStringFile",
    "shortDescription": "undefine a string source virtual file",
    "version": "5.0",
    "synopsis": "UndefineVirtualStringFile(virtfile$)",
    "functionDocs": "This function can be used to undefine a virtual file created by the function [DefineVirtualFileFromString()](https://www.hollywood-mal.com/docs/html/hollywood/DefineVirtualFileFromString_.html). It is important to call this function when you are done with a virtual file because it will release memory occupied by the virtual file.\n\nSee [DefineVirtualFileFromString](https://www.hollywood-mal.com/docs/html/hollywood/DefineVirtualFileFromString_.html).",
    "inputsDocs": "* `virtfile$` — a virtual file created by DefineVirtualFileFromString()",
    "example": "See [DefineVirtualFileFromString](https://www.hollywood-mal.com/docs/html/hollywood/DefineVirtualFileFromString_.html)",
    "platforms": ["All"],
    "insertText": "UndefineVirtualStringFile(${1:virtfile$})"
  },
  {
    "name": "UnsetEnv",
    "helpId": "UnsetEnv",
    "shortDescription": "delete environment variable",
    "version": "5.0",
    "synopsis": "UnsetEnv(var$)",
    "functionDocs": "This command can be used to delete the specified environment variable. Please note that you cannot delete global environment variables with this function. You may only delete environment variables that are local to your Hollywood script.",
    "inputsDocs": "* `var$` — environment variable to delete",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "UnsetEnv(${1:var$})"
  },
  {
    "name": "UseCarriageReturn",
    "helpId": "UseCarriageReturn",
    "shortDescription": "configure line break behaviour",
    "version": "7.1",
    "synopsis": "UseCarriageReturn(enable)",
    "functionDocs": "This function allows you to set whether or not [WriteLine()](https://www.hollywood-mal.com/docs/html/hollywood/WriteLine_.html) will write a carriage return character before the line feed character. MS-DOS and its successor Windows both use carriage return and line feed characters to indicate a line break whereas Unix, Amiga, and macOS just use a line feed character to force a line break.\n\nIf `enable` is set to `True`, [WriteLine()](https://www.hollywood-mal.com/docs/html/hollywood/WriteLine_.html) will write a carriage return character before each line feed character, otherwise it will only output a line feed character. By default, `UseCarriageReturn()` is set to `True` on Windows systems and to `False` on all other systems.",
    "inputsDocs": "* `enable` — `True` or `False` indicating whether [WriteLine()](https://www.hollywood-mal.com/docs/html/hollywood/WriteLine_.html) should output a carriage return before a line feed character",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "UseCarriageReturn(${1:enable})"
  },
  {
    "name": "WriteByte",
    "helpId": "WriteByte",
    "shortDescription": "write byte to file",
    "version": "7.0",
    "synopsis": "WriteByte(id, b[, flags])",
    "functionDocs": "This function writes a single byte to the file specified by `id` at the current file cursor position which you can modify by using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. `WriteByte()` will advance the file cursor position by one byte.\n\nThe `flags` parameter may be set to one of the following flags:\n\n- `#IO_UNSIGNED`: Write an unsigned byte to the file. This means that `b` must be between 0 and 255. This is the default.\n\n- `#IO_SIGNED`: Write a signed byte to the file. This means that `b` must be between -128 and 127.",
    "inputsDocs": "* `id` — file to write to\n* `b` — byte data to write to the file\n* `flags` — optional: additional flags (see above) (defaults to `#IO_UNSIGNED`) (V9.0)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "WriteByte(${1:id}, ${2:b})"
  },
  {
    "name": "WriteBytes",
    "helpId": "WriteBytes",
    "shortDescription": "write bytes to file",
    "version": "7.0",
    "synopsis": "WriteBytes(id, data$[, len])",
    "functionDocs": "This function writes `len` bytes from the string `data$` to the file specified by `id`. If the optional argument `len` is omitted, the complete string will be written to the file. `WriteBytes()` will advance the file cursor position by the number of bytes written.\n\nThis function is useful for writing binary data to a file. The string specified by `data$` will be treated as raw binary data instead of text.",
    "inputsDocs": "* `id` — file to write to\n* `data$` — data to write to file\n* `len` — optional: number of bytes to write (defaults to 0 which means write the complete string)",
    "example": "```\nsize = FileSize(\"test\")\nOpenFile(1, \"test\")\nOpenFile(2, \"copy_of_test\", #MODE_WRITE)\ndata$ = ReadBytes(1, size)\nWriteBytes(2, data$, size)\nCloseFile(2)\nCloseFile(1)\n```\n\nThe above code makes a copy of the file \"test\" and saves it as \"copy_of_test\".",
    "platforms": ["All"],
    "insertText": "WriteBytes(${1:id}, ${2:data$})"
  },
  {
    "name": "WriteChr",
    "helpId": "WriteChr",
    "shortDescription": "write a character to a file",
    "version": "1.0",
    "synopsis": "WriteChr(id, chr[, encoding])",
    "functionDocs": "Writes the character specified by `chr` to the file specified by `id` and increments the file cursor by the number of bytes written. The character to be written has to be passed to `WriteChr()` as a code point value. Note that depending on the encoding, this function might write up to 4 bytes to the file because in UTF-8, a single character may use up to 4 bytes.\n\nThe optional `encoding` parameter can be used to set the character encoding to use. This defaults to the default string encoding set using [SetDefaultEncoding()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultEncoding_.html). See [Character encodings](https://www.hollywood-mal.com/docs/html/hollywood/CharacterEncoding_.html).\n\nIf you need to write a single byte to a file, use the [WriteByte()](https://www.hollywood-mal.com/docs/html/hollywood/WriteByte_.html) function instead. See [WriteByte](https://www.hollywood-mal.com/docs/html/hollywood/WriteByte_.html).",
    "inputsDocs": "* `id` — identifier specifying the file to use\n* `chr` — code point value of character to write to file\n* `encoding` — optional: character encoding to use (defaults to default string encoding) (V7.0)",
    "example": "```\nOpenFile(1, \"Test\", #MODE_WRITE)\nWriteChr(1, 65)\nCloseFile()\n```\n\nThis code writes the character \"A\" to the file Test.",
    "platforms": ["All"],
    "insertText": "WriteChr(${1:id}, ${2:chr})"
  },
  {
    "name": "WriteFloat",
    "helpId": "WriteFloat",
    "shortDescription": "write a float to a file",
    "version": "2.0",
    "synopsis": "WriteFloat(id, float[, width, le])",
    "functionDocs": "This function writes a signed float to the file specified by `id` at the current file cursor position which you can modify by using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. A float will use 8 bytes of disk space which is enough to store really big integers and floats with many decimal places.\n\nStarting with Hollywood 6.0 there is an optional argument which allows you to specify the byte width of the floating point number. This can be 8 for a double-precision floating point number or 4 for a single-precision floating point number. By default, `WriteFloat()` writes double-precision floats.\n\nBy default, this function stores the value in big endian format (most significant byte first). Starting with Hollywood 6.0 you can use the optional argument `le` to explicitly request this function to use the little endian format instead.",
    "inputsDocs": "* `id` — file to write to\n* `float` — float value to write to the file\n* `width` — optional: byte width of the float to write (defaults to 8) (V6.0)\n* `le` — optional: `True` to write bytes in little endian order, `False` for big endian order (defaults to `False`) (V6.0)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "WriteFloat(${1:id}, ${2:float})"
  },
  {
    "name": "WriteFunction",
    "helpId": "WriteFunction",
    "shortDescription": "write a function to a file",
    "version": "4.0",
    "synopsis": "WriteFunction(id, func[, txtmode, nobrk])",
    "functionDocs": "This function writes the Hollywood function specified by `func` to the file specified by `id` at the current file cursor position which you can modify by using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. The function will be written to the file as precompiled bytecode, i.e. it will not be human readable.\n\nYou can load saved functions into other projects by using the [ReadFunction()](https://www.hollywood-mal.com/docs/html/hollywood/ReadFunction_.html) command. The optional argument `txtmode` specifies whether or not the function shall be written to the file as binary data or as base64 encoded data. The latter is useful for embedding Hollywood functions in human readable text files, for instance XML files. In case you enable text mode, `WriteFunction()` will automatically insert a line break after every 72 characters for better readability. If you don't want that, set the optional argument `nobrk` to `True`. In that case, no line breaks will be inserted.",
    "inputsDocs": "* `id` — file to write to\n* `func` — function to write to the file\n* `txtmode` — optional: `True` to write the function in base64 notation or `False` to write plain binary data (defaults to `False`)\n* `nobrk` — optional: `True` if you don't want to have line breaks inserted when in text mode (defaults to `False`); this argument is ignored in binary mode (V6.1)",
    "example": "```\nFunction p_LittleTestFunc(a, b)\n  Return(a+b)\nEndFunction\n\nOpenFile(1, \"func.bin\", #MODE_WRITE)\nWriteFunction(1, p_LittleTestFunc)\nCloseFile(1)\n\nOpenFile(1, \"func.bin\", #MODE_READ)\np_MyAdd = ReadFunction(1)\nCloseFile(1)\n\nPrint(p_MyAdd(5, 6))  ; prints 11\n```\n\nThe code above writes the function p_LittleTestFunc() to file \"func.bin\". After that, it opens file \"func.bin\" again and reads the function back into Hollywood. The imported function will be stored in the variable p_MyAdd(). Finally, we will call the newly imported function p_MyAdd() and it will add the numbers 5 and 6 for us.",
    "platforms": ["All"],
    "insertText": "WriteFunction(${1:id}, ${2:func})"
  },
  {
    "name": "WriteInt",
    "helpId": "WriteInt",
    "shortDescription": "write an integer to a file",
    "version": "2.0",
    "synopsis": "WriteInt(id, int[, flags])",
    "functionDocs": "This function writes an integer to the file specified by `id` at the current file cursor position which you can modify by using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. By default, `WriteInt()` will write a 32-bit integer, advancing the file cursor by 4 bytes.\n\nThe `flags` parameter may be a combination of the following flags:\n\n- `#IO_SIGNED`: Use signed integers. This means that `int` must be in the range of -2147483648 to 2147483647 (in case `#IO_FAKE64` isn't set). This is the default.\n\n- `#IO_UNSIGNED`: Use unsigned integers. This means that `int` must be in the range of 0 to 4294967295. Note that `#IO_UNSIGNED` cannot be combined with `#IO_FAKE64`.\n\n- `#IO_LITTLEENDIAN`: By default, this function stores the value in big endian format (most significant byte first). You can set this flag to request this function to use the little endian format instead.\n\n- `#IO_FAKE64`: Use 64-bit integers. This is called \"fake 64\" because Hollywood can't use the full 64-bit integer range because its numeric type is a 64-bit floating point value which can't represent exactly the same range as a true 64-bit integer value. Still, Hollywood's fake 64-bit integers should be large enough for almost anything. Using `#IO_FAKE64` you can write integers in the range of -9007199254740992 to 9007199254740992. Note that `#IO_UNSIGNED` can't be used with `#IO_FAKE64`. Hollywood's fake 64-bit integers will always be signed. (V9.0)",
    "inputsDocs": "* `id` — file to write to\n* `int` — integer value to write to the file\n* `flags` — optional: additional flags (see above) (defaults to `#IO_SIGNED`) (V9.0)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "WriteInt(${1:id}, ${2:int})"
  },
  {
    "name": "WriteLine",
    "helpId": "WriteLine",
    "shortDescription": "write a new line to a file",
    "version": "1.0",
    "synopsis": "WriteLine(id, line$)",
    "functionDocs": "Writes the string specified by `line$` to the file described by `id` and increases the file cursor accordingly.\n\nNote that on Windows systems `WriteLine()` appends both, carriage return and line feed, to `line$` whereas on all other systems only the line feed character is appended to `line$`. This behaviour can be changed by calling the [UseCarriageReturn()](https://www.hollywood-mal.com/docs/html/hollywood/UseCarriageReturn_.html) command. See [UseCarriageReturn](https://www.hollywood-mal.com/docs/html/hollywood/UseCarriageReturn_.html).",
    "inputsDocs": "* `id` — number specifying the file to use\n* `line$` — string to write to file",
    "example": "See [ReadChr](https://www.hollywood-mal.com/docs/html/hollywood/ReadChr_.html)",
    "platforms": ["All"],
    "insertText": "WriteLine(${1:id}, ${2:line$})"
  },
  {
    "name": "WriteShort",
    "helpId": "WriteShort",
    "shortDescription": "write 16-bit integer to a file",
    "version": "2.0",
    "synopsis": "WriteShort(id, short[, flags])",
    "functionDocs": "This function writes a 16-bit integer to the file specified by `id` at the current file cursor position which you can modify by using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command. Since a short integer is 16-bit, the file cursor will be advanced by 2 bytes.\n\nThe `flags` parameter may be a combination of the following flags:\n\n- `#IO_UNSIGNED`: Use an unsigned integer. This means that `short` must be in the range of 0 to 65535. This is the default.\n\n- `#IO_SIGNED`: Use a signed integer. This means that `short` must be in the range of -32768 to 32767.\n\n- `#IO_LITTLEENDIAN`: By default, this function stores the value in big endian format (most significant byte first). You can set this flag to request this function to use the little endian format instead.",
    "inputsDocs": "* `id` — file to write to\n* `short` — short integer value to write to the file\n* `flags` — optional: additional flags (see above) (defaults to `#IO_UNSIGNED`) (V9.0)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "WriteShort(${1:id}, ${2:short})"
  },
  {
    "name": "WriteString",
    "helpId": "WriteString",
    "shortDescription": "write string to file",
    "version": "1.0",
    "synopsis": "WriteString(id, s$[, len, encoding])",
    "functionDocs": "This function writes the string `s$` to the file specified by `id`. The optional argument `len` can be used to set the number of characters that should be written to the file. If `len` is omitted, the complete string is written. The file cursor position is advanced by the number of bytes written to the file. Note that this is not necessarily the same as `len` because in UTF-8 encoding a single character can use up to 4 bytes.\n\nThe optional `encoding` parameter can be used to set the character encoding to use. This defaults to the default string encoding set using [SetDefaultEncoding()](https://www.hollywood-mal.com/docs/html/hollywood/SetDefaultEncoding_.html). See [Character encodings](https://www.hollywood-mal.com/docs/html/hollywood/CharacterEncoding_.html).\n\nThis function is used for writing text to files. If you need to write binary data to a file, use the [WriteBytes()](https://www.hollywood-mal.com/docs/html/hollywood/WriteBytes_.html) function instead. See [WriteBytes](https://www.hollywood-mal.com/docs/html/hollywood/WriteBytes_.html).",
    "inputsDocs": "* `id` — file to write to\n* `s$` — string to write to the file\n* `len` — optional: number of characters to file or 0 to write the complete string (defaults to 0)\n* `encoding` — optional: character encoding to use (defaults to default string encoding) (V7.0)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "WriteString(${1:id}, ${2:s$})"
  }
]
