[
  {
    "name": "AllocMem",
    "helpId": "AllocMem",
    "shortDescription": "allocate a new memory block",
    "version": "2.0",
    "synopsis": "[id] = AllocMem(id, size)",
    "functionDocs": "This command allocates a new memory block of the specified size and makes it available under the handle id, or, if you specify [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) in `id` `AllocMem()` automatically chooses an identifier and returns it. The memory will not be initialized and is therefore filled with random data. If you want to initialize it to zero, use the [FillMem()](https://www.hollywood-mal.com/docs/html/hollywood/FillMem_.html) command.",
    "inputsDocs": "* `id` — identifier for the memory block or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `size` — size for the memory block in bytes",
    "resultsDocs": "* `id` — optional: identifier of the memory block; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "platforms": ["All"],
    "insertText": "AllocMem(${1:id}, ${2:size})"
  },
  {
    "name": "AllocMemFromPointer",
    "helpId": "AllocMemFromPointer",
    "shortDescription": "initialize memory block from pointer",
    "version": "6.0",
    "synopsis": "[id] = AllocMemFromPointer(id, ptr, size)",
    "functionDocs": "This command can be used to convert a pointer of type `#LIGHTUSERDATA` into a memory block that you can read from and write to using the memory block functions. The new memory block object will be made available under the handle `id`, or, if you specify [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as `id`, `AllocMemFromPointer()` automatically chooses an identifier and returns it.\n\nNote that `AllocMemFromPointer()` will not make a local copy of the memory pointed to by parameter 2. It will just allocate a container object so that you can access the memory data using the memory block functions. The `size` argument is only used to prevent read or write operations that are outside the memory block's boundaries. If you don't know the size of the memory block, you can also pass 0 in the `size` argument. In that case, Hollywood will never forbid any read and write operation on this memory block object.\n\nBe warned that this is a dangerous function and should only be used by people who know what they are doing. Reading from or writing to non-allocated memory can easily crash your program.",
    "inputsDocs": "* `id` — identifier for the memory block or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `ptr` — `#LIGHTUSERDATA` variable pointing to a memory block\n* `size` — size of the memory block in bytes or 0 if you don't know the size",
    "resultsDocs": "* `id` — optional: identifier of the memory block; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "platforms": ["All"],
    "insertText": "AllocMemFromPointer(${1:id}, ${2:ptr}, ${3:size})"
  },
  {
    "name": "AllocMemFromVirtualFile",
    "helpId": "AllocMemFromVirtualFile",
    "shortDescription": "initialize memory block from virtual file",
    "version": "6.1",
    "synopsis": "[id] = AllocMemFromVirtualFile(id, vf$)",
    "functionDocs": "This command can be used to access the raw memory contents of a virtual string file created using [DefineVirtualFileFromString()](https://www.hollywood-mal.com/docs/html/hollywood/DefineVirtualFileFromString_.html). The new memory block object will be made available under the handle `id`, or, if you specify [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as `id`, `AllocMemFromVirtualFile()` automatically chooses an identifier and returns it.\n\nNote that `AllocMemFromVirtualFile()` will not make a local copy of the memory owned by the virtual string file. It will just allocate a container object so that you can access the memory data using the memory block functions.\n\nAlso note that when dealing with writeable virtual string files their memory representation can change with every single write operation performed on the virtual string file. Thus, it is not safe to access the virtual string file's memory through a container obtained from `AllocMemFromVirtualFile()` after a write operation to this virtual string file. Instead, you have to obtain a new container after every write operation and free the old one using [FreeMem()](https://www.hollywood-mal.com/docs/html/hollywood/FreeMem_.html) first. Everything else will crash sooner or later.\n\nAlso note that it is forbidden to write to the memory block allocated by this function unless the virtual string file was created as writable.\n\nBe warned that this is a dangerous function and should only be used by people who know what they are doing. Reading from or writing to non-allocated memory can easily crash your program and cause all sorts of issues.",
    "inputsDocs": "* `id` — identifier for the memory block or [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) for [auto id selection](https://www.hollywood-mal.com/docs/html/hollywood/AutoIDSelect_.html)\n* `vf$` — virtual string file allocated by [DefineVirtualFileFromString()](https://www.hollywood-mal.com/docs/html/hollywood/DefineVirtualFileFromString_.html)",
    "resultsDocs": "* `id` — optional: identifier of the memory block; will only be returned when you pass [Nil](https://www.hollywood-mal.com/docs/html/hollywood/PrgTypeNil_.html) as argument 1 (see above)",
    "platforms": ["All"],
    "insertText": "AllocMemFromVirtualFile(${1:id}, ${2:vf$})"
  },
  {
    "name": "CopyMem",
    "helpId": "CopyMem",
    "shortDescription": "copy data between memory blocks",
    "version": "2.0",
    "synopsis": "CopyMem(src, dst, size[, src_offset, dst_offset])",
    "functionDocs": "This command copies size bytes from the memory block with the id `src` to the block with the id `dst` starting from `src_offset` in the source block and from `dst_offset` in the destination block.\n\nPlease note that `src` and `dst` must not be the same blocks.",
    "inputsDocs": "* `src` — source memory block to read data from\n* `dst` — destination memory block to copy to\n* `size` — size in bytes to copy\n* `src_offset` — optional: offset in the source block from where to start reading (defaults to 0 = beginning of the block)\n* `dst_offset` — optional: offset in the destination block from where to start writing (defaults to 0 = beginning of the block)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "CopyMem(${1:src}, ${2:dst}, ${3:size})"
  },
  {
    "name": "DecreasePointer",
    "helpId": "DecreasePointer",
    "shortDescription": "decrease pointer",
    "version": "6.0",
    "synopsis": "ptr = DecreasePointer(ptr, amount)",
    "functionDocs": "This function decreases the specified pointer of type `#LIGHTUSERDATA` by the amount of bytes specified in parameter 2. Since you shouldn't use pointers in Hollywood, this function is really only useful when debugging code or doing some experimental stuff with Hollywood.\n\nTo increase a pointer, you can use the [IncreasePointer()](https://www.hollywood-mal.com/docs/html/hollywood/IncreasePointer_.html) function. See [IncreasePointer](https://www.hollywood-mal.com/docs/html/hollywood/IncreasePointer_.html).",
    "inputsDocs": "* `ptr` — pointer passed as a `#LIGHTUSERDATA` variable\n* `amount` — number of bytes to decrease",
    "resultsDocs": "* `ptr` — new pointer of type `#LIGHTUSERDATA`",
    "platforms": ["All"],
    "insertText": "DecreasePointer(${1:ptr}, ${2:amount})"
  },
  {
    "name": "DumpMem",
    "helpId": "DumpMem",
    "shortDescription": "dump contents of a memory block",
    "version": "2.0",
    "synopsis": "DumpMem(id[, len, offset])",
    "functionDocs": "This function dumps the contents of the memory block specified by `id` to the debug device (usually a console window). The optional argument allows you to specify the length in bytes that shall be dumped. If it is omitted, the whole block will be dumped. The optional argument offset can be used to start dumping from an offset inside the block.\n\nBecause of the raw data that is usually in memory blocks, Hollywood will do a hex dump including ASCII notation (if possible). The format is the following:\n\n```\nxxxxxxxx: bb bb bb bb bb bb bb bb bb bb bb bb bb bb cccccccccccccccc\n```\n\n- x: offset in hexadecimal notation\n\n- b: 16 bytes per line\n\n- c: the 16 bytes in ASCII notation or '.' if the character is not graphical",
    "inputsDocs": "* `id` — identifier of the memory block to be dumped\n* `len` — optional: length in bytes (defaults to 0 which means that the complete block will be dumped)\n* `offset` — optional: offset in the block from where to start dumping (defaults to 0 = beginning of the block)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "DumpMem(${1:id})"
  },
  {
    "name": "FillMem",
    "helpId": "FillMem",
    "shortDescription": "fill a memory block",
    "version": "2.0",
    "synopsis": "FillMem(id, val, size[, offset, type])",
    "functionDocs": "This function can be used to fill the whole memory block or a part of it with a specified value. `id` specifies the memory block to use, `val` is the value to use for filling and `size` specifies the size in bytes for the filling operation. You can use the optional argument offset to fine-tune the filling operation by specifying an offset in the memory block here (in bytes). `type` specifies the type of the value and can be `#BYTE` (1 byte), `#SHORT` (2 bytes) or `#INTEGER` (4 bytes).\n\nIf you use `#SHORT` or `#INTEGER` as the filling type, the `size` argument must be a multiple of 2 or 4 respectively. Also, `offset`, if specified, must be a multiple of 2 or 4 respectively.",
    "inputsDocs": "* `id` — memory block to use\n* `val` — value to fill block with\n* `size` — size of the filling operation in bytes; must be a multiple of 2 or 4 if type is `#SHORT` or `#INTEGER`\n* `offset` — optional: offset in the block where the filling should start (defaults to 0 which means the beginning of the block); must be a multiple of 2 or 4 if type is `#SHORT` or `#INTEGER`\n* `type` — optional: type of val; currently supported are `#BYTE`, `#SHORT` and `#INTEGER` (defaults to `#BYTE`)",
    "example": "```\nAllocMem(1, 65536)\nFillMem(1, 0, 65536)\n```\n\nAllocate a block of 64kb and initialize it to 0.",
    "platforms": ["All"],
    "insertText": "FillMem(${1:id}, ${2:val}, ${3:size})"
  },
  {
    "name": "FreeMem",
    "helpId": "FreeMem",
    "shortDescription": "free a memory block",
    "version": "2.0",
    "synopsis": "FreeMem(id)",
    "functionDocs": "This command releases the memory occupied by the block specified by `id`.",
    "inputsDocs": "* `id` — memory block to free",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "FreeMem(${1:id})"
  },
  {
    "name": "GetMemPointer",
    "helpId": "GetMemPointer",
    "shortDescription": "get raw address of memory block",
    "version": "6.0",
    "synopsis": "ptr = GetMemPointer(id[, offset])",
    "functionDocs": "This function returns the raw address of the memory block passed in `id`. Optionally, you can specify an offset in bytes that should be added to the address before returning it. The pointer will be returned as a variable of type `#LIGHTUSERDATA`. It will stay valid until you call [FreeMem()](https://www.hollywood-mal.com/docs/html/hollywood/FreeMem_.html) on the memory block object.\n\nThis function is only useful in connection with functions which expect parameters of type `#LIGHTUSERDATA`. There are currently no Hollywood functions which can handle `#LIGHTUSERDATA` parameters but plugins might want to use `#LIGHTUSERDATA` parameters for certain tasks in case using tables is too slow.",
    "inputsDocs": "* `id` — memory block whose address should be returned\n* `offset` — optional: offset in bytes to add to the address before returning it (defaults to 0)",
    "resultsDocs": "* `ptr` — pointer to the raw data of the specified memory block",
    "platforms": ["All"],
    "insertText": "GetMemPointer(${1:id})"
  },
  {
    "name": "GetMemString",
    "helpId": "GetMemString",
    "shortDescription": "get string from memory block",
    "version": "7.1",
    "synopsis": "s$ = GetMemString(id[, offset, length])",
    "functionDocs": "This function returns `length` bytes starting at `offset` from the memory block specified by `id`. Both the `offset` and `length` parameters must be specified in bytes. If omitted, `offset` defaults to 0 (i.e. the beginning of the memory block) and `length` also defaults to 0 which means all remaining bytes starting from the specified offset are returned.\n\nNote that since Hollywood strings can also contain raw binary data the string that is returned by `GetMemString()` isn't necessarily a valid UTF-8 string but contains the raw binary data copied from the specified memory block.",
    "inputsDocs": "* `id` — memory block to use\n* `offset` — optional: offset in bytes defining where to start fetching bytes (defaults to 0)\n* `length` — optional: number of bytes to fetch or 0 to fetch all remaining bytes in the memory block (defaults to 0)",
    "resultsDocs": "* `s$` — contents of the specified memory block range",
    "platforms": ["All"],
    "insertText": "GetMemString(${1:id})"
  },
  {
    "name": "IncreasePointer",
    "helpId": "IncreasePointer",
    "shortDescription": "increase pointer",
    "version": "6.0",
    "synopsis": "ptr = IncreasePointer(ptr, amount)",
    "functionDocs": "This function increases the specified pointer of type `#LIGHTUSERDATA` by the amount of bytes specified in parameter 2. Since you shouldn't use pointers in Hollywood, this function is really only useful when debugging code or doing some experimental stuff with Hollywood.\n\nTo decrease a pointer, you can use the [DecreasePointer()](https://www.hollywood-mal.com/docs/html/hollywood/DecreasePointer_.html) function. See [DecreasePointer](https://www.hollywood-mal.com/docs/html/hollywood/DecreasePointer_.html).",
    "inputsDocs": "* `ptr` — pointer passed as a `#LIGHTUSERDATA` variable\n* `amount` — number of bytes to increase",
    "resultsDocs": "* `ptr` — new pointer of type `#LIGHTUSERDATA`",
    "platforms": ["All"],
    "insertText": "IncreasePointer(${1:ptr}, ${2:amount})"
  },
  {
    "name": "MemToTable",
    "helpId": "MemToTable",
    "shortDescription": "return memory block contents as a table",
    "version": "6.0",
    "synopsis": "t = MemToTable(id, type[, table])",
    "functionDocs": "This function can be used to return the contents of a memory block (or part of a memory block) as a table. The `type` argument specifies the data type of the elements that should be read from the memory block and stored inside a table. This can be either `#BYTE` (1 byte), `#SHORT` (2 bytes), `#INTEGER` (4 bytes), `#FLOAT` (4 bytes), or `#DOUBLE` (8 bytes).\n\nThe optional `table` argument can be used to set additional parameters for the operation. The following table fields are currently recognized:\n\n- `Items`: The number of items to be read from the memory block. Note that this is not a size in bytes, but an item count. So if you set the `type` argument to `#INTEGER` and set `Items` to 4, 16 bytes will be read from the memory block. Defaults to all items that are in the memory block.\n\n- `Offset`: This tag can be used to specify an offset in bytes inside the memory block that defines where `MemToTable()` should start to read elements. Defaults to 0 which means read from the beginning of the memory block.\n\n- `Signed`: If this tag is set to `True`, `MemToTable()` will treat all elements of type `#BYTE`, `#SHORT`, and `#INTEGER` as signed values. Defaults to `False`.\n\n- `EndianSwitch`: If this tag is set to `True`, `MemToTable()` will switch byte order for all multi-byte data types. This can be useful if you need to convert between big and little endian values. Defaults to `False`.\n\nTo convert a table back into a memory block, use the [TableToMem()](https://www.hollywood-mal.com/docs/html/hollywood/TableToMem_.html) function. See [TableToMem](https://www.hollywood-mal.com/docs/html/hollywood/TableToMem_.html).",
    "inputsDocs": "* `id` — memory block to use\n* `type` — data type of the elements to read (see above)\n* `table` — optional: table configuring further parameters (see above)",
    "resultsDocs": "* `t` — a table containing as many elements as specified in the `Items` tag",
    "example": "```\nAllocMem(1, 26)\nFor Local k = 0 To 25 Do Poke(1, k, 'A' + k, #BYTE)\nLocal t = MemToTable(1, #BYTE)\nFor Local k = 0 To 25 Do Print(Chr(t[k]))\n```\n\nThis prints the alphabet from a memory block source.",
    "platforms": ["All"],
    "insertText": "MemToTable(${1:id}, ${2:type})"
  },
  {
    "name": "Peek",
    "helpId": "Peek",
    "shortDescription": "look inside a memory block",
    "version": "2.0",
    "synopsis": "val = Peek(id, offset[, type, len, endian])",
    "functionDocs": "This function allows you to look inside a memory block at the specified offset. `type` specifies the data type for which you want to look. This can be `#BYTE`, `#SHORT`, `#INTEGER`, `#FLOAT`, `#DOUBLE` or `#STRING`. `#BYTE` will read one byte from the block, `#SHORT` reads two bytes, `#INTEGER` and `#FLOAT` four bytes, `#DOUBLE` eight bytes, and `#STRING` reads from the memory block until it encounters a non-graphical character or a `NULL` character.\n\nStarting with Hollywood 2.5, you can specify the optional parameter `len`. This parameter can only be used with type `#STRING`. If specified, `Peek()` will read exactly `len` bytes from the specified memory block location and return it as a string. You can use this to read raw data from memory blocks because `Peek()` will not terminate at non-graphical or `NULL` characters any more if `len` is specified. If `len` is 0, which is the default setting, `Peek()` will read bytes until it encounters a non-graphical or `NULL` character.\n\nStarting with Hollywood 6.0 there is a new `endian` parameter which allows you to specify the byte order that should be used when reading the data from the memory block. This can be set to the following types:\n\n- `#BIGENDIAN`: Big endian byte order, MSB first. This is the default.\n\n- `#NATIVEENDIAN`: Native endian byte order. If you use this type, the byte order will depend on the default byte order on the host system, i.e. big endian on big endian systems, little endian on little endian systems. Be careful using this type because it limits portability.\n\n- `#LITTLEENDIAN`: Little endian byte order, LSB first. (V8.0)",
    "inputsDocs": "* `id` — identifier of the memory block to be used\n* `offset` — where to peek (in bytes)\n* `type` — optional: data type to peek for (defaults to `#INTEGER`)\n* `len` — optional: number of bytes to read (works only in connection with type `#STRING`) (defaults to 0 which means read until a non-graphical or `NULL` character) (V2.5)\n* `endian` — optional: byte order to use (defaults to `#BIGENDIAN`) (V6.0)",
    "resultsDocs": "* `val` — contents of the memory block at the specified offset; can be a value or a string (if type was set to `#STRING`)",
    "platforms": ["All"],
    "insertText": "Peek(${1:id}, ${2:offset})"
  },
  {
    "name": "Poke",
    "helpId": "Poke",
    "shortDescription": "write to a memory block",
    "version": "2.0",
    "synopsis": "Poke(id, offset, val[, type, endian])",
    "functionDocs": "This function writes the value or string specified in `val` to the memory block with the identifier `id` at the specified offset. `Type` defaults to `#INTEGER` and specifies the type of `val`. You can also use the following types: `#BYTE` (1 byte), `#SHORT` (2 bytes), `#FLOAT` (4 byte single-precision floating point number), `#DOUBLE` (8 byte double-precision floating point number) or `#STRING`. Poking a string into a memory block occupies the number of characters in the string plus 1 byte.\n\nStarting with Hollywood 6.0 there is a new `endian` parameter which allows you to specify the byte order that should be used when writing the data to the memory block. This can be set to the following types:\n\n- `#BIGENDIAN`: Big endian byte order, MSB first. This is the default.\n\n- `#NATIVEENDIAN`: Native endian byte order. If you use this type, the byte order will depend on the default byte order on the host system, i.e. big endian on big endian systems, little endian on little endian systems. Be careful using this type because it limits portability.\n\n- `#LITTLEENDIAN`: Little endian byte order, LSB first. (V8.0)",
    "inputsDocs": "* `id` — identifier of the memory block to be used\n* `offset` — where to poke (in bytes)\n* `val` — data to poke; can be string or number\n* `type` — optional: data type to poke (defaults to `#INTEGER`)\n* `endian` — optional: byte order to use (defaults to `#BIGENDIAN`) (V6.0)",
    "example": "```\nAllocMem(1, 1024)\nPoke(1, 0, \"Hello World!\", #STRING)\nPrint(Peek(1, 0, #STRING))\n```\n\nThis will print \"Hello World!\" to the screen.",
    "platforms": ["All"],
    "insertText": "Poke(${1:id}, ${2:offset}, ${3:val})"
  },
  {
    "name": "ReadMem",
    "helpId": "ReadMem",
    "shortDescription": "read raw data from a file",
    "version": "2.0",
    "synopsis": "ReadMem(file_id, blk_id, len[, offset])",
    "functionDocs": "This function allows you to read `len` bytes raw data from an open file (specified by `file_id`, use [OpenFile()](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html) to open files) to a memory block (specified by `blk_id`). Additionally you can specify the optional `offset` argument to define where in the memory block the raw data shall be stored. The data from the source file is read from the current cursor position in the file which you can modify using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command.",
    "inputsDocs": "* `file_id` — identifier of an open file\n* `blk_id` — identifier of a memory block\n* `len` — bytes to read from the file\n* `offset` — optional: where to store the data in the block (defaults to 0 = beginning of the block)",
    "example": "```\nlen = FileSize(\"C:SetPatch\")\nOpenFile(1, \"C:SetPatch\", #MODE_READ)\nAllocMem(1, len)\nReadMem(1, 1, len)\nCloseFile(1)\nOpenFile(1, \"Ram:Copy_of_SetPatch\", #MODE_WRITE)\nWriteMem(1, 1, len)\nCloseFile(1)\nFreeMem(1)\n```\n\nMakes a copy of the SetPatch program in RAM: by using the two raw data i/o functions `ReadMem()` and [WriteMem()](https://www.hollywood-mal.com/docs/html/hollywood/WriteMem_.html).",
    "platforms": ["All"],
    "insertText": "ReadMem(${1:file_id}, ${2:blk_id}, ${3:len})"
  },
  {
    "name": "TableToMem",
    "helpId": "TableToMem",
    "shortDescription": "write table contents to memory block",
    "version": "6.0",
    "synopsis": "TableToMem(t, id, type[, table])",
    "functionDocs": "This function writes the contents of the table passed as the first parameter to the memory block object specified by `id`. The third parameter specifies the data type of the elements that should be written to the memory block. This can be either `#BYTE` (1 byte), `#SHORT` (2 bytes), `#INTEGER` (4 bytes), `#FLOAT` (4 bytes), or `#DOUBLE` (8 bytes).\n\nThe optional `table` argument can be used to set additional parameters for the operation. The following table fields are currently recognized:\n\n- `Offset`: This tag can be used to specify an offset in bytes inside the memory block that defines where `TableToMem()` should start to write elements. Defaults to 0 which means start writing at the beginning of the memory block.\n\n- `EndianSwitch`: If this tag is set to `True`, `TableToMem()` will switch byte order for all multi-byte data types when writing them to the memory block. This can be useful if you need to convert between big and little endian values. Defaults to `False`.\n\nIf there are more elements in the table than the memory block can store, this function will issue an error.\n\nTo convert a memory block back into a table, use the [MemToTable()](https://www.hollywood-mal.com/docs/html/hollywood/MemToTable_.html) function. See [MemToTable](https://www.hollywood-mal.com/docs/html/hollywood/MemToTable_.html).",
    "inputsDocs": "* `t` — table whose contents should be written to the memory block\n* `id` — memory block to use\n* `type` — data type of the elements to write (see above)\n* `table` — optional: table configuring further parameters (see above)",
    "resultsDocs": "none",
    "platforms": ["All"],
    "insertText": "TableToMem(${1:t}, ${2:id}, ${3:type})"
  },
  {
    "name": "WriteMem",
    "helpId": "WriteMem",
    "shortDescription": "write raw data to a file",
    "version": "2.0",
    "synopsis": "WriteMem(file_id, blk_id, len[, offset])",
    "functionDocs": "This function writes `len` bytes from the memory block specified by `blk_id` to the file specified by `file_id`. The data is read from the memory block at the `offset`, which you can specify in the homonymous optional argument. The data is written to the file at the current cursor position which you can modify using the [Seek()](https://www.hollywood-mal.com/docs/html/hollywood/Seek_.html) command.",
    "inputsDocs": "* `file_id` — identifier of an open file (use [OpenFile()](https://www.hollywood-mal.com/docs/html/hollywood/OpenFile_.html))\n* `blk_id` — identifier of a memory block\n* `len` — bytes to write to the file\n* `offset` — optional: where to begin reading the data from the block (defaults to 0 = beginning of the block)",
    "example": "See [ReadMem](https://www.hollywood-mal.com/docs/html/hollywood/ReadMem_.html)",
    "platforms": ["All"],
    "insertText": "WriteMem(${1:file_id}, ${2:blk_id}, ${3:len})"
  }
]
