[
  {
    "name": "Abs",
    "helpId": "Abs",
    "shortDescription": "return absolute value",
    "version": "1.5",
    "synopsis": "result = Abs(val)",
    "functionDocs": "This function returns the absolute value of `val`.",
    "inputsDocs": "* `val` — source value",
    "resultsDocs": "* `result` — absolute value of `val`",
    "platforms": ["All"],
    "insertText": "Abs(${1:val})"
  },
  {
    "name": "ACos",
    "helpId": "ACos",
    "shortDescription": "calculate arccosine",
    "version": "2.0",
    "synopsis": "result = ACos(x)",
    "functionDocs": "Calculates the arccosine of `x`.",
    "inputsDocs": "* `x` — value whose arccosine is to be calculated",
    "resultsDocs": "* `result` — arccossine of `x`",
    "platforms": ["All"],
    "insertText": "ACos(${1:x})"
  },
  {
    "name": "Add",
    "helpId": "Add",
    "shortDescription": "add two values",
    "version": "1.0",
    "synopsis": "result = Add(value1, value2)",
    "functionDocs": "Adds `value2` to `value1` and returns the result.",
    "inputsDocs": "* `value1` — base value\n* `value2` — number to add",
    "resultsDocs": "* `result` — result of the addition",
    "example": "```\na=99\na=Add(a,1)\nPrint(a)\n```\n\nThis will print \"100\" to the screen.",
    "platforms": ["All"],
    "insertText": "Add(${1:value1}, ${2:value2})"
  },
  {
    "name": "ASin",
    "helpId": "ASin",
    "shortDescription": "calculate arcsine",
    "version": "2.0",
    "synopsis": "result = ASin(x)",
    "functionDocs": "Calculates the arcsine of `x`.",
    "inputsDocs": "* `x` — value whose arcsine is to be calculated",
    "resultsDocs": "* `result` — arcsine of `x`",
    "platforms": ["All"],
    "insertText": "ASin(${1:x})"
  },
  {
    "name": "ATan",
    "helpId": "ATan",
    "shortDescription": "calculate arctangent",
    "version": "2.0",
    "synopsis": "result = ATan(x)",
    "functionDocs": "Calculates the arctangent of `x`.",
    "inputsDocs": "* `x` — value whose arctangent is to be calculated",
    "resultsDocs": "* `result` — arctangent of `x`",
    "platforms": ["All"],
    "insertText": "ATan(${1:x})"
  },
  {
    "name": "ATan2",
    "helpId": "ATan2",
    "shortDescription": "calculate arctangent of y/x",
    "version": "2.0",
    "synopsis": "result = ATan2(y, x)",
    "functionDocs": "Calculates the arctangent of `y/x`. If `x` is 0, `ATan2()` returns 0.",
    "inputsDocs": "* `y` — denominator\n* `x` — numerator",
    "resultsDocs": "* `result` — arctangent of `y/x`",
    "platforms": ["All"],
    "insertText": "ATan2(${1:y}, ${2:x})"
  },
  {
    "name": "BitClear",
    "helpId": "BitClear",
    "shortDescription": "clear a bit",
    "version": "2.0",
    "synopsis": "n = BitClear(x, b)",
    "functionDocs": "Clears bit number `b` in `x`.",
    "inputsDocs": "* `x` — source value\n* `b` — bit to clear (0-31)",
    "resultsDocs": "* `n` — cleared value",
    "example": "```\nPrint(BinStr(BitClear(Val(\"%11111111\"), 2)))\n```\n\nThe code above clears bit number 2 in the value %11111111 which results in the value %11111011.",
    "platforms": ["All"],
    "insertText": "BitClear(${1:x}, ${2:b})"
  },
  {
    "name": "BitComplement",
    "helpId": "BitComplement",
    "shortDescription": "complement a value",
    "version": "2.0",
    "synopsis": "n = BitComplement(x)",
    "functionDocs": "This function inverts all bits in `x`. `x` is treated as a 32-bit integer.",
    "inputsDocs": "* `x` — source value",
    "resultsDocs": "* `n` — inverted value",
    "example": "```\nPrint(BinStr(BitComplement(Val(\"%11110000\"))))\n```\n\nThe code above inverts the value %11110000 and returns it to you as a 32-bit integer value (%11111111111111111111111100001111)",
    "platforms": ["All"],
    "insertText": "BitComplement(${1:x})"
  },
  {
    "name": "BitSet",
    "helpId": "BitSet",
    "shortDescription": "set a bit",
    "version": "2.0",
    "synopsis": "n = BitSet(x, b)",
    "functionDocs": "Sets bit number `b` in `x` and returns the result.",
    "inputsDocs": "* `x` — source value\n* `b` — bit to set",
    "resultsDocs": "* `n` — result of operation",
    "example": "```\nPrint(BinStr(BitSet(Val(\"%10111111\"), 6)))\n```\n\nThe code above sets bit 6 in the value %10111111 and returns the result which is %11111111.",
    "platforms": ["All"],
    "insertText": "BitSet(${1:x}, ${2:b})"
  },
  {
    "name": "BitTest",
    "helpId": "BitTest",
    "shortDescription": "test if a bit is set",
    "version": "2.0",
    "synopsis": "bool = BitTest(x, b)",
    "functionDocs": "Tests if bit number `b` is set in `x` and returns `True` if this is the case, `False` otherwise.",
    "inputsDocs": "* `x` — source value\n* `b` — bit to test",
    "resultsDocs": "* `bool` — `True` if the bit is set, else `False`",
    "example": "```\nPrint(BitTest(Val(\"%10101111\"), 4))\n```\n\nReturns `False` because bit number 4 is not set in %10101111.",
    "platforms": ["All"],
    "insertText": "BitTest(${1:x}, ${2:b})"
  },
  {
    "name": "BitXor",
    "helpId": "BitXor",
    "shortDescription": "bitwise xor two values",
    "version": "2.0",
    "synopsis": "r = BitXor(a, b)",
    "functionDocs": "Performs a bitwise xor operation on `a` and `b` and returns the result. The exclusive-or operation will set each bit in the resulting value only if the corresponding bit is set in one of the source values. If the bit is set in both source values, it will not be set in the resulting value.",
    "inputsDocs": "* `a` — source value 1\n* `b` — source value 2",
    "resultsDocs": "* `r` — result of the bitwise xor",
    "example": "```\nPrint(BinStr(BitXor(Val(\"%11010001\"), Val(\"%10110010\")))\n```\n\nPerforms exclusive-or on the values %11010001 and %10110010 which results in the value %01100011.",
    "platforms": ["All"],
    "insertText": "BitXor(${1:a}, ${2:b})"
  },
  {
    "name": "Cast",
    "helpId": "Cast",
    "shortDescription": "cast a number to a new signed/unsigned type",
    "version": "3.0",
    "synopsis": "result = Cast(val, sign, type)",
    "functionDocs": "This function can be used to cast a value to a different type. This is normally not needed in Hollywood because Hollywood only knows one variable type for numbers (all numbers in Hollywood are stored as signed 64-bit floating point values; Hollywood does not differentiate between byte, short, integer, and floating point types internally). Thus, what you receive in `result` will not really be a variable of the type you have cast it to, but it will just be clipped to the boundaries of the variable type you specify.\n\nHowever, this function can come in quite handy when it comes to do signed and unsigned conversions. You might want to know which number you get when you want to convert 41234 to a signed short value. You can use this function to do that.\n\n`Cast()` accepts three arguments: The first argument is the value that shall be cast, the second argument specifies whether or not you want a signed value and must be either `True` (= cast to signed) or `False` (= cast to unsigned). The last argument finally specifies the type the value shall be cast to. This can be `#INTEGER` (32-bit), `#SHORT` (16-bit) or `#BYTE` (8-bit).",
    "inputsDocs": "* `val` — source value to be cast\n* `sign` — `True` (signed cast) or `False` (unsigned cast)\n* `type` — destination type for the value (`#INTEGER`, `#SHORT` or `#BYTE`)",
    "resultsDocs": "* `result` — result of the cast operation",
    "example": "```\nPrint(Cast(41234, TRUE, #SHORT))\n```\n\nThe code above casts the number 41234 to a signed short (16-bit) value and prints the result which is -(2^16-41234) = -24302.",
    "platforms": ["All"],
    "insertText": "Cast(${1:val}, ${2:sign}, ${3:type})"
  },
  {
    "name": "Ceil",
    "helpId": "Ceil",
    "shortDescription": "calculate ceiling of a value",
    "version": "2.0",
    "synopsis": "result = Ceil(x)",
    "functionDocs": "Calculates the ceiling of `x`. The ceiling of a value is the smallest integer that is greater than or equal to it, e.g. the ceiling of 1.5 is 2, the ceiling of -1.5 is -1.",
    "inputsDocs": "* `x` — value whose ceiling is to be calculated",
    "resultsDocs": "* `result` — ceiling of `x`",
    "platforms": ["All"],
    "insertText": "Ceil(${1:x})"
  },
  {
    "name": "Cos",
    "helpId": "Cos",
    "shortDescription": "calculate cosine",
    "version": "1.5",
    "synopsis": "result = Cos(x)",
    "functionDocs": "Calculates the cosine of the angle `x`.",
    "inputsDocs": "* `x` — angle in radians",
    "resultsDocs": "* `result` — cosine of `x`",
    "platforms": ["All"],
    "insertText": "Cos(${1:x})"
  },
  {
    "name": "Deg",
    "helpId": "Deg",
    "shortDescription": "convert radians to degrees",
    "version": "2.0",
    "synopsis": "result = Deg(x)",
    "functionDocs": "Converts the radians specified in `x` to degrees.",
    "inputsDocs": "* `x` — radian value which should be converted to degrees",
    "resultsDocs": "* `result` — degrees of `x`",
    "platforms": ["All"],
    "insertText": "Deg(${1:x})"
  },
  {
    "name": "Div",
    "helpId": "Div",
    "shortDescription": "divide value by a factor",
    "version": "1.0",
    "synopsis": "result = Div(value1, value2)",
    "functionDocs": "Divides `value1` by `value2` and returns the result.\n\nNote that although the division will use floating point precision, `value2` must not be 0. If you need to divide by zero in floating point, use [RawDiv()](https://www.hollywood-mal.com/docs/html/hollywood/RawDiv_.html) instead. See [RawDiv](https://www.hollywood-mal.com/docs/html/hollywood/RawDiv_.html).",
    "inputsDocs": "* `value1` — numerator\n* `value2` — denominator",
    "resultsDocs": "* `result` — result of the division",
    "example": "```\na=16\nDiv(a,4)\nPrint(a)\n```\n\nThis will print \"4\" to the screen.",
    "platforms": ["All"],
    "insertText": "Div(${1:value1}, ${2:value2})"
  },
  {
    "name": "EndianSwap",
    "helpId": "EndianSwap",
    "shortDescription": "swap byte order of a value",
    "version": "6.0",
    "synopsis": "result = EndianSwap(val, bits)",
    "functionDocs": "This function swaps the byte order in `val`. The additional parameter `bits` specifies how many bits should be taken into account and can be either 16 or 32.",
    "inputsDocs": "* `val` — input value\n* `bits` — operation length in bits",
    "resultsDocs": "* `result` — swapped bytes",
    "example": "```\nDebugPrint(HexStr(EndianSwap($ABCD, 16)))\n```\n\nThis prints $CDAB.",
    "platforms": ["All"],
    "insertText": "EndianSwap(${1:val}, ${2:bits})"
  },
  {
    "name": "Exp",
    "helpId": "Exp",
    "shortDescription": "calculate the exponential of a value",
    "version": "2.0",
    "synopsis": "result = Exp(x)",
    "functionDocs": "Calculates the exponential value of `x` (e ^ x).",
    "inputsDocs": "* `x` — value whose exponential is to be calculated",
    "resultsDocs": "* `result` — natural exponential of `x`",
    "platforms": ["All"],
    "insertText": "Exp(${1:x})"
  },
  {
    "name": "Floor",
    "helpId": "Floor",
    "shortDescription": "calculate the floor of a value",
    "version": "2.0",
    "synopsis": "result = Floor(x)",
    "functionDocs": "Calculates the floor of `x`. The floor of a value is the largest integer that is less than or equal to it, e.g. the floor for 1.5 is 1, the floor for -1.5 is -2.",
    "inputsDocs": "* `x` — value whose floor is to be calculated",
    "resultsDocs": "* `result` — floor of `x`",
    "platforms": ["All"],
    "insertText": "Floor(${1:x})"
  },
  {
    "name": "Frac",
    "helpId": "Frac",
    "shortDescription": "return fractional part of a float",
    "version": "1.5",
    "synopsis": "result = Frac(val)",
    "functionDocs": "This function returns the fractional part of a float.",
    "inputsDocs": "* `val` — source value",
    "resultsDocs": "* `result` — fractional part of `val`",
    "example": "```\na = Frac(3.14156)\n```\n\nThe variable `a` is set to 0.14156.",
    "platforms": ["All"],
    "insertText": "Frac(${1:val})"
  },
  {
    "name": "FrExp",
    "helpId": "FrExp",
    "shortDescription": "extract mantissa and exponent from real number",
    "version": "2.0",
    "synopsis": "m, exp = FrExp(x)",
    "functionDocs": "This function can be used to extract the mantissa and exponent of `x`. The mantissa is returned in the first return value, the exponent in the second.",
    "inputsDocs": "* `x` — floating point value to use",
    "resultsDocs": "* `m` — mantissa of floating point value\n* `exp` — exponent of floating point value",
    "platforms": ["All"],
    "insertText": "FrExp(${1:x})"
  },
  {
    "name": "Hypot",
    "helpId": "Hypot",
    "shortDescription": "calculate the hypotenuse",
    "version": "5.0",
    "synopsis": "h = Hypot(x, y)",
    "functionDocs": "This function can be used to calculate the hypotenuse of a right triangle. You have to pass the length of the two sides in `x` and `y`. A call to `Hypot()` is the same as the square root of x*x + y*y.",
    "inputsDocs": "* `x` — length of triangle side\n* `y` — length of triangle side",
    "resultsDocs": "* `h` — hypotenuse of triangle",
    "platforms": ["All"],
    "insertText": "Hypot(${1:x}, ${2:y})"
  },
  {
    "name": "Int",
    "helpId": "Int",
    "shortDescription": "return integer part of a float",
    "version": "1.5",
    "synopsis": "result = Int(val)",
    "functionDocs": "This function returns the integer part of a floating point number.",
    "inputsDocs": "* `val` — source value",
    "resultsDocs": "* `result` — integer part of `val`",
    "example": "```\na = Int(4.5)\n```\n\nThis call returns 4.",
    "platforms": ["All"],
    "insertText": "Int(${1:val})"
  },
  {
    "name": "IsFinite",
    "helpId": "IsFinite",
    "shortDescription": "check for finiteness",
    "version": "9.0",
    "synopsis": "result = IsFinite(x)",
    "functionDocs": "Checks if `x` is a finite value. A finite value is defined as any floating point value that is neither NaN nor infinity.\n\nSee [IsNan](https://www.hollywood-mal.com/docs/html/hollywood/IsNan_.html).\n\nSee [IsInf](https://www.hollywood-mal.com/docs/html/hollywood/IsInf_.html).",
    "inputsDocs": "* `x` — value to check",
    "resultsDocs": "* `result` — `True` if `x` is a finite value, `False` otherwise",
    "example": "```\na=RawDiv(1,0)  ; infinity, non-finite\nb=RawDiv(0,0)  ; NaN, non-finite\nc=RawDiv(5,2)  ; 2.5, finite\nPrint(IsFinite(a), IsFinite(b), IsFinite(c))\n```\n\nThis will print \"0 0 1\" to the screen because the first two values are non-finite whereas the last value is finite. Note that we need to use [RawDiv()](https://www.hollywood-mal.com/docs/html/hollywood/RawDiv_.html) here because the division operator as well as [Div()](https://www.hollywood-mal.com/docs/html/hollywood/Div_.html) will not allow a division by zero.",
    "platforms": ["All"],
    "insertText": "IsFinite(${1:x})"
  },
  {
    "name": "IsInf",
    "helpId": "IsInf",
    "shortDescription": "check for infinity",
    "version": "9.0",
    "synopsis": "result = IsInf(x)",
    "functionDocs": "Checks if `x` is an infinity value (positive or negative). Positive and negative infinity values are generated when dividing 1/-1 by zero in floating point.\n\nHollywood also has a predefined constant named `#INF` that contains the infinity value but the preferred way of checking against infinity is using `IsInf()`.",
    "inputsDocs": "* `x` — value to check",
    "resultsDocs": "* `result` — `True` if `x` is an infinity value, `False` otherwise",
    "example": "```\na=RawDiv(1,0)\nPrint(IsInf(a))\n```\n\nThis will print \"1\" to the screen because the division 1/0 will yield an infinity value. Note that we need to use [RawDiv()](https://www.hollywood-mal.com/docs/html/hollywood/RawDiv_.html) here because the division operator as well as [Div()](https://www.hollywood-mal.com/docs/html/hollywood/Div_.html) will not allow a division by zero.",
    "platforms": ["All"],
    "insertText": "IsInf(${1:x})"
  },
  {
    "name": "IsNan",
    "helpId": "IsNan",
    "shortDescription": "check if value is NaN",
    "version": "9.0",
    "synopsis": "result = IsNan(x)",
    "functionDocs": "Checks if `x` is a special NaN value (not-a-number). NaN is a special return value for undefined floating point numbers such as the result of 0/0 or the square root of negative numbers.\n\nNote that you should not test for NaN by comparing a number with itself, expecting to get `False`. This won't work on all platforms. Using `IsNan()` is the only portable way to check if a value is NaN.\n\nThe value of NaN is also in a predefined constant named `#NAN` but due to the design of Hollywood's parser you may only access this value using the [GetConstant()](https://www.hollywood-mal.com/docs/html/hollywood/GetConstant_.html) function. Using it literally in a script, i.e. outside a string, will fail.",
    "inputsDocs": "* `x` — value to check",
    "resultsDocs": "* `result` — `True` if `x` is a NaN value, `False` otherwise",
    "example": "```\na=RawDiv(0,0)\nPrint(IsNan(a))\n```\n\nThis will print \"1\" to the screen because the result of 0/0 is NaN. Note that we need to use [RawDiv()](https://www.hollywood-mal.com/docs/html/hollywood/RawDiv_.html) here because the division operator as well as [Div()](https://www.hollywood-mal.com/docs/html/hollywood/Div_.html) will not allow a division by zero.",
    "platforms": ["All"],
    "insertText": "IsNan(${1:x})"
  },
  {
    "name": "Ld",
    "helpId": "Ld",
    "shortDescription": "calculate base-2 logarithm",
    "version": "1.5",
    "synopsis": "result = Ld(val)",
    "functionDocs": "This function calculates and returns the base-2 logarithm of `val`.",
    "inputsDocs": "* `val` — source value",
    "resultsDocs": "* `result` — base-2 logarithm of val",
    "example": "```\na = Ld(8)\n```\n\nThis returns 3.",
    "platforms": ["All"],
    "insertText": "Ld(${1:val})"
  },
  {
    "name": "LdExp",
    "helpId": "LdExp",
    "shortDescription": "compute real number from mantissa and exponent",
    "version": "2.0",
    "synopsis": "r = LdExp(m, exp)",
    "functionDocs": "This function can be used to compute a real number from the specified mantissa and exponent. It returns the value resulting from multiplying `m` by 2 raised to the power of `exp`.",
    "inputsDocs": "* `m` — mantissa\n* `exp` — exponent",
    "resultsDocs": "* `r` — real number result",
    "platforms": ["All"],
    "insertText": "LdExp(${1:m}, ${2:exp})"
  },
  {
    "name": "Limit",
    "helpId": "Limit",
    "shortDescription": "limit the range of a number",
    "version": "2.0",
    "synopsis": "n = Limit(x, low, high)",
    "functionDocs": "Limits the range of `x`. If `x` is greater than or equal to `low` and less than or equal to `high`, the value of `x` is returned. If `x` is less than `low`, then `low` is returned. If `x` is greater than `high`, then `high` is returned.\n\nThis function ensures that the value of `x` stays in the boundaries defined by `low` and `high`.",
    "inputsDocs": "* `x` — value to examine",
    "resultsDocs": "* `n` — result of limit operation",
    "platforms": ["All"],
    "insertText": "Limit(${1:x}, ${2:low}, ${3:high})"
  },
  {
    "name": "Ln",
    "helpId": "Ln",
    "shortDescription": "calculate natural logarithm (base e)",
    "version": "1.5",
    "synopsis": "result = Ln(val)",
    "functionDocs": "This function calculates and returns the natural logarithm of `val` (using base e).",
    "inputsDocs": "* `val` — source value",
    "resultsDocs": "* `result` — natural logarithm of `val`",
    "platforms": ["All"],
    "insertText": "Ln(${1:val})"
  },
  {
    "name": "Log",
    "helpId": "Log",
    "shortDescription": "calculate logarithm for any base",
    "version": "1.5",
    "synopsis": "result = Log(val, base)",
    "functionDocs": "This function calculates and returns the logarithm for any base of `val`.",
    "inputsDocs": "* `val` — source value\n* `base` — logarithm base",
    "resultsDocs": "* `result` — logarithm of `val` from `base`",
    "example": "```\na = Log(100, 10)\n```\n\nThis returns 2.",
    "platforms": ["All"],
    "insertText": "Log(${1:val}, ${2:base})"
  },
  {
    "name": "Max",
    "helpId": "Max",
    "shortDescription": "return maximum value",
    "version": "1.5",
    "synopsis": "result = Max(a, b, ...)",
    "functionDocs": "This function compares `a` and `b` and returns the value which is greater.\n\nNew in V2.0: You can pass any number of arguments to this function now. It will always return the maximum value of all input values.",
    "inputsDocs": "* `a` — value a\n* `b` — value b\n* `...` — any number of additional values",
    "resultsDocs": "* `result` — maximum value",
    "example": "```\na = Max(9, 10)\n```\n\nThis returns 10.",
    "platforms": ["All"],
    "insertText": "Max(${1:a}, ${2:b})"
  },
  {
    "name": "Min",
    "helpId": "Min",
    "shortDescription": "return minimum value",
    "version": "1.5",
    "synopsis": "result = Min(a, b, ...)",
    "functionDocs": "This function compares `a` and `b` and returns the value which is smaller.\n\nNew in V2.0: You can pass any number of arguments to this function now. It will always return the minimum value of all input values.",
    "inputsDocs": "* `a` — value a\n* `b` — value b\n* `...` — any number of additional values",
    "resultsDocs": "* `result` — minimum value",
    "example": "```\na = Min(9, 10)\n```\n\nThis returns 9.",
    "platforms": ["All"],
    "insertText": "Min(${1:a}, ${2:b})"
  },
  {
    "name": "Mod",
    "helpId": "Mod",
    "shortDescription": "calculate remainder",
    "version": "1.5",
    "synopsis": "result = Mod(a, b)",
    "functionDocs": "This function calculates the remainder of the division `a` / `b`.",
    "inputsDocs": "* `a` — numerator\n* `b` — denominator",
    "resultsDocs": "* `result` — remainder of division",
    "example": "```\na = Mod(30, 4)\n```\n\nThis returns 2 because 30 / 4 is 7 with a remainder of 2.",
    "platforms": ["All"],
    "insertText": "Mod(${1:a}, ${2:b})"
  },
  {
    "name": "Mul",
    "helpId": "Mul",
    "shortDescription": "multiply two values",
    "version": "1.0",
    "synopsis": "result = Mul(value1, value2)",
    "functionDocs": "Multiplies `value1` by `value2` and returns the result.",
    "inputsDocs": "* `value1` — source value\n* `value2` — multiplier",
    "resultsDocs": "* `result` — result of multiplication",
    "example": "```\na=5\na=Mul(a,5)\nPrint(a)\n```\n\nThis will print \"25\" to the screen.",
    "platforms": ["All"],
    "insertText": "Mul(${1:value1}, ${2:value2})"
  },
  {
    "name": "NearlyEqual",
    "helpId": "NearlyEqual",
    "shortDescription": "check for near equality",
    "version": "10.0",
    "synopsis": "result = NearlyEqual(x, y)",
    "functionDocs": "This function compares `x` and `y` and returns `True` if they are nearly equal. This function is only useful for floating point values. The advantage of this function over Hollywood's equality operator is that comparing floating point numbers using the equality operator can lead to problems in case there are extremely minimal differences on the bit level, e.g. caused by (de)serialization. That's why it's recommended to compare floating point numbers against near equality instead of absolute equality for more reliability.",
    "inputsDocs": "* `x` — first operand for comparison\n* `y` — second operand for comparison",
    "resultsDocs": "* `result` — `True` if `x` and `y` are nearly equal, `False` otherwise",
    "platforms": ["All"],
    "insertText": "NearlyEqual(${1:x}, ${2:y})"
  },
  {
    "name": "Pi",
    "helpId": "Pi",
    "shortDescription": "returns the value of pi",
    "version": "1.0",
    "synopsis": "result = Pi()",
    "functionDocs": "This function returns the value of pi.\n\nSince pi is a constant, calling this function to get it is unnecessary overhead. Instead, you can just use Hollywood's inbuilt constant `#PI` to get the value of pi.",
    "inputsDocs": "none",
    "resultsDocs": "* `result` — value of pi, will be the same as the `#PI` constant",
    "example": "```\nPrint(Pi() = #PI)\n```\n\nThis will print \"1\" because the return value of `Pi()` will be the same as `#PI`.",
    "platforms": ["All"],
    "insertText": "Pi()"
  },
  {
    "name": "Pow",
    "helpId": "Pow",
    "shortDescription": "calculate x raised to the power of y",
    "version": "1.5",
    "synopsis": "result = Pow(x, y)",
    "functionDocs": "This function calculates `x` raised to the power of `y`.",
    "inputsDocs": "* `x` — base\n* `y` — exponent",
    "resultsDocs": "* `result` — calculation result",
    "example": "```\na = Pow(2, 8)\n```\n\nThis returns 256.",
    "platforms": ["All"],
    "insertText": "Pow(${1:x}, ${2:y})"
  },
  {
    "name": "Rad",
    "helpId": "Rad",
    "shortDescription": "convert degrees to radians",
    "version": "2.0",
    "synopsis": "result = Rad(x)",
    "functionDocs": "Converts the degrees specified in `x` to radians.",
    "inputsDocs": "* `x` — degree value which should be converted to radians",
    "resultsDocs": "* `result` — radians of `x`",
    "platforms": ["All"],
    "insertText": "Rad(${1:x})"
  },
  {
    "name": "RawDiv",
    "helpId": "RawDiv",
    "shortDescription": "divide value by a factor",
    "version": "9.0",
    "synopsis": "result = RawDiv(value1, value2)",
    "functionDocs": "Divides `value1` by `value2` using floating point precision and returns the result.\n\nThis function does exactly the same as [Div()](https://www.hollywood-mal.com/docs/html/hollywood/Div_.html) except that it also allows a division by zero, making it possible to generate special values like NaN or infinity.\n\nSee [IsNan](https://www.hollywood-mal.com/docs/html/hollywood/IsNan_.html).\n\nSee [IsInf](https://www.hollywood-mal.com/docs/html/hollywood/IsInf_.html).",
    "inputsDocs": "* `value1` — numerator\n* `value2` — denominator",
    "resultsDocs": "* `result` — result of the division",
    "example": "```\na=RawDiv(16,4)\nPrint(a)\n```\n\nThis will print \"4\" to the screen.",
    "platforms": ["All"],
    "insertText": "RawDiv(${1:value1}, ${2:value2})"
  },
  {
    "name": "Rnd",
    "helpId": "Rnd",
    "shortDescription": "generate a random number",
    "version": "1.0",
    "synopsis": "result = Rnd(range)",
    "functionDocs": "Generates a random integer number in the range of 0 to `range` (exclusive).",
    "inputsDocs": "* `range` — upper integer boundary of the random generator",
    "resultsDocs": "* `result` — a random number",
    "example": "```\nnum=Rnd(49)\n```\n\nWell, I cannot predict what value `num` will receive. I can only say that it will not be greater than 48 and not less than zero.",
    "platforms": ["All"],
    "insertText": "Rnd(${1:range})"
  },
  {
    "name": "RndF",
    "helpId": "RndF",
    "shortDescription": "generate a random float",
    "version": "1.5",
    "synopsis": "result = RndF()",
    "functionDocs": "This function returns a random floating point number in the range of 0.0 to 1.0 (exclusive).\n\nNote that before Hollywood 8.0 this function's upper boundary was documented as 1.0 (inclusive). This was wrong. The value returned by `RndF()` is guaranteed to be less than 1.0.",
    "inputsDocs": "none",
    "resultsDocs": "* `result` — a random float in the range of 0.0 to 1.0 (exclusive)",
    "example": "```\nnum = RndF()\n```\n\n`num` is set to random floating point number between 0.0 and 1.0.",
    "platforms": ["All"],
    "insertText": "RndF()"
  },
  {
    "name": "RndStrong",
    "helpId": "RndStrong",
    "shortDescription": "generate a strongly random number",
    "version": "7.1",
    "synopsis": "result = RndStrong(type, param)",
    "functionDocs": "This function can be used to generate cryptographically secure pseudo random numbers. Numbers returned by `RndStrong()` are much more random than those generated by [Rnd()](https://www.hollywood-mal.com/docs/html/hollywood/Rnd_.html) or [RndF()](https://www.hollywood-mal.com/docs/html/hollywood/RndF_.html) both of which aren't appropriate for anything cryptography related.\n\n`RndStrong()` can operate in two different modes: If you pass `#INTEGER` in `type`, it will return a single integer value that won't be smaller than 0 and won't be bigger than the integer passed in `param` (but it could be equal to `param`). If you pass `#STRING` in `type`, `RndStrong()` will generate a string of `param` random bytes, i.e. when passing `#STRING`, `param` specifies the desired length of the string.\n\nBe warned that `RndStrong()` is very slow in comparison to [Rnd()](https://www.hollywood-mal.com/docs/html/hollywood/Rnd_.html) and [RndF()](https://www.hollywood-mal.com/docs/html/hollywood/RndF_.html). That is why you shouldn't call it too often but rather cache its results if you need lots of very random numbers. For example, you could call `RndStrong()` with `type` set to `#STRING` and `param` to 65536 to make it generate a string containing 64kb worth of random numbers. Once you've consumed those, you could call it again for more random numbers.\n\nAlso note that on AmigaOS 3.x and AROS `RndStrong()` currently falls back to [Rnd()](https://www.hollywood-mal.com/docs/html/hollywood/Rnd_.html) because those operating systems don't offer cryptography-proof randomizers.",
    "inputsDocs": "* `type` — type of data to generate; can be either `#INTEGER` or `#STRING` (see above)\n* `param` — greatest acceptable integer number if `type` is `#INTEGER` or the length of the string to generate if `type` is `#STRING`",
    "resultsDocs": "* `result` — random number(s) either as a string or integer value",
    "example": "```\nnum=RndStrong(#INTEGER, 49)\n```\n\nWell, I cannot predict what value `num` will receive. I can only say that it will not be greater than 49 and not smaller than zero.",
    "platforms": ["All"],
    "insertText": "RndStrong(${1:type}, ${2:param})"
  },
  {
    "name": "Rol",
    "helpId": "Rol",
    "shortDescription": "left bit rotation",
    "version": "3.0",
    "synopsis": "result = Rol(a, x[, length])",
    "functionDocs": "This function rotates the bits of value `a` to the left by `x` bits. Bit rotation means that the bits just circle inside `a`, i.e. bits moved out of the left side are appended to the right side.\n\nThe optional argument `length` allows you to specify the length of the rotate operation. By default, this is `#INTEGER` which means that `a` will be regarded as a 32-bit integer value. If you want to do a 16-bit or an 8-bit rotation, you need to use `#SHORT` and `#BYTE`, respectively.",
    "inputsDocs": "* `a` — source value\n* `x` — number of bits to rotate\n* `length` — optional: bit length for this operation (defaults to `#INTEGER` which means 32-bit rotation); use `#SHORT` for 16-bit rotation and `#BYTE` for 8-bit rotation",
    "resultsDocs": "* `result` — rotated value",
    "example": "```\nr = Rol(Val(\"%10011110\"), 4, #BYTE)\nPrint(BinStr(r, #BYTE))\n```\n\nThe code above rotates the binary number %10011110 4 bits to the left and prints the result which is %11101001.",
    "platforms": ["All"],
    "insertText": "Rol(${1:a}, ${2:x})"
  },
  {
    "name": "Ror",
    "helpId": "Ror",
    "shortDescription": "right bit rotation",
    "version": "3.0",
    "synopsis": "result = Ror(a, x[, length])",
    "functionDocs": "This function rotates the bits of value `a` to the right by `x` bits. Bit rotation means that the bits just circle inside `a`, i.e. bits moved out of the right side are appended to the left side.\n\nThe optional argument allows you to specify the length of the rotate operation. By default, this is `#INTEGER` which means that `a` will be regarded as a 32-bit integer value. If you want to do a 16-bit or an 8-bit rotation, you need to use `#SHORT` and `#BYTE`, respectively.",
    "inputsDocs": "* `a` — source value\n* `x` — number of bits to rotate\n* `length` — optional: bit length for this operation (defaults to `#INTEGER` which means 32-bit rotation); use `#SHORT` for 16-bit rotation and `#BYTE` for 8-bit rotation",
    "resultsDocs": "* `result` — rotated value",
    "example": "```\nr = Ror(Val(\"%10011110\"), 2, #BYTE)\nPrint(BinStr(r, #BYTE))\n```\n\nThe code above rotates the binary number %10011110 2 bits to the right and prints the result which is %10100111.",
    "platforms": ["All"],
    "insertText": "Ror(${1:a}, ${2:x})"
  },
  {
    "name": "Round",
    "helpId": "Round",
    "shortDescription": "round a floating point number",
    "version": "1.5",
    "synopsis": "result = Round(x)",
    "functionDocs": "This function rounds `x` to the next integer. In case `x` is exactly between two integers, it will be rounded to the nearest even integer (half to even rounding), i.e. both 1.5 and 2.5 will be rounded to 2.",
    "inputsDocs": "* `x` — floating point number to round",
    "resultsDocs": "* `result` — integer result",
    "example": "```\na = Round(3.7)\n```\n\nThis returns 4.",
    "platforms": ["All"],
    "insertText": "Round(${1:x})"
  },
  {
    "name": "Rt",
    "helpId": "Rt",
    "shortDescription": "calculate root",
    "version": "1.5",
    "synopsis": "result = Rt(x, y)",
    "functionDocs": "This function calculates and returns the `y` root of value `x`.",
    "inputsDocs": "* `x` — source value\n* `y` — root to calculate",
    "resultsDocs": "* `result` — `y` root of `x`",
    "example": "```\na = Rt(27, 3)\n```\n\nThis returns 3.",
    "platforms": ["All"],
    "insertText": "Rt(${1:x}, ${2:y})"
  },
  {
    "name": "Sar",
    "helpId": "Sar",
    "shortDescription": "shift bits to the right",
    "version": "3.0",
    "synopsis": "result = Sar(a, x[, bignum])",
    "functionDocs": "This function shifts `a` by `x` bits to the right padding the holes with the most significant bit of `a`. This is called an arithmetic shift. `a` is converted to a signed 32-bit integer variable before the shift (unless `bignum` is set to `True`).\n\nStarting with Hollywood 9.0, there is an optional `bignum` argument. If this is set to `True`, `Sar()` will be able to operate on integers larger than 2^31 but keep in mind that `Sar()` still won't be possible to use the full 64-bit integer range because Hollywood's numeric type is a 64-bit floating point number and is thus limited to integers in the range of [-9007199254740992,9007199254740992].",
    "inputsDocs": "* `a` — source value\n* `x` — number of bits to shift\n* `bignum` — optional: whether or not to use 64-bit integers (defaults to `False`) (V9.0)",
    "resultsDocs": "* `result` — integer result",
    "example": "```\na = Sar(-256, 3)\n```\n\nThis returns -32.",
    "platforms": ["All"],
    "insertText": "Sar(${1:a}, ${2:x})"
  },
  {
    "name": "Sgn",
    "helpId": "Sgn",
    "shortDescription": "return the sign of a value",
    "version": "2.0",
    "synopsis": "sign = Sgn(x)",
    "functionDocs": "Returns the sign of `x`. If `x` is less than 0, -1 is returned. If `x` is greater than 0, 1 is returned. If `x` is equal to 0, 0 is returned.",
    "inputsDocs": "* `x` — value to examine",
    "resultsDocs": "* `sign` — sign of `x`",
    "platforms": ["All"],
    "insertText": "Sgn(${1:x})"
  },
  {
    "name": "Shl",
    "helpId": "Shl",
    "shortDescription": "shift bits to the left",
    "version": "1.5",
    "synopsis": "result = Shl(a, x[, bignum])",
    "functionDocs": "This function shifts `a` by `x` bits to the left, padding the holes with zero bits. This is called a logical shift. `a` is converted to an unsigned 32-bit integer variable before the shift (unless `bignum` is set to `True`).\n\nStarting with Hollywood 9.0, there is an optional `bignum` argument. If this is set to `True`, `Shl()` will be able to operate on integers larger than 2^31 but keep in mind that `Shl()` still won't be possible to use the full 64-bit integer range because Hollywood's numeric type is a 64-bit floating point number and is thus limited to integers in the range of [-9007199254740992,9007199254740992].",
    "inputsDocs": "* `a` — source value\n* `x` — number of bits to shift\n* `bignum` — optional: whether or not to use 64-bit integers (defaults to `False`) (V9.0)",
    "resultsDocs": "* `result` — integer result",
    "example": "```\na = Shl(256, 3)\n```\n\nThis returns 2048.",
    "platforms": ["All"],
    "insertText": "Shl(${1:a}, ${2:x})"
  },
  {
    "name": "Shr",
    "helpId": "Shr",
    "shortDescription": "shift bits to the right",
    "version": "1.5",
    "synopsis": "result = Shr(a, x[, bignum])",
    "functionDocs": "This function shifts `a` by `x` bits to the right, padding the holes with zero bits. This is called a logical shift. `a` is converted to an unsigned 32-bit integer variable before the shift (unless `bignum` is set to `True`).\n\nStarting with Hollywood 9.0, there is an optional `bignum` argument. If this is set to `True`, `Shr()` will be able to operate on integers larger than 2^31 but keep in mind that `Shr()` still won't be possible to use the full 64-bit integer range because Hollywood's numeric type is a 64-bit floating point number and is thus limited to integers in the range of [-9007199254740992,9007199254740992].",
    "inputsDocs": "* `a` — source value\n* `x` — number of bits to shift\n* `bignum` — optional: whether or not to use 64-bit integers (defaults to `False`) (V9.0)",
    "resultsDocs": "* `result` — integer result",
    "example": "```\na = Shr(256, 3)\n```\n\nThis returns 32.",
    "platforms": ["All"],
    "insertText": "Shr(${1:a}, ${2:x})"
  },
  {
    "name": "Sin",
    "helpId": "Sin",
    "shortDescription": "calculate sine",
    "version": "1.5",
    "synopsis": "result = Sin(x)",
    "functionDocs": "Calculates the sine of the angle `x`.",
    "inputsDocs": "* `x` — angle in radians",
    "resultsDocs": "* `result` — sine of `x`",
    "platforms": ["All"],
    "insertText": "Sin(${1:x})"
  },
  {
    "name": "Sqrt",
    "helpId": "Sqrt",
    "shortDescription": "calculate square root",
    "version": "1.5",
    "synopsis": "result = Sqrt(x)",
    "functionDocs": "This function calculates and returns the square root of `x`.",
    "inputsDocs": "* `x` — source value",
    "resultsDocs": "* `result` — square root of `x`",
    "example": "```\na = Sqrt(64)\n```\n\nThis returns 8.",
    "platforms": ["All"],
    "insertText": "Sqrt(${1:x})"
  },
  {
    "name": "Sub",
    "helpId": "Sub",
    "shortDescription": "subtract value from a value",
    "version": "1.0",
    "synopsis": "result = Sub(value1, value2)",
    "functionDocs": "Subtracts `value2` from `value1` and returns the result.",
    "inputsDocs": "* `value1` — minuend\n* `value2` — subtrahend",
    "resultsDocs": "* `result` — result of the subtraction",
    "example": "```\na=1\na=Sub(a,1)\nPrint(a)\n```\n\nThe above code will print \"0\" to the screen.",
    "platforms": ["All"],
    "insertText": "Sub(${1:value1}, ${2:value2})"
  },
  {
    "name": "Tan",
    "helpId": "Tan",
    "shortDescription": "calculate tangent",
    "version": "1.5",
    "synopsis": "result = Tan(x)",
    "functionDocs": "Calculates the tangent of the angle `x`.",
    "inputsDocs": "* `x` — angle in radians",
    "resultsDocs": "* `result` — tangent of `x`",
    "platforms": ["All"],
    "insertText": "Tan(${1:x})"
  },
  {
    "name": "Wrap",
    "helpId": "Wrap",
    "shortDescription": "wrap values",
    "version": "1.5",
    "synopsis": "result = Wrap(x, low, high)",
    "functionDocs": "Wrap will wrap the result of `x` if `x` is greater than or equal to `high`, or less than `low`. If `x` is less than `low`, then `x-low+high` is returned. If `x` is greater than or equal to `high`, then `x-high+low` is returned.",
    "inputsDocs": "* `x` — source value\n* `low` — low value\n* `high` — high value",
    "resultsDocs": "* `result` — result of operation",
    "platforms": ["All"],
    "insertText": "Wrap(${1:x}, ${2:low}, ${3:high})"
  }
]
